{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"source/article_img/2022-05-30-18-51-12.png","path":"article_img/2022-05-30-18-51-12.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-30-19-01-47.png","path":"article_img/2022-05-30-19-01-47.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-30-19-02-18.png","path":"article_img/2022-05-30-19-02-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-30-19-03-35.png","path":"article_img/2022-05-30-19-03-35.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-30-19-12-19.png","path":"article_img/2022-05-30-19-12-19.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-31-14-18-58.png","path":"article_img/2022-05-31-14-18-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-31-15-45-30.png","path":"article_img/2022-05-31-15-45-30.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-31-15-48-06.png","path":"article_img/2022-05-31-15-48-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-31-15-48-55.png","path":"article_img/2022-05-31-15-48-55.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-31-15-59-31.png","path":"article_img/2022-05-31-15-59-31.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-31-16-12-25.png","path":"article_img/2022-05-31-16-12-25.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-31-16-12-50.png","path":"article_img/2022-05-31-16-12-50.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-31-16-22-07.png","path":"article_img/2022-05-31-16-22-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-05-31-16-23-44.png","path":"article_img/2022-05-31-16-23-44.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-06-20-14-08-41.png","path":"article_img/2022-06-20-14-08-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-06-06-18-35-54.png","path":"article_img/2022-06-06-18-35-54.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-06-20-18-05-00.png","path":"article_img/2022-06-20-18-05-00.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-06-20-14-41-24.png","path":"article_img/2022-06-20-14-41-24.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-06-20-18-11-02.png","path":"article_img/2022-06-20-18-11-02.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-07-21-13-46-46.png","path":"article_img/2022-07-21-13-46-46.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-07-21-13-53-30.png","path":"article_img/2022-07-21-13-53-30.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-07-21-13-55-49.png","path":"article_img/2022-07-21-13-55-49.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-07-21-14-00-29.png","path":"article_img/2022-07-21-14-00-29.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-07-21-14-08-35.png","path":"article_img/2022-07-21-14-08-35.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-07-21-14-10-55.png","path":"article_img/2022-07-21-14-10-55.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-07-21-14-15-24.png","path":"article_img/2022-07-21-14-15-24.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-07-21-14-12-24.png","path":"article_img/2022-07-21-14-12-24.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-18-08-53.png","path":"article_img/2022-08-01-18-08-53.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-18-03-38.png","path":"article_img/2022-08-01-18-03-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-18-15-35.png","path":"article_img/2022-08-01-18-15-35.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-18-23-48.png","path":"article_img/2022-08-01-18-23-48.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-18-34-08.png","path":"article_img/2022-08-01-18-34-08.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-18-43-06.png","path":"article_img/2022-08-01-18-43-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-18-27-54.png","path":"article_img/2022-08-01-18-27-54.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-18-50-39.png","path":"article_img/2022-08-01-18-50-39.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-18-53-06.png","path":"article_img/2022-08-01-18-53-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-01-20-43-53.png","path":"article_img/2022-08-01-20-43-53.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-03-10-12-36.png","path":"article_img/2022-08-03-10-12-36.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-03-10-31-16.png","path":"article_img/2022-08-03-10-31-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-03-10-22-45.png","path":"article_img/2022-08-03-10-22-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-03-10-39-27.png","path":"article_img/2022-08-03-10-39-27.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-03-17-35-43.png","path":"article_img/2022-08-03-17-35-43.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-03-20-29-06.png","path":"article_img/2022-08-03-20-29-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-03-20-32-33.png","path":"article_img/2022-08-03-20-32-33.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-03-20-33-34.png","path":"article_img/2022-08-03-20-33-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-03-20-33-50.png","path":"article_img/2022-08-03-20-33-50.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-10-16-12-45.png","path":"article_img/2022-08-10-16-12-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-11-08-56-46.png","path":"article_img/2022-08-11-08-56-46.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-11-11-15-21.png","path":"article_img/2022-08-11-11-15-21.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-26-15-10-45.png","path":"article_img/2022-08-26-15-10-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-26-15-12-11.png","path":"article_img/2022-08-26-15-12-11.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-26-15-13-22.png","path":"article_img/2022-08-26-15-13-22.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-26-15-16-08.png","path":"article_img/2022-08-26-15-16-08.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-27-09-09-18.png","path":"article_img/2022-08-27-09-09-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-27-09-10-34.png","path":"article_img/2022-08-27-09-10-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-27-09-10-47.png","path":"article_img/2022-08-27-09-10-47.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-27-09-14-04.png","path":"article_img/2022-08-27-09-14-04.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-27-09-15-15.png","path":"article_img/2022-08-27-09-15-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-27-09-17-28.png","path":"article_img/2022-08-27-09-17-28.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-27-09-21-07.png","path":"article_img/2022-08-27-09-21-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-27-09-21-26.png","path":"article_img/2022-08-27-09-21-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-27-09-21-42.png","path":"article_img/2022-08-27-09-21-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-18-27.png","path":"article_img/2022-08-29-15-18-27.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-14-39.png","path":"article_img/2022-08-29-15-14-39.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-18-42.png","path":"article_img/2022-08-29-15-18-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-20-23.png","path":"article_img/2022-08-29-15-20-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-23-14.png","path":"article_img/2022-08-29-15-23-14.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-35-09.png","path":"article_img/2022-08-29-15-35-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-38-15.png","path":"article_img/2022-08-29-15-38-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-39-32.png","path":"article_img/2022-08-29-15-39-32.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-42-40.png","path":"article_img/2022-08-29-15-42-40.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-48-55.png","path":"article_img/2022-08-29-15-48-55.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-49-44.png","path":"article_img/2022-08-29-15-49-44.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-50-45.png","path":"article_img/2022-08-29-15-50-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-15-51-54.png","path":"article_img/2022-08-29-15-51-54.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-16-17-54.png","path":"article_img/2022-08-29-16-17-54.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-16-18-04.png","path":"article_img/2022-08-29-16-18-04.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-16-22-31.png","path":"article_img/2022-08-29-16-22-31.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-16-23-23.png","path":"article_img/2022-08-29-16-23-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-16-24-37.png","path":"article_img/2022-08-29-16-24-37.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-16-24-47.png","path":"article_img/2022-08-29-16-24-47.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-16-29-49.png","path":"article_img/2022-08-29-16-29-49.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-16-32-11.png","path":"article_img/2022-08-29-16-32-11.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-30-33.png","path":"article_img/2022-08-29-18-30-33.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-16-32-22.png","path":"article_img/2022-08-29-16-32-22.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-33-20.png","path":"article_img/2022-08-29-18-33-20.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-33-36.png","path":"article_img/2022-08-29-18-33-36.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-35-15.png","path":"article_img/2022-08-29-18-35-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-35-24.png","path":"article_img/2022-08-29-18-35-24.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-41-41.png","path":"article_img/2022-08-29-18-41-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-44-02.png","path":"article_img/2022-08-29-18-44-02.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-41-51.png","path":"article_img/2022-08-29-18-41-51.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-53-37.png","path":"article_img/2022-08-29-18-53-37.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-52-05.png","path":"article_img/2022-08-29-18-52-05.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-54-29.png","path":"article_img/2022-08-29-18-54-29.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-54-37.png","path":"article_img/2022-08-29-18-54-37.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-18-56-35.png","path":"article_img/2022-08-29-18-56-35.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-19-00-41.png","path":"article_img/2022-08-29-19-00-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-19-00-52.png","path":"article_img/2022-08-29-19-00-52.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-19-04-50.png","path":"article_img/2022-08-29-19-04-50.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-19-06-16.png","path":"article_img/2022-08-29-19-06-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-08-29-19-06-26.png","path":"article_img/2022-08-29-19-06-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-26-14-26-50.png","path":"article_img/2022-09-26-14-26-50.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-26-14-28-48.png","path":"article_img/2022-09-26-14-28-48.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-26-21-01-37.png","path":"article_img/2022-09-26-21-01-37.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-26-21-08-46.png","path":"article_img/2022-09-26-21-08-46.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-27-11-50-26.png","path":"article_img/2022-09-27-11-50-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-27-11-50-57.png","path":"article_img/2022-09-27-11-50-57.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-27-13-10-42.png","path":"article_img/2022-09-27-13-10-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-27-19-39-22.png","path":"article_img/2022-09-27-19-39-22.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-28-16-15-11.png","path":"article_img/2022-09-28-16-15-11.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-29-15-43-18.png","path":"article_img/2022-09-29-15-43-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-29-15-45-06.png","path":"article_img/2022-09-29-15-45-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-29-15-45-22.png","path":"article_img/2022-09-29-15-45-22.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-29-15-45-33.png","path":"article_img/2022-09-29-15-45-33.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-29-15-52-40.png","path":"article_img/2022-09-29-15-52-40.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-09-30-14-48-32.png","path":"article_img/2022-09-30-14-48-32.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-08-14-54-52.png","path":"article_img/2022-10-08-14-54-52.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-08-14-55-02.png","path":"article_img/2022-10-08-14-55-02.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-09-14-06-32.png","path":"article_img/2022-10-09-14-06-32.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-09-14-25-53.png","path":"article_img/2022-10-09-14-25-53.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-09-14-28-04.png","path":"article_img/2022-10-09-14-28-04.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-09-14-51-30.png","path":"article_img/2022-10-09-14-51-30.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-09-14-51-38.png","path":"article_img/2022-10-09-14-51-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-09-14-52-21.png","path":"article_img/2022-10-09-14-52-21.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-09-15-26-37.png","path":"article_img/2022-10-09-15-26-37.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-17-42-00.png","path":"article_img/2022-10-11-17-42-00.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-17-42-58.png","path":"article_img/2022-10-11-17-42-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-17-45-24.png","path":"article_img/2022-10-11-17-45-24.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-17-46-35.png","path":"article_img/2022-10-11-17-46-35.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-17-50-28.png","path":"article_img/2022-10-11-17-50-28.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-17-54-18.png","path":"article_img/2022-10-11-17-54-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-17-57-15.png","path":"article_img/2022-10-11-17-57-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-08-40.png","path":"article_img/2022-10-11-18-08-40.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-10-27.png","path":"article_img/2022-10-11-18-10-27.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-12-37.png","path":"article_img/2022-10-11-18-12-37.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-18-49.png","path":"article_img/2022-10-11-18-18-49.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-19-43.png","path":"article_img/2022-10-11-18-19-43.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-30-32.png","path":"article_img/2022-10-11-18-30-32.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-32-03.png","path":"article_img/2022-10-11-18-32-03.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-30-38.png","path":"article_img/2022-10-11-18-30-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-35-53.png","path":"article_img/2022-10-11-18-35-53.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-36-23.png","path":"article_img/2022-10-11-18-36-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-40-01.png","path":"article_img/2022-10-11-18-40-01.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-40-53.png","path":"article_img/2022-10-11-18-40-53.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-11-18-41-58.png","path":"article_img/2022-10-11-18-41-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-11-59-26.png","path":"article_img/2022-10-12-11-59-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-03-15.png","path":"article_img/2022-10-12-12-03-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-04-58.png","path":"article_img/2022-10-12-12-04-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-08-22.png","path":"article_img/2022-10-12-12-08-22.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-12-57.png","path":"article_img/2022-10-12-12-12-57.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-28-37.png","path":"article_img/2022-10-12-12-28-37.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-30-45.png","path":"article_img/2022-10-12-12-30-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-34-50.png","path":"article_img/2022-10-12-12-34-50.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-38-07.png","path":"article_img/2022-10-12-12-38-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-40-29.png","path":"article_img/2022-10-12-12-40-29.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-46-03.png","path":"article_img/2022-10-12-12-46-03.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-51-23.png","path":"article_img/2022-10-12-12-51-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-12-57-17.png","path":"article_img/2022-10-12-12-57-17.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-13-03-11.png","path":"article_img/2022-10-12-13-03-11.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-13-10-52.png","path":"article_img/2022-10-12-13-10-52.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-13-12-07.png","path":"article_img/2022-10-12-13-12-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-19-16-44.png","path":"article_img/2022-10-12-19-16-44.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-19-17-41.png","path":"article_img/2022-10-12-19-17-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-19-18-35.png","path":"article_img/2022-10-12-19-18-35.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-19-20-22.png","path":"article_img/2022-10-12-19-20-22.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-19-20-11.png","path":"article_img/2022-10-12-19-20-11.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-12-19-20-41.png","path":"article_img/2022-10-12-19-20-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-14-37-13.png","path":"article_img/2022-10-13-14-37-13.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-14-37-15.png","path":"article_img/2022-10-13-14-37-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-14-40-09.png","path":"article_img/2022-10-13-14-40-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-14-41-58.png","path":"article_img/2022-10-13-14-41-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-14-42-30.png","path":"article_img/2022-10-13-14-42-30.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-14-42-38.png","path":"article_img/2022-10-13-14-42-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-14-45-56.png","path":"article_img/2022-10-13-14-45-56.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-14-50-16.png","path":"article_img/2022-10-13-14-50-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-14-51-20.png","path":"article_img/2022-10-13-14-51-20.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-13-15-58-06.png","path":"article_img/2022-10-13-15-58-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-14-12-42-03.png","path":"article_img/2022-10-14-12-42-03.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-14-12-45-56.png","path":"article_img/2022-10-14-12-45-56.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-14-12-49-41.png","path":"article_img/2022-10-14-12-49-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-15-15-38-04.png","path":"article_img/2022-10-15-15-38-04.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-21-28.png","path":"article_img/2022-10-19-14-21-28.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-13-14.png","path":"article_img/2022-10-19-14-13-14.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-26-47.png","path":"article_img/2022-10-19-14-26-47.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-27-00.png","path":"article_img/2022-10-19-14-27-00.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-27-57.png","path":"article_img/2022-10-19-14-27-57.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-31-26.png","path":"article_img/2022-10-19-14-31-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-33-18.png","path":"article_img/2022-10-19-14-33-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-33-45.png","path":"article_img/2022-10-19-14-33-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-36-58.png","path":"article_img/2022-10-19-14-36-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-36-13.png","path":"article_img/2022-10-19-14-36-13.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-37-36.png","path":"article_img/2022-10-19-14-37-36.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-38-56.png","path":"article_img/2022-10-19-14-38-56.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-49-56.png","path":"article_img/2022-10-19-14-49-56.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-50-38.png","path":"article_img/2022-10-19-14-50-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-48-13.png","path":"article_img/2022-10-19-14-48-13.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-19-14-51-16.png","path":"article_img/2022-10-19-14-51-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-20-11-13-23.png","path":"article_img/2022-10-20-11-13-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-20-11-13-35.png","path":"article_img/2022-10-20-11-13-35.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-20-11-18-34.png","path":"article_img/2022-10-20-11-18-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-20-11-16-05.png","path":"article_img/2022-10-20-11-16-05.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-20-11-18-53.png","path":"article_img/2022-10-20-11-18-53.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-20-11-19-22.png","path":"article_img/2022-10-20-11-19-22.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-20-11-20-06.png","path":"article_img/2022-10-20-11-20-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-20-11-23-56.png","path":"article_img/2022-10-20-11-23-56.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-20-11-25-41.png","path":"article_img/2022-10-20-11-25-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-07-59.png","path":"article_img/2022-10-22-14-07-59.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-08-44.png","path":"article_img/2022-10-22-14-08-44.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-17-30.png","path":"article_img/2022-10-22-14-17-30.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-19-42.png","path":"article_img/2022-10-22-14-19-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-20-18.png","path":"article_img/2022-10-22-14-20-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-25-50.png","path":"article_img/2022-10-22-14-25-50.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-27-38.png","path":"article_img/2022-10-22-14-27-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-27-03.png","path":"article_img/2022-10-22-14-27-03.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-36-55.png","path":"article_img/2022-10-22-14-36-55.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-35-10.png","path":"article_img/2022-10-22-14-35-10.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-40-09.png","path":"article_img/2022-10-22-14-40-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-41-23.png","path":"article_img/2022-10-22-14-41-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-42-29.png","path":"article_img/2022-10-22-14-42-29.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-50-09.png","path":"article_img/2022-10-22-14-50-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-50-17.png","path":"article_img/2022-10-22-14-50-17.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-50-26.png","path":"article_img/2022-10-22-14-50-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-51-07.png","path":"article_img/2022-10-22-14-51-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-55-15.png","path":"article_img/2022-10-22-14-55-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-55-32.png","path":"article_img/2022-10-22-14-55-32.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-55-42.png","path":"article_img/2022-10-22-14-55-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-57-34.png","path":"article_img/2022-10-22-14-57-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-59-42.png","path":"article_img/2022-10-22-14-59-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-03-00.png","path":"article_img/2022-10-22-15-03-00.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-14-58-49.png","path":"article_img/2022-10-22-14-58-49.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-01-06.png","path":"article_img/2022-10-22-15-01-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-03-45.png","path":"article_img/2022-10-22-15-03-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-05-34.png","path":"article_img/2022-10-22-15-05-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-06-05.png","path":"article_img/2022-10-22-15-06-05.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-06-25.png","path":"article_img/2022-10-22-15-06-25.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-20-05.png","path":"article_img/2022-10-22-15-20-05.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-22-02.png","path":"article_img/2022-10-22-15-22-02.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-22-42.png","path":"article_img/2022-10-22-15-22-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-23-45.png","path":"article_img/2022-10-22-15-23-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-17-26.png","path":"article_img/2022-10-22-15-17-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-26-34.png","path":"article_img/2022-10-22-15-26-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-27-38.png","path":"article_img/2022-10-22-15-27-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-29-17.png","path":"article_img/2022-10-22-15-29-17.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-30-36.png","path":"article_img/2022-10-22-15-30-36.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-32-53.png","path":"article_img/2022-10-22-15-32-53.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-29-34.png","path":"article_img/2022-10-22-15-29-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-22-15-32-59.png","path":"article_img/2022-10-22-15-32-59.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-24-14-28-44.png","path":"article_img/2022-10-24-14-28-44.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-24-14-47-45.png","path":"article_img/2022-10-24-14-47-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-27-14-21-46.png","path":"article_img/2022-10-27-14-21-46.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-27-14-16-43.png","path":"article_img/2022-10-27-14-16-43.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-27-14-53-13.png","path":"article_img/2022-10-27-14-53-13.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-27-14-53-37.png","path":"article_img/2022-10-27-14-53-37.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-27-15-12-46.png","path":"article_img/2022-10-27-15-12-46.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-27-15-32-33.png","path":"article_img/2022-10-27-15-32-33.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-27-15-54-08.png","path":"article_img/2022-10-27-15-54-08.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-27-16-10-17.png","path":"article_img/2022-10-27-16-10-17.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-28-17-09-17.png","path":"article_img/2022-10-28-17-09-17.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-28-19-11-33.png","path":"article_img/2022-10-28-19-11-33.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-28-19-32-16.png","path":"article_img/2022-10-28-19-32-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-28-19-37-42.png","path":"article_img/2022-10-28-19-37-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-28-19-52-39.png","path":"article_img/2022-10-28-19-52-39.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-28-19-53-14.png","path":"article_img/2022-10-28-19-53-14.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-12-19-29.png","path":"article_img/2022-10-29-12-19-29.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-12-58-05.png","path":"article_img/2022-10-29-12-58-05.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-13-41-49.png","path":"article_img/2022-10-29-13-41-49.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-13-44-18.png","path":"article_img/2022-10-29-13-44-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-13-44-32.png","path":"article_img/2022-10-29-13-44-32.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-13-46-16.png","path":"article_img/2022-10-29-13-46-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-13-50-48.png","path":"article_img/2022-10-29-13-50-48.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-13-50-58.png","path":"article_img/2022-10-29-13-50-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-13-55-07.png","path":"article_img/2022-10-29-13-55-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-13-55-20.png","path":"article_img/2022-10-29-13-55-20.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-13-58-15.png","path":"article_img/2022-10-29-13-58-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-14-44-06.png","path":"article_img/2022-10-29-14-44-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-14-50-09.png","path":"article_img/2022-10-29-14-50-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-14-51-40.png","path":"article_img/2022-10-29-14-51-40.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-15-01-54.png","path":"article_img/2022-10-29-15-01-54.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-15-02-48.png","path":"article_img/2022-10-29-15-02-48.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-18-15-59.png","path":"article_img/2022-10-29-18-15-59.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-10-29-18-20-06.png","path":"article_img/2022-10-29-18-20-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-17-15-23.png","path":"article_img/2022-11-01-17-15-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-17-16-23.png","path":"article_img/2022-11-01-17-16-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-17-16-55.png","path":"article_img/2022-11-01-17-16-55.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-17-17-08.png","path":"article_img/2022-11-01-17-17-08.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-17-30-18.png","path":"article_img/2022-11-01-17-30-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-16-58-12.png","path":"article_img/2022-11-01-16-58-12.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-19-04-15.png","path":"article_img/2022-11-01-19-04-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-19-10-25.png","path":"article_img/2022-11-01-19-10-25.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-19-12-45.png","path":"article_img/2022-11-01-19-12-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-19-40-30.png","path":"article_img/2022-11-01-19-40-30.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-01-19-40-57.png","path":"article_img/2022-11-01-19-40-57.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-02-15-16-52.png","path":"article_img/2022-11-02-15-16-52.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-02-15-10-07.png","path":"article_img/2022-11-02-15-10-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-02-15-31-22.png","path":"article_img/2022-11-02-15-31-22.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-02-15-34-54.png","path":"article_img/2022-11-02-15-34-54.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-02-15-36-15.png","path":"article_img/2022-11-02-15-36-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-10-16-13-24.png","path":"article_img/2022-11-10-16-13-24.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-10-16-13-36.png","path":"article_img/2022-11-10-16-13-36.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-10-16-24-26.png","path":"article_img/2022-11-10-16-24-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-10-16-25-36.png","path":"article_img/2022-11-10-16-25-36.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-10-16-26-15.png","path":"article_img/2022-11-10-16-26-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-10-16-34-14.png","path":"article_img/2022-11-10-16-34-14.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-10-16-28-11.png","path":"article_img/2022-11-10-16-28-11.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-12-14-23-16.png","path":"article_img/2022-11-12-14-23-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-12-14-39-20.png","path":"article_img/2022-11-12-14-39-20.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-12-14-57-30.png","path":"article_img/2022-11-12-14-57-30.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-12-15-18-18.png","path":"article_img/2022-11-12-15-18-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-14-14-33-55.png","path":"article_img/2022-11-14-14-33-55.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-14-15-19-54.png","path":"article_img/2022-11-14-15-19-54.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-15-16-01-34.png","path":"article_img/2022-11-15-16-01-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-15-16-04-20.png","path":"article_img/2022-11-15-16-04-20.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-15-16-11-14.png","path":"article_img/2022-11-15-16-11-14.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-15-16-24-42.png","path":"article_img/2022-11-15-16-24-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-17-13-46-15.png","path":"article_img/2022-11-17-13-46-15.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-17-13-53-01.png","path":"article_img/2022-11-17-13-53-01.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-17-14-47-05.png","path":"article_img/2022-11-17-14-47-05.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-17-15-41-49.png","path":"article_img/2022-11-17-15-41-49.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-18-13-08-21.png","path":"article_img/2022-11-18-13-08-21.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-18-12-16-39.png","path":"article_img/2022-11-18-12-16-39.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-18-13-08-34.png","path":"article_img/2022-11-18-13-08-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-18-13-09-41.png","path":"article_img/2022-11-18-13-09-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-18-13-34-06.png","path":"article_img/2022-11-18-13-34-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-18-13-34-17.png","path":"article_img/2022-11-18-13-34-17.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-18-13-37-14.png","path":"article_img/2022-11-18-13-37-14.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-19-14-21-12.png","path":"article_img/2022-11-19-14-21-12.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-19-14-23-11.png","path":"article_img/2022-11-19-14-23-11.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-19-14-23-51.png","path":"article_img/2022-11-19-14-23-51.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-20-20-31-42.png","path":"article_img/2022-11-20-20-31-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-19-14-31-19.png","path":"article_img/2022-11-19-14-31-19.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-20-20-33-26.png","path":"article_img/2022-11-20-20-33-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-20-20-43-49.png","path":"article_img/2022-11-20-20-43-49.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-20-21-04-39.png","path":"article_img/2022-11-20-21-04-39.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-20-21-04-47.png","path":"article_img/2022-11-20-21-04-47.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-13-59-43.png","path":"article_img/2022-11-21-13-59-43.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-14-09-38.png","path":"article_img/2022-11-21-14-09-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-14-31-23.png","path":"article_img/2022-11-21-14-31-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-15-13-44.png","path":"article_img/2022-11-21-15-13-44.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-18-08-07.png","path":"article_img/2022-11-21-18-08-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-18-04-01.png","path":"article_img/2022-11-21-18-04-01.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-18-38-09.png","path":"article_img/2022-11-21-18-38-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-18-44-53.png","path":"article_img/2022-11-21-18-44-53.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-18-43-13.png","path":"article_img/2022-11-21-18-43-13.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-18-45-12.png","path":"article_img/2022-11-21-18-45-12.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-18-50-48.png","path":"article_img/2022-11-21-18-50-48.png","modified":0,"renderable":0},{"_id":"source/article_img/2022-11-21-18-56-51.png","path":"article_img/2022-11-21-18-56-51.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-17-32-38.png","path":"article_img/2023-01-29-17-32-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-17-32-40.png","path":"article_img/2023-01-29-17-32-40.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-17-48-09.png","path":"article_img/2023-01-29-17-48-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-17-47-19.png","path":"article_img/2023-01-29-17-47-19.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-17-49-24.png","path":"article_img/2023-01-29-17-49-24.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-17-48-34.png","path":"article_img/2023-01-29-17-48-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-18-13-30.png","path":"article_img/2023-01-29-18-13-30.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-17-59-12.png","path":"article_img/2023-01-29-17-59-12.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-17-57-41.png","path":"article_img/2023-01-29-17-57-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-18-15-41.png","path":"article_img/2023-01-29-18-15-41.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-18-19-47.png","path":"article_img/2023-01-29-18-19-47.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-18-24-21.png","path":"article_img/2023-01-29-18-24-21.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-19-14-03.png","path":"article_img/2023-01-29-19-14-03.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-19-17-23.png","path":"article_img/2023-01-29-19-17-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-19-24-00.png","path":"article_img/2023-01-29-19-24-00.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-19-28-42.png","path":"article_img/2023-01-29-19-28-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-19-36-25.png","path":"article_img/2023-01-29-19-36-25.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-19-37-56.png","path":"article_img/2023-01-29-19-37-56.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-19-58-58.png","path":"article_img/2023-01-29-19-58-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-20-04-48.png","path":"article_img/2023-01-29-20-04-48.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-29-20-58-10.png","path":"article_img/2023-01-29-20-58-10.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-13-26-02.png","path":"article_img/2023-01-30-13-26-02.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-13-46-43.png","path":"article_img/2023-01-30-13-46-43.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-13-57-25.png","path":"article_img/2023-01-30-13-57-25.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-15-47-25.png","path":"article_img/2023-01-30-15-47-25.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-18-59-45.png","path":"article_img/2023-01-30-18-59-45.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-19-01-11.png","path":"article_img/2023-01-30-19-01-11.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-18-59-59.png","path":"article_img/2023-01-30-18-59-59.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-20-12-26.png","path":"article_img/2023-01-30-20-12-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-20-10-34.png","path":"article_img/2023-01-30-20-10-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-20-14-01.png","path":"article_img/2023-01-30-20-14-01.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-01-30-20-18-46.png","path":"article_img/2023-01-30-20-18-46.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-14-15-48-56.png","path":"article_img/2023-03-14-15-48-56.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-17-15-21-58.png","path":"article_img/2023-03-17-15-21-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-17-15-28-09.png","path":"article_img/2023-03-17-15-28-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-17-15-39-57.png","path":"article_img/2023-03-17-15-39-57.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-17-16-13-42.png","path":"article_img/2023-03-17-16-13-42.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-18-18-55-07.png","path":"article_img/2023-03-18-18-55-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-18-18-55-20.png","path":"article_img/2023-03-18-18-55-20.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-18-18-56-04.png","path":"article_img/2023-03-18-18-56-04.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-18-18-56-36.png","path":"article_img/2023-03-18-18-56-36.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-18-19-00-23.png","path":"article_img/2023-03-18-19-00-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-18-19-01-01.png","path":"article_img/2023-03-18-19-01-01.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-18-19-05-21.png","path":"article_img/2023-03-18-19-05-21.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-18-19-08-12.png","path":"article_img/2023-03-18-19-08-12.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-18-19-24-34.png","path":"article_img/2023-03-18-19-24-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-22-12-13-16.png","path":"article_img/2023-03-22-12-13-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-22-12-23-50.png","path":"article_img/2023-03-22-12-23-50.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-22-12-25-07.png","path":"article_img/2023-03-22-12-25-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-22-12-49-01.png","path":"article_img/2023-03-22-12-49-01.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-22-12-56-23.png","path":"article_img/2023-03-22-12-56-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-22-13-00-16.png","path":"article_img/2023-03-22-13-00-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-25-14-47-55.png","path":"article_img/2023-03-25-14-47-55.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-25-15-16-38.png","path":"article_img/2023-03-25-15-16-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-25-15-11-00.png","path":"article_img/2023-03-25-15-11-00.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-25-15-20-53.png","path":"article_img/2023-03-25-15-20-53.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-25-15-24-46.png","path":"article_img/2023-03-25-15-24-46.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-25-15-26-06.png","path":"article_img/2023-03-25-15-26-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-25-15-32-24.png","path":"article_img/2023-03-25-15-32-24.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-25-15-33-19.png","path":"article_img/2023-03-25-15-33-19.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-25-15-36-39.png","path":"article_img/2023-03-25-15-36-39.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-13-34-47.png","path":"article_img/2023-03-26-13-34-47.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-13-35-34.png","path":"article_img/2023-03-26-13-35-34.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-14-42-38.png","path":"article_img/2023-03-26-14-42-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-14-43-26.png","path":"article_img/2023-03-26-14-43-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-17-25.png","path":"article_img/2023-03-26-15-17-25.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-03-35.png","path":"article_img/2023-03-26-15-03-35.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-19-55.png","path":"article_img/2023-03-26-15-19-55.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-28-33.png","path":"article_img/2023-03-26-15-28-33.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-36-18.png","path":"article_img/2023-03-26-15-36-18.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-38-16.png","path":"article_img/2023-03-26-15-38-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-38-26.png","path":"article_img/2023-03-26-15-38-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-38-35.png","path":"article_img/2023-03-26-15-38-35.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-38-40.png","path":"article_img/2023-03-26-15-38-40.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-41-54.png","path":"article_img/2023-03-26-15-41-54.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-42-58.png","path":"article_img/2023-03-26-15-42-58.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-43-07.png","path":"article_img/2023-03-26-15-43-07.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-43-27.png","path":"article_img/2023-03-26-15-43-27.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-15-48-40.png","path":"article_img/2023-03-26-15-48-40.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-16-07-46.png","path":"article_img/2023-03-26-16-07-46.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-16-08-09.png","path":"article_img/2023-03-26-16-08-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-16-10-17.png","path":"article_img/2023-03-26-16-10-17.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-16-13-26.png","path":"article_img/2023-03-26-16-13-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-16-13-32.png","path":"article_img/2023-03-26-16-13-32.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-16-15-31.png","path":"article_img/2023-03-26-16-15-31.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-16-15-40.png","path":"article_img/2023-03-26-16-15-40.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-18-08-33.png","path":"article_img/2023-03-26-18-08-33.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-18-26-36.png","path":"article_img/2023-03-26-18-26-36.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-18-32-27.png","path":"article_img/2023-03-26-18-32-27.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-18-48-25.png","path":"article_img/2023-03-26-18-48-25.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-18-50-00.png","path":"article_img/2023-03-26-18-50-00.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-18-56-23.png","path":"article_img/2023-03-26-18-56-23.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-19-14-54.png","path":"article_img/2023-03-26-19-14-54.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-19-14-59.png","path":"article_img/2023-03-26-19-14-59.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-19-17-06.png","path":"article_img/2023-03-26-19-17-06.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-19-17-26.png","path":"article_img/2023-03-26-19-17-26.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-19-18-48.png","path":"article_img/2023-03-26-19-18-48.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-26-19-22-16.png","path":"article_img/2023-03-26-19-22-16.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-29-13-26-38.png","path":"article_img/2023-03-29-13-26-38.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-29-13-40-25.png","path":"article_img/2023-03-29-13-40-25.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-29-13-43-09.png","path":"article_img/2023-03-29-13-43-09.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-03-29-14-23-17.png","path":"article_img/2023-03-29-14-23-17.png","modified":0,"renderable":0},{"_id":"source/article_img/CompDecomp.gif","path":"article_img/CompDecomp.gif","modified":0,"renderable":0},{"_id":"source/article_img/CompDecompWithExtraFeatures.gif","path":"article_img/CompDecompWithExtraFeatures.gif","modified":0,"renderable":0},{"_id":"source/article_img/LMM_L.gif","path":"article_img/LMM_L.gif","modified":0,"renderable":0},{"_id":"source/article_img/Opt_color.png","path":"article_img/Opt_color.png","modified":0,"renderable":0},{"_id":"source/article_img/LMM_M.gif","path":"article_img/LMM_M.gif","modified":0,"renderable":0},{"_id":"source/article_img/QQ图片20220803200133.jpg","path":"article_img/QQ图片20220803200133.jpg","modified":0,"renderable":0},{"_id":"source/article_img/Opt_pose.png","path":"article_img/Opt_pose.png","modified":0,"renderable":0},{"_id":"source/article_img/mm_1.gif","path":"article_img/mm_1.gif","modified":0,"renderable":0},{"_id":"source/img/bg/3DSlicerLogo.png","path":"img/bg/3DSlicerLogo.png","modified":0,"renderable":0},{"_id":"source/img/bg/Blender_cover.jpg","path":"img/bg/Blender_cover.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/EulerAngle.jpg","path":"img/bg/EulerAngle.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/LearnedMM.png","path":"img/bg/LearnedMM.png","modified":0,"renderable":0},{"_id":"source/img/bg/Logo.jpg","path":"img/bg/Logo.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/Logo.png","path":"img/bg/Logo.png","modified":0,"renderable":0},{"_id":"source/img/bg/P5R.jpg","path":"img/bg/P5R.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/Motion_Matching.png","path":"img/bg/Motion_Matching.png","modified":0,"renderable":0},{"_id":"source/img/bg/PBDR.png","path":"img/bg/PBDR.png","modified":0,"renderable":0},{"_id":"source/img/bg/PBDR_Cover.png","path":"img/bg/PBDR_Cover.png","modified":0,"renderable":0},{"_id":"source/img/bg/Pink_city.png","path":"img/bg/Pink_city.png","modified":0,"renderable":0},{"_id":"source/img/bg/West2.jpg","path":"img/bg/West2.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/RayTracing_weekend.jpg","path":"img/bg/RayTracing_weekend.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/West4.jpg","path":"img/bg/West4.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/asoul.jpg","path":"img/bg/asoul.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/bg.png","path":"img/bg/bg.png","modified":0,"renderable":0},{"_id":"source/img/bg/cg_bg.png","path":"img/bg/cg_bg.png","modified":0,"renderable":0},{"_id":"source/img/bg/games105.jpg","path":"img/bg/games105.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/nanjing.jpeg","path":"img/bg/nanjing.jpeg","modified":0,"renderable":0},{"_id":"source/img/bg/kite.webp","path":"img/bg/kite.webp","modified":0,"renderable":0},{"_id":"source/img/bg/opengl.jpg","path":"img/bg/opengl.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/profile.jpg","path":"img/bg/profile.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/unity_logo.jpg","path":"img/bg/unity_logo.jpg","modified":0,"renderable":0},{"_id":"source/img/bg/wechat.jpg","path":"img/bg/wechat.jpg","modified":0,"renderable":0},{"_id":"source/article_img/![](/article_img/2022-08-01-18-03-38.png).png","path":"article_img/![](/article_img/2022-08-01-18-03-38.png).png","modified":0,"renderable":0},{"_id":"source/article_img/![](/article_img/2022-10-12-19-20-22.png).png","path":"article_img/![](/article_img/2022-10-12-19-20-22.png).png","modified":0,"renderable":0},{"_id":"source/article_img/![](/article_img/2022-10-24-14-28-16.png).png","path":"article_img/![](/article_img/2022-10-24-14-28-16.png).png","modified":0,"renderable":0},{"_id":"source/article_img/![](/article_img/2023-03-22-12-23-50.png).png","path":"article_img/![](/article_img/2023-03-22-12-23-50.png).png","modified":0,"renderable":0},{"_id":"source/article_img/2023-04-19-12-13-27.png","path":"article_img/2023-04-19-12-13-27.png","modified":0,"renderable":0},{"_id":"source/article_img/2023-04-19-12-51-20.png","path":"article_img/2023-04-19-12-51-20.png","modified":0,"renderable":0},{"_id":"source/img/bg/cpp.jpg","path":"img/bg/cpp.jpg","modified":0,"renderable":0},{"_id":"source/article_img/2023-04-19-16-20-25.png","path":"article_img/2023-04-19-16-20-25.png","modified":1,"renderable":0},{"_id":"source/article_img/2023-04-21-13-49-02.png","path":"article_img/2023-04-21-13-49-02.png","modified":1,"renderable":0},{"_id":"source/article_img/2023-04-21-13-52-38.png","path":"article_img/2023-04-21-13-52-38.png","modified":1,"renderable":0},{"_id":"source/article_img/2023-04-21-14-03-00.png","path":"article_img/2023-04-21-14-03-00.png","modified":1,"renderable":0},{"_id":"source/article_img/2023-04-21-14-35-19.png","path":"article_img/2023-04-21-14-35-19.png","modified":1,"renderable":0},{"_id":"source/article_img/2023-04-21-14-36-18.png","path":"article_img/2023-04-21-14-36-18.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"1bf2723b956a3ad1910aaa715c453dfdd088c529","modified":1664016221800},{"_id":"source/_posts/20220425讨论.md","hash":"8ee4a4cc00c15214c05a351bccac82d4ef006ef3","modified":1664016241025},{"_id":"source/_posts/3DSlicer插件制作.md","hash":"88a72f40b8e2ed47293bb413749ffd36126ab811","modified":1664016241040},{"_id":"source/_posts/3DSlicer配置编译.md","hash":"119feee1ae2aa36e0cb6149ed4adb4b632455708","modified":1666958306906},{"_id":"source/_posts/Blender常用快捷键.md","hash":"6d9e2383ad93a2a9cb18ccf2fb73a2d2d0d94bf2","modified":1679036875624},{"_id":"source/_posts/Games101-3-光栅化.md","hash":"50ab7d71aa2901d771ad42968b53ea321e41fec5","modified":1665725170374},{"_id":"source/_posts/Games101-10-渲染中的高级话题.md","hash":"7f6b32c381b5db16cbcc7030d87d347cd335b1f6","modified":1666424184684},{"_id":"source/_posts/Games101-1-线代基础.md","hash":"00f27a8c0adf56309e6a1699a5aee24cab624fe3","modified":1665725178125},{"_id":"source/_posts/Games101-11-相机与透镜.md","hash":"038acba78e663ae4e56612eb0ac18897c107e087","modified":1667031024620},{"_id":"source/_posts/Games101-2-变换.md","hash":"6d84408102463c0a7aeda82f836c29f175a7921b","modified":1668061443497},{"_id":"source/_posts/Games101-4-着色.md","hash":"e7775174740b3ab709d518dbdb830d318e590973","modified":1665725156381},{"_id":"source/_posts/Games101-6-光线追踪(Whitted-Style).md","hash":"b1f83b3d29bc239063aab33f2d003904469ca928","modified":1665725145688},{"_id":"source/_posts/Games105-1-数学基础.md","hash":"e36691f264a191c89ea982077b96917a4ec313a3","modified":1680067632125},{"_id":"source/_posts/Games101-7-辐射度量学.md","hash":"0e715a93e2197184f5f4c5ae54dc9baf8dca5011","modified":1665725145688},{"_id":"source/_posts/Games101-9-外观和材质.md","hash":"f882b4b32623b8fd3f9023f5d649937a764f722b","modified":1666424177709},{"_id":"source/_posts/Games101-8-路径追踪.md","hash":"d6394e0462046b48e57e48b1cb09897925536da0","modified":1665725145688},{"_id":"source/_posts/Markdown用法简介.md","hash":"01f76899dd35234141a8ed4b658ba77badfee0d3","modified":1677220808989},{"_id":"source/_posts/LearnedMotionMatching复现.md","hash":"85b8b6fe75d5fe3965ef1419b778a12583de8084","modified":1679730037552},{"_id":"source/_posts/Ray tracing in one weekend.md","hash":"8f6de7240613e23147385534e656f5b78222fecd","modified":1667040198972},{"_id":"source/_posts/MotionMactching基础.md","hash":"3ac66e2d1a25a6ddf2fe2ae29a8c257bce0df529","modified":1679830249361},{"_id":"source/_posts/Unity常用快捷键.md","hash":"fea63fde645217f39549d59dc845579c79212dff","modified":1679048035810},{"_id":"source/_posts/[边学边做]DreamGuard.md","hash":"d58926caf6e81cbe6fd4ea27940d6c1f39436915","modified":1681724740873},{"_id":"source/_posts/hello-world.md","hash":"d3b692f81d82e9638f3300f1fd24721c2c0c0d8b","modified":1664016241131},{"_id":"source/_posts/learnopengl-2-着色器.md","hash":"b9c847fad801dc7e1fb75003fe280ff2fcf2887f","modified":1667292670729},{"_id":"source/_posts/learnopengl-3-纹理.md","hash":"f9b3367bb3388225fae548e0e5a0befcb67bceb1","modified":1668060772989},{"_id":"source/_posts/learnopengl-1-你好三角形.md","hash":"307de34728d643d4fba8f0741d3e688e450eacc2","modified":1673928342340},{"_id":"source/_posts/learnopengl-5-摄像机.md","hash":"dbcf594582ec427c07ef23a5877877eb79d10c6e","modified":1668240602097},{"_id":"source/_posts/learnopengl-4-变换和坐标系.md","hash":"ad9e6a53f38f404db8b6f19d7ed266ff80bf6d91","modified":1668069501945},{"_id":"source/_posts/百人计划-动画TA-动作理论基础.md","hash":"4df0149ffd4f1ea77cfb08378fab3671aab08fa4","modified":1681724732578},{"_id":"source/_posts/万向节死锁问题.md","hash":"05a8b269b4138f3495305dbdea38c4deb1114518","modified":1679048124668},{"_id":"source/_posts/非真实感渲染入门.md","hash":"5e2eb9e0b2b7507ffd080b858849171c32fe3322","modified":1677220409048},{"_id":"source/_posts/实习岗位.md","hash":"ab80ae8b6694698e1fabde05a4e2ab8340a98bc7","modified":1679047974915},{"_id":"source/article_img/2022-05-30-19-02-18.png","hash":"84b955a0f8637abee229ed02827477aa91ec40e4","modified":1664016222510},{"_id":"source/article_img/2022-05-31-15-45-30.png","hash":"e8b846da732571b8cd7f7fffbdfa30e6e6465f10","modified":1664016222840},{"_id":"source/article_img/2022-05-30-19-12-19.png","hash":"c66250fd4b1106d76d6883f49defe9ea847dfcd6","modified":1664016222698},{"_id":"source/article_img/2022-05-31-15-48-06.png","hash":"a8e5f2e27e6ccad1201cdf0f160c459929c6bbd7","modified":1664016222857},{"_id":"source/article_img/2022-05-31-15-59-31.png","hash":"eb03d920266fbc27d0b7028693acd80e469d89c5","modified":1664016223179},{"_id":"source/article_img/2022-05-31-16-23-44.png","hash":"f6609ee31ca71982814311648e6f2c00357fe98e","modified":1664016223549},{"_id":"source/article_img/2022-05-31-16-22-07.png","hash":"6aba2a9abe75625322d48568d4c595496d0f76e3","modified":1664016223522},{"_id":"source/article_img/2022-07-21-13-46-46.png","hash":"0f5deb9e74f839c4068f5509c60f2d68d4a78b97","modified":1664016225309},{"_id":"source/article_img/2022-07-21-13-53-30.png","hash":"195b8626a5742b87b4c010c336737f88f97b4fb7","modified":1664016225351},{"_id":"source/article_img/2022-07-21-13-55-49.png","hash":"e166bec98ea94234ecf1a382341aebfc47d69a85","modified":1664016225410},{"_id":"source/article_img/2022-07-21-14-00-29.png","hash":"c47eee39e94a246eb5b6e8cf08de07ecffa0d9c6","modified":1664016225460},{"_id":"source/article_img/2022-07-21-14-10-55.png","hash":"9b57085bf7330ed2cc27a202ef684b6557995116","modified":1664016225503},{"_id":"source/article_img/2022-07-21-14-15-24.png","hash":"3b090f20a6e162a9234275061f54cd88c626ce57","modified":1664016225590},{"_id":"source/article_img/2022-07-21-14-08-35.png","hash":"9fe3ecd6cf1f7f45b2f82f597b063c231c47693f","modified":1664016225476},{"_id":"source/article_img/2022-07-21-14-12-24.png","hash":"e79fc38871fa8cb2d5518590b1226c1c5a3b81e3","modified":1664016225551},{"_id":"source/article_img/2022-08-01-18-23-48.png","hash":"a89fd1c85e3726eca129fd4dc8cc7e8e4729bdad","modified":1664016226089},{"_id":"source/article_img/2022-08-01-18-34-08.png","hash":"f5f202301574b93730856c9c54ed911be5594632","modified":1664016226154},{"_id":"source/article_img/2022-08-01-18-43-06.png","hash":"885da975c5e9f4ade5c5b0a506b2030f2fdd864e","modified":1664016226247},{"_id":"source/article_img/2022-08-01-18-27-54.png","hash":"90f6f944035ade40656ffb8ba5a2d6c220d30e50","modified":1664016226109},{"_id":"source/article_img/2022-08-01-18-53-06.png","hash":"a0f847b0d1014dab2850b907cf616e908a50121a","modified":1664016226325},{"_id":"source/article_img/2022-08-01-18-50-39.png","hash":"00f60bd3ba53ad9689bc008dcae467aabbfcdd66","modified":1664016226289},{"_id":"source/article_img/2022-08-03-10-22-45.png","hash":"31978e3f979be13cac28336744a871ea3fd6ea2b","modified":1664016226700},{"_id":"source/article_img/2022-08-01-20-43-53.png","hash":"8442551e6a01a3a43f38b31f90545ec7b93a2446","modified":1664016226384},{"_id":"source/article_img/2022-08-03-10-31-16.png","hash":"29dc3e56d34a5c00e2b60eb095c09730a9649e59","modified":1664016226760},{"_id":"source/article_img/2022-08-03-20-29-06.png","hash":"c9470eb257b21ac9590215325b99cc2049a995b2","modified":1664016226963},{"_id":"source/article_img/2022-08-03-20-33-34.png","hash":"2116aacfeaf676472145cd6df43dc7154064efcd","modified":1664016226996},{"_id":"source/article_img/2022-08-03-10-39-27.png","hash":"c7aefebea3ccf982f23e86b52f17086c9a7ee186","modified":1664016226839},{"_id":"source/article_img/2022-08-03-20-32-33.png","hash":"c88c27fed1034b44776a58f495c35e224893f9ed","modified":1664016226976},{"_id":"source/article_img/2022-08-03-20-33-50.png","hash":"529756c6d081d2145dd7b5617fe72ac782eb2982","modified":1664016227060},{"_id":"source/article_img/2022-08-11-08-56-46.png","hash":"03b0741d3089e019779c6807d041d4265142bce1","modified":1664016227230},{"_id":"source/article_img/2022-08-11-11-15-21.png","hash":"fd53ce44233e39dcbe49d5257a7f2461074786d1","modified":1664016227245},{"_id":"source/article_img/2022-08-26-15-13-22.png","hash":"dc7a6a43795b67fe89956e84c815adc6ea1c05f5","modified":1664016227653},{"_id":"source/article_img/2022-08-27-09-10-47.png","hash":"728e96e7bf51410576d877d6c90c8d0058842e0a","modified":1664016228860},{"_id":"source/article_img/2022-08-27-09-17-28.png","hash":"d98336b6d64f8ce26ad73690fc3b19506b85848b","modified":1664016229109},{"_id":"source/article_img/2022-08-27-09-21-07.png","hash":"149074e64e3bd543c04a17eabfedc7c9c96cc013","modified":1664016229170},{"_id":"source/article_img/2022-08-29-15-18-27.png","hash":"dca358d7f89d618acf0ce43a533c1db854bd8148","modified":1664016230079},{"_id":"source/article_img/2022-08-29-15-14-39.png","hash":"5ebe60a44b1e30a7a4f4c36d6aebfb7dc3ef830c","modified":1664016230040},{"_id":"source/article_img/2022-08-29-15-18-42.png","hash":"7b505c1805b19d195fe8e172fd6e188ad66c432f","modified":1664016230120},{"_id":"source/article_img/2022-08-29-15-20-23.png","hash":"eeb13a8d33e0380eca5f26f20cf0e3fe0f48b436","modified":1664016230192},{"_id":"source/article_img/2022-08-29-15-23-14.png","hash":"a0b5b42bfb1eff1bdd85e3b390090f3c3ebb96ed","modified":1664016230240},{"_id":"source/article_img/2022-08-29-15-35-09.png","hash":"ec325c194190e2f021dd79862cb026b8c9d36cae","modified":1664016230265},{"_id":"source/article_img/2022-08-29-15-38-15.png","hash":"d84f74aba175e8effa90abfeaae0fe2dcead2334","modified":1664016230314},{"_id":"source/article_img/2022-08-29-15-39-32.png","hash":"a4dc1741ddc67e7435adc62ac3912b409c550cf6","modified":1664016230401},{"_id":"source/article_img/2022-08-29-15-48-55.png","hash":"4b7ac586e2ecbb1ffc9080e727bac750d655b059","modified":1664016230535},{"_id":"source/article_img/2022-08-29-15-49-44.png","hash":"5bf3cfbf6e1c5615b8bfaa88d492424282eacfe2","modified":1664016230569},{"_id":"source/article_img/2022-08-29-15-51-54.png","hash":"550b39adb015a5c3233e44238537e74e30e3c9f9","modified":1664016230682},{"_id":"source/article_img/2022-08-29-15-50-45.png","hash":"9f599a0033401e2f93fc208a1922b29200cf9c47","modified":1664016230620},{"_id":"source/article_img/2022-08-29-16-18-04.png","hash":"858a618933d8fe8ebfffb0adcb34b1d99b689a6c","modified":1664016230952},{"_id":"source/article_img/2022-08-29-16-22-31.png","hash":"2aab023d81df4417874b8fe0a9def954c6e01901","modified":1664016231010},{"_id":"source/article_img/2022-08-29-16-23-23.png","hash":"96735f2e1c39e849d71473b7dc1e2e5bb41cd1f0","modified":1664016231040},{"_id":"source/article_img/2022-08-29-16-24-37.png","hash":"1c753f9f054891afd25d6d54a1f519a0b5069a72","modified":1664016231083},{"_id":"source/article_img/2022-08-29-16-29-49.png","hash":"2525fb4e879dd33c871e3e709a58c592291dad14","modified":1664016231194},{"_id":"source/article_img/2022-08-29-18-30-33.png","hash":"557125fa72e57f74e98b60052cc41e4a1586d5f4","modified":1664016232780},{"_id":"source/article_img/2022-08-29-18-33-20.png","hash":"c2b1729a8b9e1ef297c5b78b7aa3a4196752d41f","modified":1664016232859},{"_id":"source/article_img/2022-08-29-18-35-24.png","hash":"a165ee43735c1fc503561bed8227c89d07fab32e","modified":1664016233430},{"_id":"source/article_img/2022-08-29-18-41-51.png","hash":"466d84f26f096657c667b758e918b093299442a4","modified":1664016233731},{"_id":"source/article_img/2022-08-29-18-52-05.png","hash":"4ad70f2681b2149156a290cd33f617e57a2027a2","modified":1664016233923},{"_id":"source/article_img/2022-08-29-19-00-41.png","hash":"86f67a7140de122f6d05b033811570d62af644a1","modified":1664016235040},{"_id":"source/article_img/2022-08-29-19-06-16.png","hash":"4fb25f5bdb4a70d5fe5390c0646df4701268df41","modified":1664016236810},{"_id":"source/article_img/2022-08-29-19-06-26.png","hash":"7e9def7a2e10c93601644092454871cad38ddc9b","modified":1664016236852},{"_id":"source/article_img/2022-09-26-21-01-37.png","hash":"cacbb2c870a2e43f26437304bc58b902fd1e90b0","modified":1664197297982},{"_id":"source/article_img/2022-09-26-14-28-48.png","hash":"581d38625694a66700d83e37b4516095a23f3f74","modified":1664173728608},{"_id":"source/article_img/2022-09-27-11-50-57.png","hash":"162ba438d989ed1b4089ba6a48d3f132cefd6ed1","modified":1664250658110},{"_id":"source/article_img/2022-09-27-13-10-42.png","hash":"b7462d089bd4c449b0c1ccc591605afebcdf6f2f","modified":1664255442417},{"_id":"source/article_img/2022-09-27-19-39-22.png","hash":"1c53cf3788d5a054542ebd3b1d6510aece089963","modified":1664278762457},{"_id":"source/article_img/2022-09-29-15-43-18.png","hash":"41ff96a6e48d5a67b9a3bc6620c12b5d4fa41a24","modified":1664437399192},{"_id":"source/article_img/2022-10-09-14-06-32.png","hash":"dea60e820858ff23f2bd710449257dccaaa77696","modified":1665295592337},{"_id":"source/article_img/2022-10-09-14-28-04.png","hash":"d82944e03364ebf4dec9365c208636c8720df658","modified":1665296884478},{"_id":"source/article_img/2022-10-11-17-42-58.png","hash":"950302921d5e0a1af6e2929ad3b60c15d45bde49","modified":1665481379015},{"_id":"source/article_img/2022-10-11-17-42-00.png","hash":"c94ac7f2b3fa4c65058c251cb0002cee7d55bed2","modified":1665481320291},{"_id":"source/article_img/2022-10-11-17-45-24.png","hash":"c9c0ce727191deaa227eff0f4ac4769288c3d65d","modified":1665481525101},{"_id":"source/article_img/2022-10-11-17-46-35.png","hash":"e796e316e37a6891511b01b4719f350b37b18396","modified":1665481595671},{"_id":"source/article_img/2022-10-11-17-50-28.png","hash":"81876817f0b96b4fd8519391b7a4d0b558449173","modified":1665481828524},{"_id":"source/article_img/2022-10-11-17-54-18.png","hash":"85262a75c3f8b316ea2b514608149b91163edb07","modified":1665482058337},{"_id":"source/article_img/2022-10-11-17-57-15.png","hash":"6688ee57ab3b137fa5fdee74ab5ce15cb964008f","modified":1665482235602},{"_id":"source/article_img/2022-10-11-18-08-40.png","hash":"982c21682faf10e161315717c24794af07267338","modified":1665482920485},{"_id":"source/article_img/2022-10-11-18-12-37.png","hash":"8bcbe9a38ba4d3c4165dba63b81657cc8aa327db","modified":1665483157485},{"_id":"source/article_img/2022-10-11-18-18-49.png","hash":"eb3996fbf69274553d6c07169b56a374bd2fdecf","modified":1665483529803},{"_id":"source/article_img/2022-10-11-18-19-43.png","hash":"e4ff5881073bf1b0fd46e0fc9db20a74c08f05be","modified":1665483726758},{"_id":"source/article_img/2022-10-11-18-30-32.png","hash":"6ba96f7d83035bce29dee06a1321cc8486a20bb0","modified":1665484232408},{"_id":"source/article_img/2022-10-11-18-32-03.png","hash":"f8cb0ef57eb005c448b407c79f78f7a4d4ace948","modified":1665484324172},{"_id":"source/article_img/2022-10-11-18-30-38.png","hash":"e33158182e2df3e7e15f052bdbc8a6265761ef31","modified":1665484239034},{"_id":"source/article_img/2022-10-11-18-35-53.png","hash":"f9436dcf37fec22282ef6011116d30b6498d8f6e","modified":1665484554119},{"_id":"source/article_img/2022-10-11-18-36-23.png","hash":"10ce0ce5199087df9df2e2460351b40406696a18","modified":1665484584262},{"_id":"source/article_img/2022-10-11-18-40-53.png","hash":"1ebd1052e724acdc2ccf95be9b6efb207e077389","modified":1665484853773},{"_id":"source/article_img/2022-10-11-18-40-01.png","hash":"f09fa9f341a6a862339e3fde317344b8a117b78d","modified":1665484801651},{"_id":"source/article_img/2022-10-11-18-41-58.png","hash":"0c491d859dc483be49a4385fdceec6aa951dfaa2","modified":1665484918893},{"_id":"source/article_img/2022-10-12-11-59-26.png","hash":"8a9964c27fc0a960e925ce628f0ece5ad6b955c8","modified":1665547199597},{"_id":"source/article_img/2022-10-12-12-03-15.png","hash":"6bce1dce6cef4d1ca5d8b6f6a70ef945683e55bc","modified":1665547395594},{"_id":"source/article_img/2022-10-12-12-04-58.png","hash":"100054259bde0a720a4b9cd1c8acf0858837124f","modified":1665547498584},{"_id":"source/article_img/2022-10-12-12-08-22.png","hash":"e62e597132385b019baa04636f4c31c10e45b851","modified":1665547703218},{"_id":"source/article_img/2022-10-12-12-12-57.png","hash":"5dbbafb2be1132873cda606708788c3799066b34","modified":1665547977705},{"_id":"source/article_img/2022-10-12-12-28-37.png","hash":"99b4c990f996570a2b104ab4a21ead392de96397","modified":1665548917863},{"_id":"source/article_img/2022-10-12-12-30-45.png","hash":"44f33077fde29076a3aef1d09b05c50c2dce529f","modified":1665549045398},{"_id":"source/article_img/2022-10-12-12-38-07.png","hash":"f40d73a8cc61e71e731943a3d4b3bbd1ec08791f","modified":1665549487324},{"_id":"source/article_img/2022-10-12-12-40-29.png","hash":"45b582dd5ce534e6e043bc20e3c7cfff98eadfc5","modified":1665549630264},{"_id":"source/article_img/2022-10-12-12-57-17.png","hash":"d78388f2210449415bd748a5ea303debd14e781b","modified":1665550637983},{"_id":"source/article_img/2022-10-12-13-10-52.png","hash":"f93f7e81a81bdbef5993e73b17ab69a02a78c4ea","modified":1665551452795},{"_id":"source/article_img/2022-10-12-13-12-07.png","hash":"e65957cde1ebfadf19e904305383953dad59125d","modified":1665551527479},{"_id":"source/article_img/2022-10-12-19-16-44.png","hash":"6295db0c4da4605d78ef3f93e55f828021098c8b","modified":1665573404747},{"_id":"source/article_img/2022-10-12-19-17-41.png","hash":"e31141e20495a4d6beefef7f42a5367f22b53a72","modified":1665573462075},{"_id":"source/article_img/2022-10-12-19-18-35.png","hash":"3d642cccc3307a6cdb091e5a8b1b63a55c3189c4","modified":1665573516015},{"_id":"source/article_img/2022-10-12-19-20-22.png","hash":"244e9fea450e810c2301939290818cad82445a4b","modified":1665573623019},{"_id":"source/article_img/2022-10-12-19-20-11.png","hash":"319851d6a774bb2a1bf62b1f69a34d2e08323ca1","modified":1665573611684},{"_id":"source/article_img/2022-10-12-19-20-41.png","hash":"55432063b7d4f19b3abf10415cce9d4e5e2883cc","modified":1665573641409},{"_id":"source/article_img/2022-10-13-14-37-13.png","hash":"b569d5f4b2d0aa84d4d4db6b9fe3f76befb6857c","modified":1665643034896},{"_id":"source/article_img/2022-10-13-14-37-15.png","hash":"b569d5f4b2d0aa84d4d4db6b9fe3f76befb6857c","modified":1665643036100},{"_id":"source/article_img/2022-10-13-14-40-09.png","hash":"a4f164b03a50bda1df93f68749178d2058574398","modified":1665643210271},{"_id":"source/article_img/2022-10-13-14-41-58.png","hash":"1cfa7422455160e9981f7f3c8a3ac3b6da049664","modified":1665643319387},{"_id":"source/article_img/2022-10-13-14-42-30.png","hash":"3a748861e886c60b14547b5234d5159492f1289d","modified":1665643351380},{"_id":"source/article_img/2022-10-13-14-42-38.png","hash":"fa871ee5eb431effbfe0474bc190aa5261d773fe","modified":1665643359722},{"_id":"source/article_img/2022-10-13-14-45-56.png","hash":"fc8125f07041c37f38b38c26e2539d9b78dea3f0","modified":1665643557324},{"_id":"source/article_img/2022-10-13-14-50-16.png","hash":"7d3e68d3736e81f9d5184fd46ac0ee5821f76275","modified":1665643817554},{"_id":"source/article_img/2022-10-13-15-58-06.png","hash":"1eb12f149d5fb66c15fbc8ee822be938d0ee4a7f","modified":1665647887770},{"_id":"source/article_img/2022-10-14-12-42-03.png","hash":"7044082d1c894e72dc12e682f95a4dd79e2d2b79","modified":1665722523678},{"_id":"source/article_img/2022-10-14-12-45-56.png","hash":"1874f1a2854e8de69f0684f46ce55d969cba3341","modified":1665722756680},{"_id":"source/article_img/2022-10-14-12-49-41.png","hash":"3874589d649b40fd4f96baf21e42213ddf041cbd","modified":1665722981493},{"_id":"source/article_img/2022-10-19-14-21-28.png","hash":"f3ab422f56622894b923d72e1f99a06c395e4006","modified":1666160488396},{"_id":"source/article_img/2022-10-19-14-31-26.png","hash":"f5b5cb99d20afa1d52cf6a0627a5bacedab4523d","modified":1666161086846},{"_id":"source/article_img/2022-10-19-14-33-18.png","hash":"4b3b67c687478f8eca1742cf42c1f36f925f9832","modified":1666161198540},{"_id":"source/article_img/2022-10-19-14-33-45.png","hash":"f4fff7b2fcff4bddcde4112c9c1eb97a20281f04","modified":1666161225448},{"_id":"source/article_img/2022-10-19-14-38-56.png","hash":"833798b48e405bd63bcd3771f4d408c1ef1a22b1","modified":1666161536422},{"_id":"source/article_img/2022-10-19-14-49-56.png","hash":"0865613d2bfc25932c657fa4749e32adfa9d46ab","modified":1666162196727},{"_id":"source/article_img/2022-10-19-14-50-38.png","hash":"d2b976345ff7d191e34f6b7d34abf5b2cb98a693","modified":1666162238703},{"_id":"source/article_img/2022-10-19-14-51-16.png","hash":"19ed8d90eda38462e5bbdd288a8a8a6964257527","modified":1666162276624},{"_id":"source/article_img/2022-10-20-11-18-34.png","hash":"9f010a3b8a0107799b2677c2f83f8411da4fe7de","modified":1666235915149},{"_id":"source/article_img/2022-10-20-11-18-53.png","hash":"b25eedb85083af2803cfd747f87c48ab2ff1ab75","modified":1666235933955},{"_id":"source/article_img/2022-10-20-11-20-06.png","hash":"23195bade890b3f794f29f7c1055456747826f95","modified":1666236007030},{"_id":"source/article_img/2022-10-20-11-19-22.png","hash":"2bb4f766dd061ab5db5f9f50c4a6d7c262a91710","modified":1666235963060},{"_id":"source/article_img/2022-10-20-11-23-56.png","hash":"ba99c0f43f42404d440d45d81368d815e4790c8d","modified":1666236236542},{"_id":"source/article_img/2022-10-20-11-25-41.png","hash":"6f9a2f1c5de89496f11f62cd390a69bb295e8ce4","modified":1666236341368},{"_id":"source/article_img/2022-10-22-14-07-59.png","hash":"14c798af6f4e79137c4c04e5169727e78f0d8ff7","modified":1666418879459},{"_id":"source/article_img/2022-10-22-14-17-30.png","hash":"e2fc6672c813cc7789c4e5c6cadae3d07c18d696","modified":1666419450845},{"_id":"source/article_img/2022-10-22-14-27-38.png","hash":"a9629ac0e1919f1c5ee72f74fce3fba9fb391e2d","modified":1666420058967},{"_id":"source/article_img/2022-10-22-14-27-03.png","hash":"efb309bbb1f55b55ec9792be540f4ed9389b1094","modified":1666420023785},{"_id":"source/article_img/2022-10-22-14-36-55.png","hash":"a4ae3e438bd768cea6a2e3ffcf380699be724aac","modified":1666420616157},{"_id":"source/article_img/2022-10-22-14-40-09.png","hash":"68d7f7bb7c0772e3e37a89c030882c0ef4b0cbc7","modified":1666420810129},{"_id":"source/article_img/2022-10-22-14-41-23.png","hash":"c23d30fcabbf4d962b2e86c3e41798cdf830b34e","modified":1666420883494},{"_id":"source/article_img/2022-10-22-14-50-09.png","hash":"877522f53022e55d2b7008729a3432581c36b411","modified":1666421410270},{"_id":"source/article_img/2022-10-22-14-50-17.png","hash":"94a44f400d24e3018788ad9478d0f66d39805b54","modified":1666421417886},{"_id":"source/article_img/2022-10-22-14-55-15.png","hash":"23a106f396e851dce3a638ed4dc40a62a3341e4d","modified":1666421715552},{"_id":"source/article_img/2022-10-22-14-50-26.png","hash":"356b7b15e1719551c41904c40815b0b1c3ec7bd3","modified":1666421426460},{"_id":"source/article_img/2022-10-22-14-55-32.png","hash":"a1777465eb5cd09446e2a7ac4e11e950e897044a","modified":1666421733197},{"_id":"source/article_img/2022-10-22-14-55-42.png","hash":"9231953f60864817c0a257038984febdbba5ab03","modified":1666421742707},{"_id":"source/article_img/2022-10-22-15-03-00.png","hash":"abb59708a25bf2cf400b35fc264d45470b3de05d","modified":1666422181262},{"_id":"source/article_img/2022-10-22-15-01-06.png","hash":"f26cc542e53232a871cd2b708e9cd325173ac5ac","modified":1666422067051},{"_id":"source/article_img/2022-10-22-15-20-05.png","hash":"86158ba98c4c16ea2a49e2c8cbc46d5f5771e843","modified":1666423205422},{"_id":"source/article_img/2022-10-22-15-22-02.png","hash":"1ae191e1e35cd95c64e51b5a227807ca016c3572","modified":1666423322463},{"_id":"source/article_img/2022-10-22-15-29-17.png","hash":"d911bc7972ca369c44c2b46e385a904d22577cae","modified":1666423757776},{"_id":"source/article_img/2022-10-22-15-30-36.png","hash":"eeb9850d84a6137f8e680bf6b3dfac26701a9834","modified":1666423836428},{"_id":"source/article_img/2022-10-22-15-29-34.png","hash":"7db2e9796ac1705549957f297b9679fe2a406e96","modified":1666423774575},{"_id":"source/article_img/2022-10-24-14-28-44.png","hash":"ce34b554448169a84570828a7765d292a9b8e815","modified":1666592924549},{"_id":"source/article_img/2022-10-24-14-47-45.png","hash":"d05881b947c0f828d4d1bfb643324982fb74b1ed","modified":1666594065596},{"_id":"source/article_img/2022-10-27-14-16-43.png","hash":"ae739b7fc421f0c18cdc0ce45034dff5a9729d0d","modified":1666851405082},{"_id":"source/article_img/2022-10-27-15-12-46.png","hash":"3ad58b3a01d7f0abfcfa49f4dbee21d8e75d32c2","modified":1666854767418},{"_id":"source/article_img/2022-10-27-15-32-33.png","hash":"c0aacab6597e628b14a8813087c1b597d5060f09","modified":1666855954803},{"_id":"source/article_img/2022-10-27-15-54-08.png","hash":"2f2753c9458a79af14b793b918103cc22de4ef66","modified":1666857249831},{"_id":"source/article_img/2022-10-27-16-10-17.png","hash":"2a2fa2ff53f29c712293dde96a2aae658e135c01","modified":1666858218339},{"_id":"source/article_img/2022-10-28-17-09-17.png","hash":"c6cf5de0b47123f31078cc93562d008f12188490","modified":1666948157379},{"_id":"source/article_img/2022-10-28-19-11-33.png","hash":"b7cc715e6c9d0b77898181ae1a9a3c29bd1e28b7","modified":1666955493307},{"_id":"source/article_img/2022-10-28-19-32-16.png","hash":"df9c57645acdaf979dc63c381f73d59f5ce65c5e","modified":1666956736324},{"_id":"source/article_img/2022-10-28-19-37-42.png","hash":"7e4d455d1c262f7eee815ad4dfb85bb10a178274","modified":1666957062781},{"_id":"source/article_img/2022-10-28-19-52-39.png","hash":"ec170493a06e3d50c4f6471c1af3c8fa0a4f1b9a","modified":1666957960143},{"_id":"source/article_img/2022-10-28-19-53-14.png","hash":"3d65dfaf067c4336b7ce4571d176285c2512d3ce","modified":1666957994289},{"_id":"source/article_img/2022-10-29-13-44-18.png","hash":"f0e968225f52e1cc85555b29b0968979c6fc337d","modified":1667022258394},{"_id":"source/article_img/2022-10-29-13-58-15.png","hash":"08525f9d7ab4e9f9d7d61f07393a823f08e47929","modified":1667023095281},{"_id":"source/article_img/2022-10-29-14-44-06.png","hash":"26022b78120ff0dd6a0414404fe4022e2742ff05","modified":1667025847256},{"_id":"source/article_img/2022-10-29-14-50-09.png","hash":"f47be6ab6c6fc33f00c6a7d59c7fa7e1c023e9f9","modified":1667026209348},{"_id":"source/article_img/2022-10-29-15-01-54.png","hash":"3cb5366abf35d0a89ce4e3a84f370f4710a17a02","modified":1667026914298},{"_id":"source/article_img/2022-10-29-15-02-48.png","hash":"f02046610711bec2c8c13882d14e02702f35a2cb","modified":1667026968863},{"_id":"source/article_img/2022-10-29-18-15-59.png","hash":"52c2590b804db88ac890f4fb5a5096703354aac1","modified":1667038560140},{"_id":"source/article_img/2022-11-01-17-16-23.png","hash":"15fe7ddf41c083a554ec19e25dcf285a60d4cf64","modified":1667294184163},{"_id":"source/article_img/2022-11-01-17-16-55.png","hash":"e964d03ff85011adca52fea5ab88990bc6dd6662","modified":1667294216250},{"_id":"source/article_img/2022-11-01-19-12-45.png","hash":"b47feaac433e3a3c9be9d9a48f82f984a5fe3469","modified":1667301165573},{"_id":"source/article_img/2022-11-02-15-16-52.png","hash":"e36e64f694b7b1d0d54671abdcebee07d7c67c95","modified":1667373413152},{"_id":"source/article_img/2022-11-10-16-13-24.png","hash":"385a75ba0297bb6127ffaec938f08ac5b8a0ec1d","modified":1668068005290},{"_id":"source/article_img/2022-11-10-16-13-36.png","hash":"b294c1d2956a3b9c5435676912f41779bde4536f","modified":1668068017387},{"_id":"source/article_img/2022-11-10-16-25-36.png","hash":"6f0eb595df514d5c0393ac84de1a4e113c85f875","modified":1668068737641},{"_id":"source/article_img/2022-11-10-16-26-15.png","hash":"eb188f833d18a7e5dca8bb86fd75c8270763fa3d","modified":1668068776914},{"_id":"source/article_img/2022-11-10-16-28-11.png","hash":"ebf8fe30b649bab0f588b3033e5de80b7a4f8e3a","modified":1668068892090},{"_id":"source/article_img/2022-11-12-14-23-16.png","hash":"58781421824901c9f1ba3dbcbc8424784a655726","modified":1668234197280},{"_id":"source/article_img/2022-11-12-14-39-20.png","hash":"335073dcd4c5f6ed2c2fa93d55f9754fefb6b169","modified":1668235160574},{"_id":"source/article_img/2022-11-12-14-57-30.png","hash":"41b1373c542fefd7a00b0004e363ace6fefc8fa4","modified":1668236251292},{"_id":"source/article_img/2022-11-14-14-33-55.png","hash":"b35d82e8f28d1fa301c121d71dd23f31090b5dfb","modified":1668407635379},{"_id":"source/article_img/2022-11-15-16-11-14.png","hash":"ea00717d463ef936026872b814bf7dee1961a262","modified":1668499874953},{"_id":"source/article_img/2022-11-15-16-24-42.png","hash":"f9eb6ac7811d981f9c2dcf40b88aef6ca45743ec","modified":1668500682538},{"_id":"source/article_img/2022-11-17-13-46-15.png","hash":"e4369e196e3c007807010eb9dc2de9e47a6f3180","modified":1668663975936},{"_id":"source/article_img/2022-11-17-13-53-01.png","hash":"5f4b023710d93aa7c83ed8cd76b4a886ac7bb32c","modified":1668664381336},{"_id":"source/article_img/2022-11-17-14-47-05.png","hash":"ecb7e37175af5d5d086764addc097d04550ac5ea","modified":1668667625424},{"_id":"source/article_img/2022-11-17-15-41-49.png","hash":"e0961f1cdd09ff0dd89e786247ae1399dd7d8337","modified":1668670910034},{"_id":"source/article_img/2022-11-18-13-08-21.png","hash":"9f44783c1847777a20b7c4e4924e42e9178f0690","modified":1668748101630},{"_id":"source/article_img/2022-11-18-13-08-34.png","hash":"db73a27020075242e3888a0b4917269e75b6ee4f","modified":1668748114537},{"_id":"source/article_img/2022-11-18-13-37-14.png","hash":"79d2c9a544b4d68f2a82048149731ea286d40d8c","modified":1668749835082},{"_id":"source/article_img/2022-11-19-14-21-12.png","hash":"7532435f20397952c5cbcc06b1491b24a7bc6c0f","modified":1668838873484},{"_id":"source/article_img/2022-11-19-14-23-11.png","hash":"d6cdfc01ed22a0f367dbb223d238ad331009da3d","modified":1668838991873},{"_id":"source/article_img/2022-11-20-20-31-42.png","hash":"d9c242b8f93cd5614d4cff2306cda5a4030dc468","modified":1668947503215},{"_id":"source/article_img/2022-11-19-14-31-19.png","hash":"3aa61b324ceae1f9020ca7bf00f23bc008efbea8","modified":1668839479610},{"_id":"source/article_img/2022-11-20-20-33-26.png","hash":"dc1b7c263d61244f3b5dff79a3f46ce7650563e8","modified":1668947606916},{"_id":"source/article_img/2022-11-20-20-43-49.png","hash":"6ac67a04a65538c7dbce8cdd4e8bc51f931d9346","modified":1668948229842},{"_id":"source/article_img/2022-11-20-21-04-39.png","hash":"76886e17de3661cee30d88cfcc97543d96101533","modified":1668949480146},{"_id":"source/article_img/2022-11-20-21-04-47.png","hash":"363194772d6acc7379062e276ee2f1d24b9a8826","modified":1668949488058},{"_id":"source/article_img/2022-11-21-13-59-43.png","hash":"5f6f5b0d527a2db15101010b0a88a95a46ed36c6","modified":1669010384042},{"_id":"source/article_img/2022-11-21-18-08-07.png","hash":"de07c2a02f109a1e273232aa150eb6738be3e091","modified":1669025287387},{"_id":"source/article_img/2022-11-21-18-04-01.png","hash":"d9815ab76a9540024850f272481a08224a4aed2d","modified":1669025042132},{"_id":"source/article_img/2022-11-21-18-38-09.png","hash":"8fdf80a0ac7515ce4ce43edef25cf48126ac93c4","modified":1669027089965},{"_id":"source/article_img/2022-11-21-18-44-53.png","hash":"786476dcdc2262f0efb4bd7907487c656693b965","modified":1669027494096},{"_id":"source/article_img/2022-11-21-18-45-12.png","hash":"07921677770d9d49b02985d7b94fe3acdfd5997c","modified":1669027512388},{"_id":"source/article_img/2023-01-29-17-59-12.png","hash":"a0b5b42bfb1eff1bdd85e3b390090f3c3ebb96ed","modified":1676777529639},{"_id":"source/article_img/2023-01-29-18-13-30.png","hash":"f91f5da5940f76e3f43aac60fba8c079e01dbef0","modified":1676777529718},{"_id":"source/article_img/2023-01-29-18-15-41.png","hash":"30e2ec8e5623c437e8db4224b24a88593c7a8669","modified":1676777529749},{"_id":"source/article_img/2023-01-29-19-28-42.png","hash":"d84f74aba175e8effa90abfeaae0fe2dcead2334","modified":1676777532952},{"_id":"source/article_img/2023-01-29-19-37-56.png","hash":"fa473e2786693d21dcdf5a46794fc6a3530be2dc","modified":1676777533135},{"_id":"source/article_img/2023-01-29-19-58-58.png","hash":"e3ab6694b287b8ee91b612acb716b4cfa3b23890","modified":1676777533169},{"_id":"source/article_img/2023-01-30-13-26-02.png","hash":"655ad56262e553b1de860a899eecf6eefc1e4f63","modified":1676777533768},{"_id":"source/article_img/2023-01-30-18-59-45.png","hash":"ced4bd899065603807fea30b17fac57be880ca6d","modified":1676777535717},{"_id":"source/article_img/2023-01-30-19-01-11.png","hash":"bcae25d9a27ad4406237476a9ec8679c5c552232","modified":1676777535843},{"_id":"source/article_img/2023-01-30-18-59-59.png","hash":"b33cebedffb3916a9aafac6084ab028172cccbd9","modified":1676777535776},{"_id":"source/article_img/2023-01-30-20-12-26.png","hash":"4f4554252bd72c2531ca3ba92f7e11c274daf7a9","modified":1676777535944},{"_id":"source/article_img/2023-01-30-20-10-34.png","hash":"b4bd329c423a3be854732fe2101f34cd82f59c5e","modified":1676777535915},{"_id":"source/article_img/2023-01-30-20-14-01.png","hash":"5a5b52c19f341f911bc0533244ddd2ce5155e5af","modified":1676777535969},{"_id":"source/article_img/2023-01-30-20-18-46.png","hash":"5c72402786763d3d831ffe29ebb4788bfc294cdd","modified":1676777535996},{"_id":"source/article_img/2023-03-18-18-55-20.png","hash":"4583b8482e1c5cf4470fb84d323eb97387e750fc","modified":1679136920597},{"_id":"source/article_img/2023-03-18-18-56-04.png","hash":"c0c82f87e39a5093f38a0b0e09b5f1bd0246b989","modified":1679136965246},{"_id":"source/article_img/2023-03-18-19-01-01.png","hash":"729449fdd549d4a1874af1ac94a8b9bdebd4f2ff","modified":1679137262233},{"_id":"source/article_img/2023-03-18-19-24-34.png","hash":"e5029e3d8b0852044a9ef98bbca6e197e495b26c","modified":1679138674725},{"_id":"source/article_img/2023-03-22-12-23-50.png","hash":"6f411ee52c13b528f640f5a9437b13bef6ed65ac","modified":1679459030839},{"_id":"source/article_img/2023-03-22-12-25-07.png","hash":"883e09284c1d50e3c0c6fca1b24a42e3cca54933","modified":1679459108042},{"_id":"source/article_img/2023-03-22-12-56-23.png","hash":"578f8069d993ba67906e4ba8dd1f6ce1bc2a035a","modified":1679460983475},{"_id":"source/article_img/2023-03-22-12-49-01.png","hash":"181f6d7e1dea6bcc603da44163f6d90c9ab61d22","modified":1679460541966},{"_id":"source/article_img/2023-03-22-13-00-16.png","hash":"91dda246e14ad2caddd53f5b3ba3b6a0b2f6c992","modified":1679461216488},{"_id":"source/article_img/2023-03-25-15-11-00.png","hash":"f0ed874ec73475c52cdcaed7008b8de4a115787b","modified":1679728260355},{"_id":"source/article_img/2023-03-25-15-16-38.png","hash":"a1d2baec40c715045f030e22f1e6c54addacebf6","modified":1679728599027},{"_id":"source/article_img/2023-03-25-15-20-53.png","hash":"989fcfdf3b0fda1da5f2a29adddefab6f9772331","modified":1679728853346},{"_id":"source/article_img/2023-03-25-15-26-06.png","hash":"8ebe41c3c162fed81cb03efe21f38855c1bb29dd","modified":1679729166507},{"_id":"source/article_img/2023-03-25-15-32-24.png","hash":"d4efe67cdfa2154547510f0cdbbb817afa2102e6","modified":1679729544355},{"_id":"source/article_img/2023-03-25-15-36-39.png","hash":"77e36324e0ab336dab107346cc4c7b93fbab679e","modified":1679729800116},{"_id":"source/article_img/2023-03-25-15-33-19.png","hash":"fed50b13d69a9d273f694a0e5d964bae31927889","modified":1679729599397},{"_id":"source/article_img/2023-03-26-13-34-47.png","hash":"8ed8f6ecf72f2c7f17e7136d885bd94a0047f38c","modified":1679808887744},{"_id":"source/article_img/2023-03-26-13-35-34.png","hash":"5cf8c850b20be881c34f161a544397cc431b81da","modified":1679808934311},{"_id":"source/article_img/2023-03-26-15-03-35.png","hash":"0f3b69a6408e8cb6b4a73a3f28c399a4e48af416","modified":1679814215388},{"_id":"source/article_img/2023-03-26-18-08-33.png","hash":"f3d7209be9c785f4cbde618988cff380f18a9681","modified":1679825314149},{"_id":"source/article_img/2023-03-26-18-26-36.png","hash":"d4f096c32f5457fc46b270ce4d5e0700e5c8a0c5","modified":1679826396678},{"_id":"source/article_img/2023-03-26-18-48-25.png","hash":"0c81e8827b5d39b16b04928b0d178a7e34cee40a","modified":1679827705876},{"_id":"source/article_img/2023-03-26-18-56-23.png","hash":"ecc6d2814c5b6689e704b6b0e625b2c5fe0167fc","modified":1679828183314},{"_id":"source/article_img/2023-03-26-19-14-54.png","hash":"7b3d96b88fe7feee2be18b8a3028ef3b227c5f67","modified":1679829295151},{"_id":"source/article_img/2023-03-26-19-14-59.png","hash":"035442270e5ca9d4fd134e8f3894940265532dbf","modified":1679829299866},{"_id":"source/article_img/2023-03-26-19-17-06.png","hash":"1552935e56d6fa2e5c5b32acbf1b1ef0978bdfb3","modified":1679829426940},{"_id":"source/article_img/2023-03-26-19-17-26.png","hash":"b887a13e35e6c4d5d7a4811a3549caea7ca86593","modified":1679829446858},{"_id":"source/article_img/2023-03-29-13-40-25.png","hash":"0fe32aeb0e069c594c494fc38c052b0e13d65a66","modified":1680068426055},{"_id":"source/img/bg/Blender_cover.jpg","hash":"796e5d5a58b7c6b7cd0b3dd42434d683a4f8a481","modified":1677220396680},{"_id":"source/img/bg/EulerAngle.jpg","hash":"3ae3b34018cdd22ca036d9784b61245b42b45b8f","modified":1679047852604},{"_id":"source/img/bg/Logo.jpg","hash":"0c2f49c6175e04fafdaadb64d8df192979803890","modified":1677909571620},{"_id":"source/img/bg/Logo.png","hash":"df0ab2f66e3644b4d6951baaeff5824686c80fbc","modified":1677909645809},{"_id":"source/img/bg/opengl.jpg","hash":"9d1f1133409327051af41fa0291d5f769c2604c3","modified":1666592672550},{"_id":"source/img/bg/profile.jpg","hash":"74ef610c7cc2a0ae383c608b9e59923208581b4c","modified":1664016240935},{"_id":"source/img/bg/unity_logo.jpg","hash":"43447ecf42da5172258c6362350bcc7ba335c97c","modified":1677221032063},{"_id":"source/img/bg/wechat.jpg","hash":"4182333419b7fde017c6c34dc08767d3d868cce1","modified":1664016241000},{"_id":"source/article_img/![](/article_img/2022-10-12-19-20-22.png).png","hash":"55432063b7d4f19b3abf10415cce9d4e5e2883cc","modified":1665573637649},{"_id":"source/article_img/![](/article_img/2023-03-22-12-23-50.png).png","hash":"883e09284c1d50e3c0c6fca1b24a42e3cca54933","modified":1679459103500},{"_id":"source/article_img/![](/article_img/2022-10-24-14-28-16.png).png","hash":"ef8f56bc99dddbda87cc5ef428553302b7b30b85","modified":1666592908435},{"_id":"source/article_img/2022-05-30-19-01-47.png","hash":"ca2d8c2e6c6b54183c97c3f4bd360e95d1a54c74","modified":1664016222410},{"_id":"source/article_img/2022-05-30-19-03-35.png","hash":"c2e866178cf983d0cfe1aa038425472f7acee240","modified":1664016222613},{"_id":"source/article_img/2022-05-31-14-18-58.png","hash":"b9a7139c5bdaf6e5db16b7a8413b1e3ab23630d7","modified":1664016222772},{"_id":"source/article_img/2022-05-31-16-12-25.png","hash":"ec74d41977cf0abf5056caded9aa9b88af62966f","modified":1664016223263},{"_id":"source/article_img/2022-05-31-15-48-55.png","hash":"4d46759e0cd502639178910c9e95c54e314ea5ff","modified":1664016222989},{"_id":"source/article_img/2022-05-31-16-12-50.png","hash":"bd2b8343d8e913d4db216cc10056448eb57b4529","modified":1664016223363},{"_id":"source/article_img/2022-06-20-14-08-41.png","hash":"05002bb28f4ab5ee54f1189ffe22ddf65910b496","modified":1664016223829},{"_id":"source/article_img/2022-06-06-18-35-54.png","hash":"6be1df14e318133e1f7ed4a0a3c84e450a325e43","modified":1664016223652},{"_id":"source/article_img/2022-06-20-14-41-24.png","hash":"7eaa2f3d1b0684816e1acc6475460ce5758bc2a1","modified":1664016223940},{"_id":"source/article_img/2022-08-01-18-08-53.png","hash":"31279d78550f5e21ceb0e570e45891ffe7af5813","modified":1664016225851},{"_id":"source/article_img/2022-08-01-18-15-35.png","hash":"959c7a4f960cfe8a8a87d5bfb9c9c932b62a9b27","modified":1664016226029},{"_id":"source/article_img/2022-08-01-18-03-38.png","hash":"050155e074d15b444c7b8a9776c6dc241afd0319","modified":1664016225685},{"_id":"source/article_img/2022-08-03-17-35-43.png","hash":"cef751918702699d6d9409a6c2343f5c797a2445","modified":1664016226940},{"_id":"source/article_img/2022-08-10-16-12-45.png","hash":"750ffcd40592edc266a2a21eb7c1df5f049edce3","modified":1664016227179},{"_id":"source/article_img/2022-08-26-15-12-11.png","hash":"1d51afba2ce825e15dacc7766a2cd9b81a6dcf98","modified":1664016227593},{"_id":"source/article_img/2022-08-26-15-16-08.png","hash":"607891053a8057c948fe8f423af1741b7c72af72","modified":1664016227789},{"_id":"source/article_img/2022-08-27-09-10-34.png","hash":"7dbdeabde67d50f5be466e18fca466d25a051376","modified":1664016228790},{"_id":"source/article_img/2022-08-27-09-14-04.png","hash":"3251eda86b675721cf92a679ac1c6b96ef20b216","modified":1664016228933},{"_id":"source/article_img/2022-08-27-09-15-15.png","hash":"e9343bef545e889fba609e1608be329e0caff760","modified":1664016229020},{"_id":"source/article_img/2022-08-29-15-42-40.png","hash":"d3266a537705a5c009307e9942d3fb3698927358","modified":1664016230473},{"_id":"source/article_img/2022-08-29-16-17-54.png","hash":"2746f1fa918980a06cd359a91101671d9e0bea3e","modified":1664016230783},{"_id":"source/article_img/2022-08-29-16-24-47.png","hash":"b165b5fe2290faad8ae8bf4b7f0c88084d3a76d2","modified":1664016231163},{"_id":"source/article_img/2022-08-29-18-44-02.png","hash":"611e6d0aacac0e2136e0ba7031592c9ecf7120e0","modified":1664016233830},{"_id":"source/article_img/2022-09-27-11-50-26.png","hash":"b52d456aa359accf5bd2894e07bb9e923384a906","modified":1664250626342},{"_id":"source/article_img/2022-09-28-16-15-11.png","hash":"5669b36a5224debf2a1947362153b7797911643f","modified":1664352912077},{"_id":"source/article_img/2022-09-29-15-45-06.png","hash":"9e4e41ea63cab044dc495cf95010a7a0ff995128","modified":1664437506617},{"_id":"source/article_img/2022-09-29-15-45-33.png","hash":"e72d675daff15c3dcd71b82034b6f92d2171e4be","modified":1664437534173},{"_id":"source/article_img/2022-09-29-15-52-40.png","hash":"396bbefad1974c6b136a564a713525a4483a35aa","modified":1664437960882},{"_id":"source/article_img/2022-09-30-14-48-32.png","hash":"680dfc7afb1390028ba9dd283b1f5c26e54e3404","modified":1664520512986},{"_id":"source/article_img/2022-10-08-14-55-02.png","hash":"c42df55757047401594f46f58fb3f02fcdbb0dec","modified":1665212102522},{"_id":"source/article_img/2022-10-09-14-52-21.png","hash":"532415bdce5970d5a862edd9f1db8ae459b965c4","modified":1665298341981},{"_id":"source/article_img/2022-10-11-18-10-27.png","hash":"73eeeabc10aa597437ca2572c30d9e4fce1b9d71","modified":1665483027776},{"_id":"source/article_img/2022-10-12-12-34-50.png","hash":"c97f81f8633de9a20be12a1977ca55e8e6d5b864","modified":1665549291115},{"_id":"source/article_img/2022-10-12-12-46-03.png","hash":"3fb738d2a064dd910c0914853d87fd472194cf4a","modified":1665549963546},{"_id":"source/article_img/2022-10-12-12-51-23.png","hash":"70da84a9c83747d6117c6a6e414e97eed115529e","modified":1665550325018},{"_id":"source/article_img/2022-10-12-13-03-11.png","hash":"0792eb4591aa01adf92a83fb5bf8e86e709ad759","modified":1665551313625},{"_id":"source/article_img/2022-10-13-14-51-20.png","hash":"f87435455792d652881421db4eced41581d8af9b","modified":1665643881614},{"_id":"source/article_img/2022-10-15-15-38-04.png","hash":"f3850d72b541092ee5591bb9fbc0058fb624c274","modified":1665819485120},{"_id":"source/article_img/2022-10-19-14-36-58.png","hash":"80c9fd8bf7c35fabe981854aa7ce09ee6daad8eb","modified":1666161418834},{"_id":"source/article_img/2022-10-19-14-36-13.png","hash":"a19547e41fec0bb3565e3129c3653abd5ac80735","modified":1666161373929},{"_id":"source/article_img/2022-10-19-14-37-36.png","hash":"3c0d8066675325859322f17fb95bc14ac2f85159","modified":1666161456694},{"_id":"source/article_img/2022-10-22-14-25-50.png","hash":"92eebc26516af1929aa045162f4247e5e44956be","modified":1666419950519},{"_id":"source/article_img/2022-10-22-14-42-29.png","hash":"a4726012621f46f40f3820af18fae7f255e4a441","modified":1666420949894},{"_id":"source/article_img/2022-10-22-14-59-42.png","hash":"af8b7a7f05dc89e531399afb22423450974e6f1d","modified":1666421982959},{"_id":"source/article_img/2022-10-22-14-58-49.png","hash":"f43b0d22628f375478605dac5f482e0a12b997a6","modified":1666421930054},{"_id":"source/article_img/2022-10-22-15-17-26.png","hash":"7a1d4fa5091def58c5c4aa8a9933e88ac1548d53","modified":1666423046905},{"_id":"source/article_img/2022-10-22-15-32-53.png","hash":"6640695e678feeccaf6daec81744d399143fa389","modified":1666423973419},{"_id":"source/article_img/2022-10-22-15-32-59.png","hash":"0b0d1240c6c002947aa6a9a907e70af8cc2ea42b","modified":1666423980106},{"_id":"source/article_img/2022-10-27-14-21-46.png","hash":"c73f02f6f2f973145816dfdd949616d2096d2bc5","modified":1666851707719},{"_id":"source/article_img/2022-10-29-12-19-29.png","hash":"cf2b664bcdeb16e395d64efdf0f4f2f7285128c2","modified":1667017169534},{"_id":"source/article_img/2022-11-01-17-15-23.png","hash":"d7c854d5a7a92f8b595af80d9231ae054c53cbad","modified":1667294124164},{"_id":"source/article_img/2022-11-01-17-30-18.png","hash":"e4a0760dc342621e7901f1a416300857fbf14ef4","modified":1667295018525},{"_id":"source/article_img/2022-11-01-19-04-15.png","hash":"1362961b315907f0a04935c109969a08494c8f0c","modified":1667300655516},{"_id":"source/article_img/2022-11-01-16-58-12.png","hash":"56109401dbd7081b6f20c1fd41bd3c5dde07a182","modified":1667293093435},{"_id":"source/article_img/2022-11-01-19-10-25.png","hash":"06e3c69c66a5cd6c4940b0d6c667ed1ac2d4410d","modified":1667301025706},{"_id":"source/article_img/2022-11-10-16-24-26.png","hash":"73f60bca62a9abaf280dc9a95288ad9005991744","modified":1668068667015},{"_id":"source/article_img/2022-11-21-14-09-38.png","hash":"4be4f3c44f3f6f9b24e97b3adea7ba6754e5249e","modified":1669011024526},{"_id":"source/article_img/2022-11-21-14-31-23.png","hash":"5c3b1eb11af2bdc729d60099162e4483bcaae323","modified":1669012283754},{"_id":"source/article_img/2023-01-29-19-14-03.png","hash":"d3266a537705a5c009307e9942d3fb3698927358","modified":1676777530360},{"_id":"source/article_img/2023-01-29-19-36-25.png","hash":"3a13dc3c1e0da45b1b8ac66ee950b9b77424ea3a","modified":1676777533053},{"_id":"source/article_img/2023-01-29-20-04-48.png","hash":"231ac4958f3840da4a8198b868563b57e68817b0","modified":1676777533287},{"_id":"source/article_img/2023-01-30-13-46-43.png","hash":"4c5a9c652ac4d5085c7b382797231fdb6fecd009","modified":1676777533881},{"_id":"source/article_img/2023-03-18-18-55-07.png","hash":"a903910d7683d3169bc82d5a798790b5b9bb7e71","modified":1679136907554},{"_id":"source/article_img/2023-03-18-18-56-36.png","hash":"00082c13c382f1fa00f74e7752f77d35ae09e6b2","modified":1679136996857},{"_id":"source/article_img/2023-03-18-19-00-23.png","hash":"c8f4db87f5677297f56cd2c2f47ef9265d8a924a","modified":1679137224141},{"_id":"source/article_img/2023-03-18-19-05-21.png","hash":"f46de393393d03ee5741869f2215fcfe8abc89a8","modified":1679137522081},{"_id":"source/article_img/2023-03-22-12-13-16.png","hash":"150e9b8082668fdaed3c1cf25ec30e69d0e4d1df","modified":1679458396483},{"_id":"source/article_img/2023-03-25-14-47-55.png","hash":"af8384fc3346ce177a87887ce54ba74f8886a05f","modified":1679726876271},{"_id":"source/article_img/2023-03-25-15-24-46.png","hash":"5d6a98400341540888f7d14d8adcb6988604db84","modified":1679729086332},{"_id":"source/article_img/2023-03-26-14-42-38.png","hash":"9721e974d81aaf7a36d03e7a585a6a9bd38edd3a","modified":1679812958362},{"_id":"source/article_img/2023-03-26-15-17-25.png","hash":"1924f3fc8f250f5007071255786b76168976ef71","modified":1679815045662},{"_id":"source/article_img/2023-03-26-15-38-26.png","hash":"9aabeae9c563feaf2077f0249c62fd280d08cb17","modified":1679816306516},{"_id":"source/article_img/2023-03-26-15-38-35.png","hash":"db8b9ccd5db4109840e12854b13220c7021dcb75","modified":1679816315432},{"_id":"source/article_img/2023-03-26-15-38-40.png","hash":"0e0c29c8bef3304b54fc9e990ffda44bfdf88545","modified":1679816321078},{"_id":"source/article_img/2023-03-26-16-10-17.png","hash":"8acc9ada6403f8a121ef7b3b1c22459cd3ea9318","modified":1679818217836},{"_id":"source/article_img/2023-03-26-16-15-40.png","hash":"208f683578f8552c5fd7a3520c195f5ddc7092bc","modified":1679818540593},{"_id":"source/article_img/2023-03-26-18-50-00.png","hash":"d492e3ebe8f8c1dc3f25d05e9cccc6b3d349a226","modified":1679827801130},{"_id":"source/article_img/2023-03-26-19-18-48.png","hash":"ed939f88f4ff0a473cce0aae6b7966e558700d36","modified":1679829528856},{"_id":"source/article_img/2023-03-26-19-22-16.png","hash":"fbf0166f58559dd645b68d27ca2b75557d27fc5b","modified":1679829736709},{"_id":"source/img/bg/LearnedMM.png","hash":"af8384fc3346ce177a87887ce54ba74f8886a05f","modified":1679726876271},{"_id":"source/img/bg/P5R.jpg","hash":"1fbd4481f16dd964aa4d01bebbbb8464e1fe0901","modified":1668075360451},{"_id":"source/img/bg/PBDR.png","hash":"2485b0b4cd688f88afeb0b75421f591028db1cd5","modified":1668944082325},{"_id":"source/img/bg/West4.jpg","hash":"5c2f03d61e3a4810325cd8bce66bf28883827643","modified":1666860827872},{"_id":"source/img/bg/bg.png","hash":"a39d439a556f47f159ceba84b787483ff5a3acd6","modified":1664016239701},{"_id":"source/img/bg/kite.webp","hash":"62a2ba05b4e1587d2d28d90a025357b3c1c8d0fa","modified":1664016240551},{"_id":"source/article_img/![](/article_img/2022-08-01-18-03-38.png).png","hash":"31279d78550f5e21ceb0e570e45891ffe7af5813","modified":1664016221981},{"_id":"source/article_img/2022-05-30-18-51-12.png","hash":"6dd9180e8b0d94c5bdc47cef6507fdd363dd2929","modified":1664016222309},{"_id":"source/article_img/2022-08-03-10-12-36.png","hash":"1390648b57ee3191a722d6f071dcbbad7e11b138","modified":1664016226563},{"_id":"source/article_img/2022-08-26-15-10-45.png","hash":"cc517c1d612fa14cb6a0e2fdef88da8a60533d9c","modified":1664016227373},{"_id":"source/article_img/2022-08-29-18-33-36.png","hash":"18eac1b77d92b9e0a436f5df8259687e6387bc58","modified":1664016233040},{"_id":"source/article_img/2022-08-29-18-35-15.png","hash":"8823027f417f83897385827bced2be78f4e9f0ce","modified":1664016233290},{"_id":"source/article_img/2022-08-29-18-41-41.png","hash":"8e85c51872fbc7eb8470a1e7c404e8a89b046a72","modified":1664016233589},{"_id":"source/article_img/2022-08-29-18-54-29.png","hash":"860478dbd9a6d8849842f2ac2c9e52f4ef24da9f","modified":1664016234484},{"_id":"source/article_img/2022-08-29-18-54-37.png","hash":"23cc10537308a6265d1868709ec88cdeef9542ad","modified":1664016234700},{"_id":"source/article_img/2022-10-08-14-54-52.png","hash":"8d4719a0b3f809d85c0f38541bae31ec236dc790","modified":1665212092852},{"_id":"source/article_img/2022-10-09-14-25-53.png","hash":"aa5b41daf062326a094109ec6c1a0239da3e0bc6","modified":1665296753407},{"_id":"source/article_img/2022-10-09-14-51-30.png","hash":"3076d7ed0edbf09917f119fb0f6d766eb3339bcb","modified":1665298291169},{"_id":"source/article_img/2022-10-09-14-51-38.png","hash":"dc72ab3a282903eea97ce49022b05192bf53fd6e","modified":1665298298372},{"_id":"source/article_img/2022-10-09-15-26-37.png","hash":"c89b53f06b600c3ae6d2384b5b61bf0b0051431f","modified":1665300398040},{"_id":"source/article_img/2022-10-20-11-13-35.png","hash":"154f004ecb6289077f57450b65bb4b4ca040f137","modified":1666235615355},{"_id":"source/article_img/2022-10-22-14-19-42.png","hash":"57e8c77e9412597d4d1ef2430bb6c34a0d6d2fb7","modified":1666419582923},{"_id":"source/article_img/2022-10-22-14-20-18.png","hash":"c8700f82cb042f5153f08a795ff18729cf3fe3e9","modified":1666419618400},{"_id":"source/article_img/2022-10-22-14-35-10.png","hash":"2ce8a97c47a75aa90bc26e375e5cdc43e7d04e39","modified":1666420511014},{"_id":"source/article_img/2022-10-22-15-05-34.png","hash":"db03507be981f8cb4ab63a9d5f5d506802668b09","modified":1666422334779},{"_id":"source/article_img/2022-10-22-15-06-05.png","hash":"8b1d0015ae1f2d517c1c4812139dc5cc8ab59417","modified":1666422365707},{"_id":"source/article_img/2022-10-22-15-22-42.png","hash":"43e69e8dd6270c9dace39c8d0860af9869bfae89","modified":1666423363107},{"_id":"source/article_img/2022-10-22-15-23-45.png","hash":"f51a720b810017b7c7bfa279953b49968eb20674","modified":1666423425845},{"_id":"source/article_img/2022-10-22-15-27-38.png","hash":"9de6d452c35eb0ffb555853fce6483b94add06df","modified":1666423658737},{"_id":"source/article_img/2022-10-29-12-58-05.png","hash":"7ecc01dd5dccad39aa5b0a853acfbfea179c0465","modified":1667019485566},{"_id":"source/article_img/2022-10-29-13-41-49.png","hash":"9619c1c0349f37166082afb309167f50926bc98e","modified":1667022110162},{"_id":"source/article_img/2022-11-01-17-17-08.png","hash":"436bab29920629180d77d8a4e2202ded25fb0bb8","modified":1667294228613},{"_id":"source/article_img/2022-11-01-19-40-30.png","hash":"87e001c0f440171bb472c4f793ea4d08ea789aa6","modified":1667302830591},{"_id":"source/article_img/2022-11-02-15-34-54.png","hash":"9478f14941394c37163aa4175e0aabfd5b75948d","modified":1667374747799},{"_id":"source/article_img/2022-11-18-12-16-39.png","hash":"25c2a3d4345dbb5d536c40ab432ee89f14291087","modified":1668744999623},{"_id":"source/article_img/2022-11-18-13-34-06.png","hash":"5cab00a06edc7bcdfe5097b207d88528eddcfb35","modified":1668749646439},{"_id":"source/article_img/2022-11-18-13-34-17.png","hash":"5cab00a06edc7bcdfe5097b207d88528eddcfb35","modified":1668749657802},{"_id":"source/article_img/2022-11-19-14-23-51.png","hash":"b28b3619fc6f605879cc594aa8582bacdcca7f8b","modified":1668839032102},{"_id":"source/article_img/2022-11-21-15-13-44.png","hash":"96b65fee1be1d1a929ef4ef3f6cafabd1a9c12cf","modified":1669014824652},{"_id":"source/article_img/2023-01-29-18-19-47.png","hash":"027b85191df7d76cc0b33a1fe713dcf63155b1e8","modified":1676777529814},{"_id":"source/article_img/2023-01-29-19-24-00.png","hash":"2336498d53fe3504cab672f580912efcf309b0dc","modified":1676777532879},{"_id":"source/article_img/2023-03-18-19-08-12.png","hash":"426e590064d48037afed57df00e984e5dfd618a0","modified":1679137692478},{"_id":"source/article_img/2023-03-26-14-43-26.png","hash":"257aa96e3983626e2ffd8e6121f38f274d69a032","modified":1679813006648},{"_id":"source/article_img/2023-03-26-15-19-55.png","hash":"8886dd9119879c42f834a08b818a536f9c3388b9","modified":1679815195603},{"_id":"source/article_img/2023-03-26-15-28-33.png","hash":"22da9ece6c0255f4b9506ee4eb98f8fcf53852f0","modified":1679815713548},{"_id":"source/article_img/2023-03-26-15-36-18.png","hash":"97fa1bbd64718054a7206333b49dcba4c7711e53","modified":1679816178394},{"_id":"source/article_img/2023-03-26-15-43-07.png","hash":"199381321daf2b1bed3389a893dfa06bebaa1af3","modified":1679816587952},{"_id":"source/article_img/2023-03-26-15-43-27.png","hash":"a952327bb7a9414beb58cd92d384ee2e268318d9","modified":1679816607431},{"_id":"source/article_img/2023-03-26-16-07-46.png","hash":"baf49b21c329bf5c64792acea1fa3d3daaca2050","modified":1679818066983},{"_id":"source/article_img/2023-03-26-16-13-26.png","hash":"4165f55d70262177f7cb17451d8a032b4ec563ea","modified":1679818406599},{"_id":"source/article_img/2023-03-26-16-15-31.png","hash":"6b5e356f31742c7b953c9b56ba58beab256a8324","modified":1679818531970},{"_id":"source/img/bg/3DSlicerLogo.png","hash":"e3c9443753142fb1c89977c8ef152438d125172b","modified":1664016238230},{"_id":"source/img/bg/games105.jpg","hash":"ec2d053b480473aeeeac2cf161182d153a1eb955","modified":1679136856861},{"_id":"source/article_img/2022-08-27-09-21-26.png","hash":"1f3483ec957b8d68058293c9f9c1762a23f9c6b8","modified":1664016229400},{"_id":"source/article_img/2022-08-29-18-53-37.png","hash":"e57e1850a17bdd378560796e22f17ac781119ab4","modified":1664016234159},{"_id":"source/article_img/2022-08-29-18-56-35.png","hash":"841f1f903c7832621eaa19839b851fcff394aa7d","modified":1664016234960},{"_id":"source/article_img/2022-08-29-19-04-50.png","hash":"f4429372706e83980b2e5e5297215ec87087c47d","modified":1664016236698},{"_id":"source/article_img/2022-09-26-21-08-46.png","hash":"13898ce64db5eace1f6cb933416352503cb839fc","modified":1664197727109},{"_id":"source/article_img/2022-10-19-14-26-47.png","hash":"6d394b2beea10805d3815cbfc8c1d44df13d0c09","modified":1666160808225},{"_id":"source/article_img/2022-10-19-14-27-00.png","hash":"972bacc43bc7179a55db725ce59413a9fb7af563","modified":1666160820593},{"_id":"source/article_img/2022-10-19-14-27-57.png","hash":"7589b8da377118f80446486bb57198996c127884","modified":1666160877403},{"_id":"source/article_img/2022-10-22-14-08-44.png","hash":"a00bb8eb2e0205dbe8f289bc08924e06a8496e9e","modified":1666418924688},{"_id":"source/article_img/2022-10-22-14-51-07.png","hash":"e1bd39459d51e349c78b5aff8b34894b08a4dbb3","modified":1666421468241},{"_id":"source/article_img/2022-10-22-14-57-34.png","hash":"976b7c68647b015ee3680924046ba5a358cd2c98","modified":1666421854847},{"_id":"source/article_img/2022-10-22-15-03-45.png","hash":"1d1b8f8381a4e700f4b498a36462f0d81676abb7","modified":1666422226102},{"_id":"source/article_img/2022-10-22-15-26-34.png","hash":"130e8bd2afd761d711718706b44ac14e4bdd9d83","modified":1666423595207},{"_id":"source/article_img/2022-10-29-13-46-16.png","hash":"1960f3d8b78ada9d5a160a37d9ba19f81d89a490","modified":1667022376958},{"_id":"source/article_img/2022-10-29-13-50-48.png","hash":"eb498eb79a5cf48f709f4943816a97ed9de7fcda","modified":1667022648641},{"_id":"source/article_img/2022-10-29-13-50-58.png","hash":"3c46be248f611175e181361b2052450683d76f69","modified":1667022659237},{"_id":"source/article_img/2022-10-29-13-55-20.png","hash":"291e7cd4c7e6b895bfc5002de2d4f18eaa677e57","modified":1667022921204},{"_id":"source/article_img/2022-11-01-19-40-57.png","hash":"446e2eb550febd0d688ecc44fcc96ce63a5e3f08","modified":1667302858081},{"_id":"source/article_img/2022-11-02-15-31-22.png","hash":"da46723565706dd123ac7d9724a3d1586dd2aa6e","modified":1667374719134},{"_id":"source/article_img/2022-11-18-13-09-41.png","hash":"d8006e451b1a75b8ac692890c036d34bb43f2a21","modified":1668748182180},{"_id":"source/article_img/2022-11-21-18-50-48.png","hash":"d502774da8bd471aedb936b5b88d04d5186bf620","modified":1669027848574},{"_id":"source/article_img/2022-11-21-18-56-51.png","hash":"891c839c7566616186421006130c295d755b5f2f","modified":1669028211357},{"_id":"source/article_img/2023-01-29-17-57-41.png","hash":"d04c2763a5bb43e70692891b809d162000caaba8","modified":1676777529609},{"_id":"source/article_img/2023-01-30-15-47-25.png","hash":"6c62bb3117ad9ea3a31e02530ef0408c56ced04c","modified":1676777535689},{"_id":"source/article_img/2023-03-17-15-28-09.png","hash":"e424acef74bc0fd1a23fe7b692ec0cc419a6c7c6","modified":1679038090216},{"_id":"source/article_img/2023-03-17-15-39-57.png","hash":"2f0bdc04268a2b975c916c241b7c8a681377cbc0","modified":1679038798159},{"_id":"source/article_img/2023-03-17-16-13-42.png","hash":"f88c83c88962dbbefdb9fb9d9e5054e4ce26e81b","modified":1679040822408},{"_id":"source/article_img/2023-03-26-15-42-58.png","hash":"e62c35b755abacd2fb5bb16c04c9e35641e88939","modified":1679816578714},{"_id":"source/article_img/2023-03-26-16-13-32.png","hash":"57c8d4677b7be646696edca76a9310a527f3636e","modified":1679818412685},{"_id":"source/article_img/Opt_color.png","hash":"8d1d6ce6ab3dd0fba97dfa3621c10c2ea4a02e0b","modified":1668940671643},{"_id":"source/img/bg/nanjing.jpeg","hash":"bbe4d2dc4d9fad68a0ea7bacec1d07427ac2543f","modified":1664016240781},{"_id":"source/article_img/2022-08-27-09-09-18.png","hash":"c242cea22d7970c81097fbe17920d00c398da22f","modified":1664016228160},{"_id":"source/article_img/2022-08-27-09-21-42.png","hash":"041dcca2876358c735fb8b216a7bae633b752824","modified":1664016229980},{"_id":"source/article_img/2022-09-26-14-26-50.png","hash":"d64646f9ddfa34cc25285e4fdbd4514bfee4e8a8","modified":1664173611389},{"_id":"source/article_img/2022-09-29-15-45-22.png","hash":"d381775c6b2de476b083a85a8a2260e069b15d85","modified":1664437522856},{"_id":"source/article_img/2022-10-19-14-48-13.png","hash":"8c8a0e29d8f8f8eb8cea1e5169d349d1ea3162ed","modified":1666162093822},{"_id":"source/article_img/2022-10-20-11-13-23.png","hash":"3cdcd8918086cbd993d506e1bca77f6a9d21e626","modified":1666235604092},{"_id":"source/article_img/2022-10-20-11-16-05.png","hash":"441ef891c39b75274c67e081498363e039bf692f","modified":1666235765619},{"_id":"source/article_img/2022-10-22-15-06-25.png","hash":"ce465513a45a258ae7183bda4756954eb2eedeb0","modified":1666422386198},{"_id":"source/article_img/2022-10-29-13-44-32.png","hash":"7f6fee8368afa14dc0d764d25cbc89e6256c010f","modified":1667022272502},{"_id":"source/article_img/2022-10-29-13-55-07.png","hash":"790f8571202201a3c9b3ddeed485eca82025c82c","modified":1667022907649},{"_id":"source/article_img/2022-10-29-14-51-40.png","hash":"58dbb27d734b9aac0bbf35d52de418b119d78b9e","modified":1667026300320},{"_id":"source/article_img/2022-11-02-15-36-15.png","hash":"82b98c8cd108c4689740697dc0dc3932aa0bcf35","modified":1667374776416},{"_id":"source/article_img/2022-11-14-15-19-54.png","hash":"90b07a1957270224d736014d4756a53951c799fc","modified":1668410395067},{"_id":"source/article_img/2022-11-21-18-43-13.png","hash":"a941456976979b4fe2c6cb47d042bbfe27168c58","modified":1669027393800},{"_id":"source/article_img/2023-03-17-15-21-58.png","hash":"0ce8891a09f721f1a2e239b830b19c555890f91d","modified":1679037718933},{"_id":"source/article_img/2023-03-26-15-38-16.png","hash":"d361dea0206fb2da4cbef81b0e0b52903f66ac02","modified":1679816297209},{"_id":"source/article_img/2023-03-26-15-48-40.png","hash":"0c3c2e7e3c566fa6e0d36348095dee61aba3a50e","modified":1679816920914},{"_id":"source/article_img/Opt_pose.png","hash":"807c6122492ca123c34b4e5810f1e42499f2fa6e","modified":1668940509273},{"_id":"source/img/bg/West2.jpg","hash":"cb02a7cc32956aad55ea4085e642a1791ee1ef60","modified":1666860769016},{"_id":"source/img/bg/RayTracing_weekend.jpg","hash":"db554a58efaf190332b815c2001fc725d5b0aa29","modified":1665300648127},{"_id":"source/article_img/2022-08-29-16-32-11.png","hash":"bd7d8ecbb8fbbafee35f638f784835e5dd53f355","modified":1664016231641},{"_id":"source/article_img/2022-10-19-14-13-14.png","hash":"fcbbef45971cc4607e2aff6a8b73484b4a6567f9","modified":1666159995009},{"_id":"source/article_img/QQ图片20220803200133.jpg","hash":"b1fc9181f0fa07b6bd0a1eb22cbf72bcb186a58b","modified":1664016237210},{"_id":"source/article_img/2022-06-20-18-11-02.png","hash":"4a33b51b7f2449e3207fd76f61e33c53ed3bbc3a","modified":1664016225260},{"_id":"source/article_img/2022-08-29-16-32-22.png","hash":"835af9b9ff7ae4686a7e956ab241036744852ce6","modified":1664016232721},{"_id":"source/article_img/2023-01-29-20-58-10.png","hash":"7f82778142b3c0ec5452537eff6efe57f8f17ce2","modified":1676777533712},{"_id":"source/article_img/2023-03-26-15-41-54.png","hash":"33cfd0c1cd0ec8b90be5af8bbeff74f39753b8ee","modified":1679816515031},{"_id":"source/article_img/2022-06-20-18-05-00.png","hash":"4d688a0d63c116c78024d1f202fe76068787bafb","modified":1664016224748},{"_id":"source/article_img/2022-08-29-19-00-52.png","hash":"8b8076195c9793d3bd7ab36fa28b06450c37d090","modified":1664016236320},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1664016253208},{"_id":"source/article_img/2023-01-29-18-24-21.png","hash":"1e9b8d40aa28d7c325f386b84a6cc23825a39dad","modified":1676777530323},{"_id":"source/article_img/2023-03-26-16-08-09.png","hash":"e206537d742a623138e0b2d5354d4219fce2918b","modified":1679818090159},{"_id":"source/article_img/2023-03-26-18-32-27.png","hash":"9cf282f9644dc8c9452a387f371e97eeeaf619dd","modified":1679826747471},{"_id":"source/article_img/2023-03-29-14-23-17.png","hash":"ae604f6d4f526a36a8609acc39270687c6a13afc","modified":1680070997956},{"_id":"source/img/bg/cg_bg.png","hash":"313e52b451a968a2fd8b3aba460727c8e0e44a4f","modified":1664016240460},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1664016249172},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1664016249206},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1664016249191},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1664016249521},{"_id":"themes/fluid/README_en.md","hash":"8c874f309e346fffa392e174385b5cc08510f218","modified":1664016251424},{"_id":"themes/fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1664016251405},{"_id":"themes/fluid/_config.yml","hash":"d5ed15fd87806915a5d1ca822d2218862f788a95","modified":1664016254900},{"_id":"themes/fluid/package.json","hash":"980a730164d9f145a3271ed64d7122b7cee6d590","modified":1664016251386},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1664016251370},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1664016249592},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1664016249606},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1664016249621},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1664016249688},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1664016249637},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1664016249716},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1664016249730},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1664016249745},{"_id":"themes/fluid/layout/404.ejs","hash":"9569c5c8f67d2783f372f671c57b93a00dc63c2f","modified":1664016249770},{"_id":"themes/fluid/layout/about.ejs","hash":"23e5db06cfdc1cb26503204f074db58647adfbf3","modified":1664016249803},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1664016249824},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1664016249875},{"_id":"themes/fluid/layout/index.ejs","hash":"952d3f27cd7a245848fa1c4a1f5c8912500c2ee1","modified":1664016249936},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1664016249893},{"_id":"themes/fluid/layout/layout.ejs","hash":"1452acee33611685b199c50e1bd4ecddbf6424e3","modified":1664016249964},{"_id":"themes/fluid/layout/links.ejs","hash":"edcbef65037759c3a7b3539f2edcd72b082267e9","modified":1664016249974},{"_id":"themes/fluid/layout/page.ejs","hash":"a4a6b184bd91d9fe090da28891e74afc3b71c7fd","modified":1664016250017},{"_id":"themes/fluid/layout/post.ejs","hash":"3a812de943457c0c544832daa1957420883aca96","modified":1664016250084},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1664016249470},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1664016250095},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"16d33eb89ecf90f4046720fde5395d972c7ba1fd","modified":1664016249233},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1664016250118},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1664016249264},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"af977ed0792508bb0766ea8afe82d34ef1e8fb3c","modified":1664016249249},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1664016249283},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1664016249373},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"e24b470f7aa8044499a4f5e39634e5dc43899011","modified":1664016249443},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1664016251456},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1664016251628},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1664016251664},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1664016251691},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1664016251707},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1664016251643},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1664016251732},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1664016251757},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1664016251780},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1664016251799},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"43620b0944ffb67ea1fa6cc838f65a7351222eb0","modified":1664016251839},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1664016251814},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1664016251873},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1664016251903},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1664016251962},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"b917b893b1777e6ffcb53188f9f5644510e5f20d","modified":1664016251920},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1664016251987},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1664016252035},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1664016252010},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1664016252051},{"_id":"themes/fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1664016252073},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1664016252095},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1664016252119},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1664016252135},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1664016250157},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1664016250192},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1664016252159},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"a591fedbc5759fb00152304f9ea486dfba3a246a","modified":1664016250270},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"24ef242aa01e5f5bc397cf3f83ae48b1e8353dab","modified":1664016250571},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1664016250600},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1664016250669},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"eb2c46aa2508ea65d6e5c397c4bc20d05761d754","modified":1664016250698},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1664016250877},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"536eedc03faae3b35dc69abd478634d453061a0a","modified":1664016250860},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"3d8912b68fcf51c38f6e1c5dd2bd74657bb3b7fb","modified":1664016251318},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1664016251333},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1664016252202},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1664016252221},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1664016252239},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1664016252272},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1664016253286},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1664016254849},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1664016254586},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1664016254626},{"_id":"themes/fluid/source/js/color-schema.js","hash":"781e5c82556f279f99c97ffd13f359bd1a445145","modified":1664016254677},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1664016254603},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1664016254719},{"_id":"themes/fluid/source/js/boot.js","hash":"6b7319b36ca2e2d3afe336623ef438994f3d26de","modified":1664016254652},{"_id":"themes/fluid/source/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1664016254697},{"_id":"themes/fluid/source/js/leancloud.js","hash":"ed23208de670d7a5900f2669cc715e2479885958","modified":1664016254753},{"_id":"themes/fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1664016254774},{"_id":"themes/fluid/source/js/plugins.js","hash":"b4ca98f68bf09a74678932e4ac73ac56a7c01e03","modified":1664016254797},{"_id":"themes/fluid/source/js/utils.js","hash":"d49d462f8547de07ca49e1ea195dff864b08706b","modified":1664016254824},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"54933c294d9b469a76a5ed36328e778ed740158f","modified":1664016251503},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1664016251482},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1664016251525},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1664016251557},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"cb78296da15c7a8a6957cff2129294cc4815513b","modified":1664016251545},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1664016251580},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1664016250294},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1664016251603},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1664016250315},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1664016250336},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1664016250389},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1664016250363},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1664016250413},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1664016250434},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1664016250457},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1664016250553},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1664016250503},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1664016250620},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1664016250647},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"38990ed9dbccd88342ee4b4cb5e60818e9eb8e8a","modified":1664016250824},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"ef56f0903762a7a2c853417dfa6b0463440295e0","modified":1664016250929},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"57358e2164284f33f3bc81d5f602c620aeab942f","modified":1664016250735},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"953552425f0b86c98d1026fdb04e716fdff356e7","modified":1664016250951},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"129a8b19ab26efd02ff1806ff4012376d2cd3497","modified":1664016250971},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1664016250984},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1664016251010},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"3b3b0be9f7624ff72fbb2da6ae3663adcfb7d118","modified":1664016251051},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1664016251075},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"88420e83c0968f7da69aa423f42d3033891c9229","modified":1664016251125},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"c80bdc171aa53eb7205dcdc77764cec87a1dafd6","modified":1664016251031},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1664016251098},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"359cbcb0e222c23c8a0c5a99034a8a51f667a9ce","modified":1664016251155},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1664016251177},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1664016251235},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1664016251226},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1664016251256},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"91a1de823492d9225f9daa3ef59efbca345456a0","modified":1664016251274},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1664016252301},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1664016252331},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1664016252357},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"2465f604eea63b14cd2b0cc142769d963a0193a0","modified":1664016253260},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1664016252408},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1664016252384},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"99e8e25e84d513b869a17140f63a5c1e48a0e7e1","modified":1664016252902},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1664016252920},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1664016252947},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1664016252444},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"5f4a17a20ddbf18c8ea6c66638b764905e4386b3","modified":1664016252975},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1664016252466},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1664016252481},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1664016252514},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1664016253022},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1664016253054},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"e24cd1186aae10bf897eed9cfd5278247b6300eb","modified":1664016253078},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"e6e48d6ba2951ce4abc2876600f85eef64095338","modified":1664016253127},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"078e5496a1852952ce4ee49016e86b9f70d31908","modified":1664016253158},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1664016253191},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1664016253234},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1664016252612},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1664016252572},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1664016252546},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1664016252592},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1664016252636},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1664016252652},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"896179810e1ee986208ae2d57a44719f6b839bde","modified":1664016252703},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1664016252680},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1664016252725},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1664016252767},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1664016252739},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"696e429284bda7ae0fffe62ca84cb01a9243ecf0","modified":1664016252797},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1664016252812},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1664016252877},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1664016252852},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1664016252830},{"_id":"source/article_img/2022-11-10-16-34-14.png","hash":"f9855ab59a93eae2fc13ddca1b2bae1b693365b0","modified":1668069255985},{"_id":"source/article_img/2023-03-29-13-43-09.png","hash":"36fe062d9e29efe0c6a59f857665c78cfb359702","modified":1680068589791},{"_id":"source/article_img/2022-10-29-18-20-06.png","hash":"ff7b4e059f8e03e36270a33f3833a8170bb40bac","modified":1667038806997},{"_id":"source/article_img/2022-11-15-16-01-34.png","hash":"ad1b03c09066824ed1c084479ebbd063246aaa45","modified":1668499295400},{"_id":"source/article_img/2023-01-29-17-32-40.png","hash":"2f85f45b3db23658c0c3cd11d87b7196af35c0b2","modified":1676777523715},{"_id":"source/article_img/2023-01-29-17-32-38.png","hash":"2f85f45b3db23658c0c3cd11d87b7196af35c0b2","modified":1676777522954},{"_id":"source/article_img/2023-01-30-13-57-25.png","hash":"711d21f1e6ed93a73202a859e64df8cf957eacb2","modified":1676777535193},{"_id":"source/article_img/2023-01-29-17-47-19.png","hash":"5082028205cd9b4babbd02db555f4b6ae8fbd4c1","modified":1676777524836},{"_id":"source/img/bg/PBDR_Cover.png","hash":"b2b75b4600da606038bb6ee431f67962ed714b8e","modified":1668408863701},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1664016253872},{"_id":"source/article_img/2022-11-15-16-04-20.png","hash":"7c339adc1a5bd48b81dd93c01a58a5890d5237f5","modified":1668499460700},{"_id":"source/article_img/2023-01-29-17-48-34.png","hash":"e02afed0273453fd6625896036184c8fb7d140ec","modified":1676777527604},{"_id":"source/img/bg/Motion_Matching.png","hash":"f3fe812c1c9ea33e6182c06317cf9f6467e3da80","modified":1679464851652},{"_id":"source/article_img/2022-11-12-15-18-18.png","hash":"de6b5baf97b2ef9d6411b688ec8a51ed3790966f","modified":1668237499345},{"_id":"source/article_img/2023-01-29-17-48-09.png","hash":"bf184fca3bb2c71da519eb969a34b69cd33906bf","modified":1676777526269},{"_id":"source/article_img/2023-01-29-17-49-24.png","hash":"ade3a654f94121b279a5dfb1b2472c285251dcc5","modified":1676777529140},{"_id":"source/article_img/2023-01-29-19-17-23.png","hash":"dcb098ec77cd2a3fdee836f3a9c324d79da59548","modified":1676777532467},{"_id":"source/img/bg/asoul.jpg","hash":"3187fcfb754e535dc08d38874c497c6d5a4b0cb6","modified":1664016239570},{"_id":"source/article_img/2023-03-14-15-48-56.png","hash":"aba1ae48a03239a1483e2ca9a7929fe226735f82","modified":1678780136621},{"_id":"source/article_img/2023-03-29-13-26-38.png","hash":"3539d5d876e1c245ec48f9db7f526c7cd2294fbd","modified":1680067599296},{"_id":"source/article_img/2022-10-27-14-53-37.png","hash":"5e48814c5018b291b1aae15adec2f717bcd840ce","modified":1666853618525},{"_id":"source/article_img/2022-11-02-15-10-07.png","hash":"a868cc4947141b3004b91d2794f689bd1e012631","modified":1667373007534},{"_id":"source/article_img/2022-10-27-14-53-13.png","hash":"a41d1dbf3ebb98fcb8dd8c85edd7552f5e5e279f","modified":1666853595059},{"_id":"source/img/bg/Pink_city.png","hash":"5ea089d73c4f3fbe1c2af7e481a0c84606595572","modified":1668146331716},{"_id":"source/article_img/CompDecompWithExtraFeatures.gif","hash":"a2d6f84e43f5b29b720244bb9b7b47ccbc94f607","modified":1679827549940},{"_id":"source/article_img/LMM_L.gif","hash":"e6f2abac787d2a3a269fbca63b246aab098a61d7","modified":1679743107285},{"_id":"source/article_img/LMM_M.gif","hash":"2fe4d99bc6e3f09a659f3375a5a804083b8bb2ca","modified":1679742964263},{"_id":"source/article_img/CompDecomp.gif","hash":"360a8e12bbeec1655d9d61df1eafa91b1cdbf648","modified":1679827118383},{"_id":"source/article_img/mm_1.gif","hash":"daf82d952ee3bc7d11eb74619c9d0ac7de278589","modified":1679741529169},{"_id":"public/local-search.xml","hash":"c74c26208c9d14056f421d1b337769e1043ce33e","modified":1682063572703},{"_id":"public/about/index.html","hash":"100ec226120b5a39f73d7d8a69481dbda36c96de","modified":1681718060189},{"_id":"public/2023/03/26/MotionMactching基础/index.html","hash":"94bdd483b68f11c9086b29c783b8c402074ae0e6","modified":1681718060189},{"_id":"public/2023/03/29/百人计划-动画TA-动作理论基础/index.html","hash":"5fbf02c50d55a5cb13c6e2e12b438c8544de261c","modified":1681885305978},{"_id":"public/2023/03/25/LearnedMotionMatching复现/index.html","hash":"d5b9af6225b947bcbb0d78b8f00e19ad92aa3407","modified":1681718060189},{"_id":"public/2023/03/22/[边学边做]DreamGuard/index.html","hash":"75e4d08e9bf9d6cf8852c248d4cabf991c795d47","modified":1681724761067},{"_id":"public/2023/03/18/Games105-1-数学基础/index.html","hash":"320e6ed3da523fb4824e36c9a2c2ccab2bf2ae8d","modified":1681718060189},{"_id":"public/2023/03/17/万向节死锁问题/index.html","hash":"0267ec2444b1e092b7c57ca8be62dbc592a292f6","modified":1681718060189},{"_id":"public/2023/03/05/Unity常用快捷键/index.html","hash":"042f3fcceeef9db69c41f0453abdfa21e68bcdab","modified":1681718060189},{"_id":"public/archives/index.html","hash":"4e68b115816aea1c2197e68920c79fc9753fd0cf","modified":1681885305978},{"_id":"public/archives/page/2/index.html","hash":"2a4146b692402f09c0b17ad7497f030ded041e1c","modified":1681885269957},{"_id":"public/archives/page/3/index.html","hash":"be76484c5cfb34f4f86c5c72c218bcb793ea6aeb","modified":1681885269957},{"_id":"public/archives/2022/index.html","hash":"7ed6a157392d547074ca0586306a2deaa79bb12f","modified":1681885269957},{"_id":"public/archives/2022/page/2/index.html","hash":"6a459fd71a7f3361d37de415fd459084a3a9f69f","modified":1681885269957},{"_id":"public/archives/2022/04/index.html","hash":"575fd0abdf70ee819d87b6c07f1db76e6aba3d7d","modified":1681885269957},{"_id":"public/archives/2022/06/index.html","hash":"ea0a7dbbefd5d22c56d26fd5a2db1a6eadc1ce35","modified":1681885269957},{"_id":"public/archives/2022/07/index.html","hash":"a1b9c2d7c30d18af6fa088eaf3429e86847077ac","modified":1681885269957},{"_id":"public/archives/2022/08/index.html","hash":"409f2740c17d0fff56abb886ff63eb716eec3af8","modified":1681885269957},{"_id":"public/archives/2022/10/index.html","hash":"77827817c8c2a7d4138ed2acbc33ed6fe87462a3","modified":1681885269957},{"_id":"public/archives/2022/11/index.html","hash":"647ec3f7fc8d12f9d98404f9ffc3152515b4f5fd","modified":1681885269957},{"_id":"public/archives/2023/index.html","hash":"3c2070fc795ef31423c4138ce4aaca0570a5f451","modified":1681885305978},{"_id":"public/archives/2023/01/index.html","hash":"af8238b09b7598880b33386d2418d48eff3fe0bc","modified":1681885269957},{"_id":"public/archives/2023/02/index.html","hash":"acca8dac22218cdb44ed5f92562ef1fd32d19032","modified":1681885269957},{"_id":"public/archives/2023/03/index.html","hash":"53564ccbd4d9f0a6f2529262e35f65df291699df","modified":1681885269957},{"_id":"public/categories/3DSlicer/index.html","hash":"ad3a4163ee7d06cbfed7f1254c731295e8e1a1f9","modified":1681718060189},{"_id":"public/categories/笔记/index.html","hash":"d91f331c98dc200593394c25fa973ca4ab9a1024","modified":1681718060189},{"_id":"public/categories/Games101笔记/index.html","hash":"7db94d3a70580dbd167d6777ae9509e0b53b40fd","modified":1681718060189},{"_id":"public/categories/Games105笔记/index.html","hash":"d1f79d34d92e8a9d0b45a0da3418c0bba66a7a10","modified":1681718060189},{"_id":"public/categories/练习/index.html","hash":"8f0f400d0bd3d9ecfe30ce4e8a65325229138e60","modified":1681718060189},{"_id":"public/categories/Ray-Tracing-笔记/index.html","hash":"6c544efd3cfbe842c9eb1df1c139a5234766a7e0","modified":1681718060189},{"_id":"public/categories/游戏Demo/index.html","hash":"05fb2614005b2ac667442c425ef57a22e922b61d","modified":1681718060189},{"_id":"public/categories/OpenGL笔记/index.html","hash":"22ea60df79ae71e849f6599654242e7848109f9b","modified":1681718060189},{"_id":"public/categories/动画TA/index.html","hash":"e7b8817d5a2f702e103b662584d4aaa379d51361","modified":1681718060189},{"_id":"public/tags/3DSlicer/index.html","hash":"9aff8363716fe45e5cdd78d3ce7f02495fa617d9","modified":1681718060189},{"_id":"public/tags/Blender/index.html","hash":"1b1bb12650eb70a1dde7d2f92d0d7b8a3c2a8645","modified":1681718060189},{"_id":"public/tags/Games101/index.html","hash":"6b01f3f7ebad96bf3313e059ba2e31b6d3e00f77","modified":1681718060189},{"_id":"public/tags/Games105/index.html","hash":"7ebe191e855cac5b941c7bfe068687e36b5481d6","modified":1681718060189},{"_id":"public/tags/计算机角色动画/index.html","hash":"c480c8c6d072bc33b4dc91a494ba258689f48355","modified":1681718060189},{"_id":"public/tags/Hexo/index.html","hash":"cb24a58fbb3c8f177a710ed62fd992e9b8aef0a2","modified":1681718060189},{"_id":"public/tags/Fluid/index.html","hash":"70add7ba211556b5b88ea626d643951150b4249a","modified":1681718060189},{"_id":"public/tags/Ray-Tracing/index.html","hash":"4c09efeb55783c72a380372d5731255906e2a866","modified":1681718060189},{"_id":"public/tags/Unity/index.html","hash":"c2066daae8b78e0edf248c7254ef506dc9596860","modified":1681718060189},{"_id":"public/tags/【边学边做】/index.html","hash":"3e4174ccb9b3c13220dd44caffb0fa9d3ccce84b","modified":1681718060189},{"_id":"public/tags/OpenGL/index.html","hash":"c63bd8708218b218f44ae1a0ba38cf259930bca9","modified":1681718060189},{"_id":"public/404.html","hash":"ec64b44fe3fb08fd80c76d0ada344803f72c0453","modified":1681718060189},{"_id":"public/tags/百人计划/index.html","hash":"6d75bcff390025b9f1d4b6628f46d5f63a4be8e1","modified":1681718060189},{"_id":"public/tags/NPR/index.html","hash":"1bea4057237b45c00be59397426312548964593a","modified":1681718060189},{"_id":"public/tags/index.html","hash":"8f979e69b8df25c804b7c619f8085e4882684113","modified":1681885269957},{"_id":"public/links/index.html","hash":"b22c20c1b8d7e834591a64d86eb3e66a7c533758","modified":1681718060189},{"_id":"public/2023/02/24/实习岗位/index.html","hash":"33c9b90e5a0933bfa40aafcb5211539291488308","modified":1681718060189},{"_id":"public/2023/02/24/Blender常用快捷键/index.html","hash":"d7fb0b3c05008853376f91ff0da9d1b0533d9823","modified":1681718060189},{"_id":"public/2023/01/29/非真实感渲染入门/index.html","hash":"34424011c07b2200a3be30507e65b536e3863a80","modified":1681718060189},{"_id":"public/2022/11/12/learnopengl-5-摄像机/index.html","hash":"a7088e1338a68f735d44ad2022457a40b249b5f1","modified":1681718060189},{"_id":"public/2022/11/02/learnopengl-4-变换和坐标系/index.html","hash":"4cd060dee08ac987c2c5e0c8bb073603a9c90bce","modified":1681718060189},{"_id":"public/2022/11/01/learnopengl-3-纹理/index.html","hash":"c1baf49d40457e7843496c0f28610870daf9eb50","modified":1681718060189},{"_id":"public/2022/10/29/Games101-11-相机与透镜/index.html","hash":"a73e152e9467608b5a9a5c518e454bc70dcf99ec","modified":1681718060189},{"_id":"public/2022/10/28/learnopengl-2-着色器/index.html","hash":"cbf10dc09dbea799d03e19e6ef5ea878e8f1d740","modified":1681718060189},{"_id":"public/2022/10/27/learnopengl-1-你好三角形/index.html","hash":"1cad5f9de6f60b74a90e1949af8aac62c98a5b50","modified":1681718060189},{"_id":"public/2022/10/22/Games101-10-渲染中的高级话题/index.html","hash":"ce6d38373296c158a85e03feaf19ded847d3843b","modified":1681718060189},{"_id":"public/2022/10/18/Games101-9-外观和材质/index.html","hash":"a757d5e1a96a595b10abc4c23e5608ea95988bd8","modified":1681718060189},{"_id":"public/2022/10/13/Games101-8-路径追踪/index.html","hash":"6c91a4f9a2ede222563c2d362108ef2c882b51b1","modified":1681718060189},{"_id":"public/2022/10/12/Games101-7-辐射度量学/index.html","hash":"6e403ad4785966d68b84c603d393993718f6981b","modified":1681718060189},{"_id":"public/2022/10/11/Games101-6-光线追踪(Whitted-Style)/index.html","hash":"3ebc3d5e502076a2d60283ec43a14541e1148c39","modified":1681718060189},{"_id":"public/2022/10/09/Ray tracing in one weekend/index.html","hash":"d7b1956e32b0bbd72a96e2e3028f907f833e057c","modified":1681718060189},{"_id":"public/2022/09/24/hello-world/index.html","hash":"d18e04025ac3644aa5fe4e3875b320cef556db34","modified":1681718060189},{"_id":"public/2022/08/25/Games101-4-着色/index.html","hash":"8c866abb0f1a5984806c5b2721ed1e2aab590e93","modified":1681718060189},{"_id":"public/2022/08/07/3DSlicer插件制作/index.html","hash":"213bc1db1bee189dcaa2fa5d53701627e6c23912","modified":1681718060189},{"_id":"public/2022/08/01/Games101-3-光栅化/index.html","hash":"b67de04b8be67fd081f615c6f025cfdc1b303f24","modified":1681718060189},{"_id":"public/2022/07/21/Games101-2-变换/index.html","hash":"f96076c1e283d9eb98102baf58de9a9eba5d09ce","modified":1681718060189},{"_id":"public/2022/07/20/Games101-1-线代基础/index.html","hash":"00124dfdcdd103b67f8e5a20fc210fde0630e733","modified":1681718060189},{"_id":"public/2022/06/19/3DSlicer配置编译/index.html","hash":"e44501d0c77919000bd38ae77e883b89a62478d1","modified":1681718060189},{"_id":"public/2022/04/26/20220425讨论/index.html","hash":"cc022fb8f6974b5effda193fd6f2eddbeed447ae","modified":1681718060189},{"_id":"public/2022/04/06/Markdown用法简介/index.html","hash":"7e3657080db37152ffae342b2558f18f8f38963b","modified":1681718060189},{"_id":"public/index.html","hash":"16616e8998badc7580c18f6131063f9fa4dbb62a","modified":1681885305978},{"_id":"public/page/2/index.html","hash":"d75fa7a5466fdb9fc231e0ec0a831559e29082ec","modified":1681885269957},{"_id":"public/page/3/index.html","hash":"9b99c49252086fbaafb6a195ac7cb289d4133f21","modified":1681885269957},{"_id":"public/categories/index.html","hash":"470e0b2e6bf0ac24f71418c531869571978c9c76","modified":1681885305978},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1681718060189},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1681718060189},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1681718060189},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1681718060189},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1681718060189},{"_id":"public/article_img/2022-05-30-19-02-18.png","hash":"84b955a0f8637abee229ed02827477aa91ec40e4","modified":1681718060189},{"_id":"public/article_img/2022-05-31-15-45-30.png","hash":"e8b846da732571b8cd7f7fffbdfa30e6e6465f10","modified":1681718060189},{"_id":"public/article_img/2022-05-30-19-12-19.png","hash":"c66250fd4b1106d76d6883f49defe9ea847dfcd6","modified":1681718060189},{"_id":"public/article_img/2022-05-31-15-48-06.png","hash":"a8e5f2e27e6ccad1201cdf0f160c459929c6bbd7","modified":1681718060189},{"_id":"public/article_img/2022-05-31-15-59-31.png","hash":"eb03d920266fbc27d0b7028693acd80e469d89c5","modified":1681718060189},{"_id":"public/article_img/2022-05-31-16-23-44.png","hash":"f6609ee31ca71982814311648e6f2c00357fe98e","modified":1681718060189},{"_id":"public/article_img/2022-05-31-16-22-07.png","hash":"6aba2a9abe75625322d48568d4c595496d0f76e3","modified":1681718060189},{"_id":"public/article_img/2022-07-21-13-53-30.png","hash":"195b8626a5742b87b4c010c336737f88f97b4fb7","modified":1681718060189},{"_id":"public/article_img/2022-07-21-13-55-49.png","hash":"e166bec98ea94234ecf1a382341aebfc47d69a85","modified":1681718060189},{"_id":"public/article_img/2022-07-21-13-46-46.png","hash":"0f5deb9e74f839c4068f5509c60f2d68d4a78b97","modified":1681718060189},{"_id":"public/article_img/2022-07-21-14-00-29.png","hash":"c47eee39e94a246eb5b6e8cf08de07ecffa0d9c6","modified":1681718060189},{"_id":"public/article_img/2022-07-21-14-08-35.png","hash":"9fe3ecd6cf1f7f45b2f82f597b063c231c47693f","modified":1681718060189},{"_id":"public/article_img/2022-07-21-14-10-55.png","hash":"9b57085bf7330ed2cc27a202ef684b6557995116","modified":1681718060189},{"_id":"public/article_img/2022-07-21-14-15-24.png","hash":"3b090f20a6e162a9234275061f54cd88c626ce57","modified":1681718060189},{"_id":"public/article_img/2022-07-21-14-12-24.png","hash":"e79fc38871fa8cb2d5518590b1226c1c5a3b81e3","modified":1681718060189},{"_id":"public/article_img/2022-08-01-18-23-48.png","hash":"a89fd1c85e3726eca129fd4dc8cc7e8e4729bdad","modified":1681718060189},{"_id":"public/article_img/2022-08-01-18-34-08.png","hash":"f5f202301574b93730856c9c54ed911be5594632","modified":1681718060189},{"_id":"public/article_img/2022-08-01-18-43-06.png","hash":"885da975c5e9f4ade5c5b0a506b2030f2fdd864e","modified":1681718060189},{"_id":"public/article_img/2022-08-01-18-27-54.png","hash":"90f6f944035ade40656ffb8ba5a2d6c220d30e50","modified":1681718060189},{"_id":"public/article_img/2022-08-01-18-50-39.png","hash":"00f60bd3ba53ad9689bc008dcae467aabbfcdd66","modified":1681718060189},{"_id":"public/article_img/2022-08-01-18-53-06.png","hash":"a0f847b0d1014dab2850b907cf616e908a50121a","modified":1681718060189},{"_id":"public/article_img/2022-08-03-10-31-16.png","hash":"29dc3e56d34a5c00e2b60eb095c09730a9649e59","modified":1681718060189},{"_id":"public/article_img/2022-08-03-10-22-45.png","hash":"31978e3f979be13cac28336744a871ea3fd6ea2b","modified":1681718060189},{"_id":"public/article_img/2022-08-01-20-43-53.png","hash":"8442551e6a01a3a43f38b31f90545ec7b93a2446","modified":1681718060189},{"_id":"public/article_img/2022-08-03-10-39-27.png","hash":"c7aefebea3ccf982f23e86b52f17086c9a7ee186","modified":1681718060189},{"_id":"public/article_img/2022-08-03-20-33-34.png","hash":"2116aacfeaf676472145cd6df43dc7154064efcd","modified":1681718060189},{"_id":"public/article_img/2022-08-03-20-32-33.png","hash":"c88c27fed1034b44776a58f495c35e224893f9ed","modified":1681718060189},{"_id":"public/article_img/2022-08-03-20-29-06.png","hash":"c9470eb257b21ac9590215325b99cc2049a995b2","modified":1681718060189},{"_id":"public/article_img/2022-08-03-20-33-50.png","hash":"529756c6d081d2145dd7b5617fe72ac782eb2982","modified":1681718060189},{"_id":"public/article_img/2022-08-11-08-56-46.png","hash":"03b0741d3089e019779c6807d041d4265142bce1","modified":1681718060189},{"_id":"public/article_img/2022-08-11-11-15-21.png","hash":"fd53ce44233e39dcbe49d5257a7f2461074786d1","modified":1681718060189},{"_id":"public/article_img/2022-08-26-15-13-22.png","hash":"dc7a6a43795b67fe89956e84c815adc6ea1c05f5","modified":1681718060189},{"_id":"public/article_img/2022-08-27-09-10-47.png","hash":"728e96e7bf51410576d877d6c90c8d0058842e0a","modified":1681718060189},{"_id":"public/article_img/2022-08-27-09-17-28.png","hash":"d98336b6d64f8ce26ad73690fc3b19506b85848b","modified":1681718060189},{"_id":"public/article_img/2022-08-27-09-21-07.png","hash":"149074e64e3bd543c04a17eabfedc7c9c96cc013","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-18-27.png","hash":"dca358d7f89d618acf0ce43a533c1db854bd8148","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-14-39.png","hash":"5ebe60a44b1e30a7a4f4c36d6aebfb7dc3ef830c","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-23-14.png","hash":"a0b5b42bfb1eff1bdd85e3b390090f3c3ebb96ed","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-18-42.png","hash":"7b505c1805b19d195fe8e172fd6e188ad66c432f","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-35-09.png","hash":"ec325c194190e2f021dd79862cb026b8c9d36cae","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-20-23.png","hash":"eeb13a8d33e0380eca5f26f20cf0e3fe0f48b436","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-38-15.png","hash":"d84f74aba175e8effa90abfeaae0fe2dcead2334","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-39-32.png","hash":"a4dc1741ddc67e7435adc62ac3912b409c550cf6","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-49-44.png","hash":"5bf3cfbf6e1c5615b8bfaa88d492424282eacfe2","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-48-55.png","hash":"4b7ac586e2ecbb1ffc9080e727bac750d655b059","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-50-45.png","hash":"9f599a0033401e2f93fc208a1922b29200cf9c47","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-51-54.png","hash":"550b39adb015a5c3233e44238537e74e30e3c9f9","modified":1681718060189},{"_id":"public/article_img/2022-08-29-16-18-04.png","hash":"858a618933d8fe8ebfffb0adcb34b1d99b689a6c","modified":1681718060189},{"_id":"public/article_img/2022-08-29-16-22-31.png","hash":"2aab023d81df4417874b8fe0a9def954c6e01901","modified":1681718060189},{"_id":"public/article_img/2022-08-29-16-24-37.png","hash":"1c753f9f054891afd25d6d54a1f519a0b5069a72","modified":1681718060189},{"_id":"public/article_img/2022-08-29-16-23-23.png","hash":"96735f2e1c39e849d71473b7dc1e2e5bb41cd1f0","modified":1681718060189},{"_id":"public/article_img/2022-08-29-16-29-49.png","hash":"2525fb4e879dd33c871e3e709a58c592291dad14","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-30-33.png","hash":"557125fa72e57f74e98b60052cc41e4a1586d5f4","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-33-20.png","hash":"c2b1729a8b9e1ef297c5b78b7aa3a4196752d41f","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-35-24.png","hash":"a165ee43735c1fc503561bed8227c89d07fab32e","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-41-51.png","hash":"466d84f26f096657c667b758e918b093299442a4","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-52-05.png","hash":"4ad70f2681b2149156a290cd33f617e57a2027a2","modified":1681718060189},{"_id":"public/article_img/2022-08-29-19-00-41.png","hash":"86f67a7140de122f6d05b033811570d62af644a1","modified":1681718060189},{"_id":"public/article_img/2022-08-29-19-06-16.png","hash":"4fb25f5bdb4a70d5fe5390c0646df4701268df41","modified":1681718060189},{"_id":"public/article_img/2022-08-29-19-06-26.png","hash":"7e9def7a2e10c93601644092454871cad38ddc9b","modified":1681718060189},{"_id":"public/article_img/2022-09-26-14-28-48.png","hash":"581d38625694a66700d83e37b4516095a23f3f74","modified":1681718060189},{"_id":"public/article_img/2022-09-26-21-01-37.png","hash":"cacbb2c870a2e43f26437304bc58b902fd1e90b0","modified":1681718060189},{"_id":"public/article_img/2022-09-27-11-50-57.png","hash":"162ba438d989ed1b4089ba6a48d3f132cefd6ed1","modified":1681718060189},{"_id":"public/article_img/2022-09-27-13-10-42.png","hash":"b7462d089bd4c449b0c1ccc591605afebcdf6f2f","modified":1681718060189},{"_id":"public/article_img/2022-09-27-19-39-22.png","hash":"1c53cf3788d5a054542ebd3b1d6510aece089963","modified":1681718060189},{"_id":"public/article_img/2022-09-29-15-43-18.png","hash":"41ff96a6e48d5a67b9a3bc6620c12b5d4fa41a24","modified":1681718060189},{"_id":"public/article_img/2022-10-09-14-06-32.png","hash":"dea60e820858ff23f2bd710449257dccaaa77696","modified":1681718060189},{"_id":"public/article_img/2022-10-09-14-28-04.png","hash":"d82944e03364ebf4dec9365c208636c8720df658","modified":1681718060189},{"_id":"public/article_img/2022-10-11-17-42-58.png","hash":"950302921d5e0a1af6e2929ad3b60c15d45bde49","modified":1681718060189},{"_id":"public/article_img/2022-10-11-17-42-00.png","hash":"c94ac7f2b3fa4c65058c251cb0002cee7d55bed2","modified":1681718060189},{"_id":"public/article_img/2022-10-11-17-45-24.png","hash":"c9c0ce727191deaa227eff0f4ac4769288c3d65d","modified":1681718060189},{"_id":"public/article_img/2022-10-11-17-46-35.png","hash":"e796e316e37a6891511b01b4719f350b37b18396","modified":1681718060189},{"_id":"public/article_img/2022-10-11-17-50-28.png","hash":"81876817f0b96b4fd8519391b7a4d0b558449173","modified":1681718060189},{"_id":"public/article_img/2022-10-11-17-54-18.png","hash":"85262a75c3f8b316ea2b514608149b91163edb07","modified":1681718060189},{"_id":"public/article_img/2022-10-11-17-57-15.png","hash":"6688ee57ab3b137fa5fdee74ab5ce15cb964008f","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-08-40.png","hash":"982c21682faf10e161315717c24794af07267338","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-12-37.png","hash":"8bcbe9a38ba4d3c4165dba63b81657cc8aa327db","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-18-49.png","hash":"eb3996fbf69274553d6c07169b56a374bd2fdecf","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-19-43.png","hash":"e4ff5881073bf1b0fd46e0fc9db20a74c08f05be","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-30-32.png","hash":"6ba96f7d83035bce29dee06a1321cc8486a20bb0","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-32-03.png","hash":"f8cb0ef57eb005c448b407c79f78f7a4d4ace948","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-30-38.png","hash":"e33158182e2df3e7e15f052bdbc8a6265761ef31","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-35-53.png","hash":"f9436dcf37fec22282ef6011116d30b6498d8f6e","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-36-23.png","hash":"10ce0ce5199087df9df2e2460351b40406696a18","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-40-01.png","hash":"f09fa9f341a6a862339e3fde317344b8a117b78d","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-40-53.png","hash":"1ebd1052e724acdc2ccf95be9b6efb207e077389","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-41-58.png","hash":"0c491d859dc483be49a4385fdceec6aa951dfaa2","modified":1681718060189},{"_id":"public/article_img/2022-10-12-11-59-26.png","hash":"8a9964c27fc0a960e925ce628f0ece5ad6b955c8","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-04-58.png","hash":"100054259bde0a720a4b9cd1c8acf0858837124f","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-08-22.png","hash":"e62e597132385b019baa04636f4c31c10e45b851","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-03-15.png","hash":"6bce1dce6cef4d1ca5d8b6f6a70ef945683e55bc","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-12-57.png","hash":"5dbbafb2be1132873cda606708788c3799066b34","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-28-37.png","hash":"99b4c990f996570a2b104ab4a21ead392de96397","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-30-45.png","hash":"44f33077fde29076a3aef1d09b05c50c2dce529f","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-38-07.png","hash":"f40d73a8cc61e71e731943a3d4b3bbd1ec08791f","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-40-29.png","hash":"45b582dd5ce534e6e043bc20e3c7cfff98eadfc5","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-57-17.png","hash":"d78388f2210449415bd748a5ea303debd14e781b","modified":1681718060189},{"_id":"public/article_img/2022-10-12-13-10-52.png","hash":"f93f7e81a81bdbef5993e73b17ab69a02a78c4ea","modified":1681718060189},{"_id":"public/article_img/2022-10-12-19-16-44.png","hash":"6295db0c4da4605d78ef3f93e55f828021098c8b","modified":1681718060189},{"_id":"public/article_img/2022-10-12-13-12-07.png","hash":"e65957cde1ebfadf19e904305383953dad59125d","modified":1681718060189},{"_id":"public/article_img/2022-10-12-19-17-41.png","hash":"e31141e20495a4d6beefef7f42a5367f22b53a72","modified":1681718060189},{"_id":"public/article_img/2022-10-12-19-18-35.png","hash":"3d642cccc3307a6cdb091e5a8b1b63a55c3189c4","modified":1681718060189},{"_id":"public/article_img/2022-10-12-19-20-22.png","hash":"244e9fea450e810c2301939290818cad82445a4b","modified":1681718060189},{"_id":"public/article_img/2022-10-12-19-20-11.png","hash":"319851d6a774bb2a1bf62b1f69a34d2e08323ca1","modified":1681718060189},{"_id":"public/article_img/2022-10-12-19-20-41.png","hash":"55432063b7d4f19b3abf10415cce9d4e5e2883cc","modified":1681718060189},{"_id":"public/article_img/2022-10-13-14-37-13.png","hash":"b569d5f4b2d0aa84d4d4db6b9fe3f76befb6857c","modified":1681718060189},{"_id":"public/article_img/2022-10-13-14-37-15.png","hash":"b569d5f4b2d0aa84d4d4db6b9fe3f76befb6857c","modified":1681718060189},{"_id":"public/article_img/2022-10-13-14-40-09.png","hash":"a4f164b03a50bda1df93f68749178d2058574398","modified":1681718060189},{"_id":"public/article_img/2022-10-13-14-41-58.png","hash":"1cfa7422455160e9981f7f3c8a3ac3b6da049664","modified":1681718060189},{"_id":"public/article_img/2022-10-13-14-42-30.png","hash":"3a748861e886c60b14547b5234d5159492f1289d","modified":1681718060189},{"_id":"public/article_img/2022-10-13-14-42-38.png","hash":"fa871ee5eb431effbfe0474bc190aa5261d773fe","modified":1681718060189},{"_id":"public/article_img/2022-10-13-14-50-16.png","hash":"7d3e68d3736e81f9d5184fd46ac0ee5821f76275","modified":1681718060189},{"_id":"public/article_img/2022-10-13-14-45-56.png","hash":"fc8125f07041c37f38b38c26e2539d9b78dea3f0","modified":1681718060189},{"_id":"public/article_img/2022-10-13-15-58-06.png","hash":"1eb12f149d5fb66c15fbc8ee822be938d0ee4a7f","modified":1681718060189},{"_id":"public/article_img/2022-10-14-12-42-03.png","hash":"7044082d1c894e72dc12e682f95a4dd79e2d2b79","modified":1681718060189},{"_id":"public/article_img/2022-10-14-12-45-56.png","hash":"1874f1a2854e8de69f0684f46ce55d969cba3341","modified":1681718060189},{"_id":"public/article_img/2022-10-14-12-49-41.png","hash":"3874589d649b40fd4f96baf21e42213ddf041cbd","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-21-28.png","hash":"f3ab422f56622894b923d72e1f99a06c395e4006","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-31-26.png","hash":"f5b5cb99d20afa1d52cf6a0627a5bacedab4523d","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-33-18.png","hash":"4b3b67c687478f8eca1742cf42c1f36f925f9832","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-33-45.png","hash":"f4fff7b2fcff4bddcde4112c9c1eb97a20281f04","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-38-56.png","hash":"833798b48e405bd63bcd3771f4d408c1ef1a22b1","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-49-56.png","hash":"0865613d2bfc25932c657fa4749e32adfa9d46ab","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-50-38.png","hash":"d2b976345ff7d191e34f6b7d34abf5b2cb98a693","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-51-16.png","hash":"19ed8d90eda38462e5bbdd288a8a8a6964257527","modified":1681718060189},{"_id":"public/article_img/2022-10-20-11-18-34.png","hash":"9f010a3b8a0107799b2677c2f83f8411da4fe7de","modified":1681718060189},{"_id":"public/article_img/2022-10-20-11-18-53.png","hash":"b25eedb85083af2803cfd747f87c48ab2ff1ab75","modified":1681718060189},{"_id":"public/article_img/2022-10-20-11-19-22.png","hash":"2bb4f766dd061ab5db5f9f50c4a6d7c262a91710","modified":1681718060189},{"_id":"public/article_img/2022-10-20-11-23-56.png","hash":"ba99c0f43f42404d440d45d81368d815e4790c8d","modified":1681718060189},{"_id":"public/article_img/2022-10-20-11-20-06.png","hash":"23195bade890b3f794f29f7c1055456747826f95","modified":1681718060189},{"_id":"public/article_img/2022-10-20-11-25-41.png","hash":"6f9a2f1c5de89496f11f62cd390a69bb295e8ce4","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-07-59.png","hash":"14c798af6f4e79137c4c04e5169727e78f0d8ff7","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-17-30.png","hash":"e2fc6672c813cc7789c4e5c6cadae3d07c18d696","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-27-38.png","hash":"a9629ac0e1919f1c5ee72f74fce3fba9fb391e2d","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-27-03.png","hash":"efb309bbb1f55b55ec9792be540f4ed9389b1094","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-36-55.png","hash":"a4ae3e438bd768cea6a2e3ffcf380699be724aac","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-41-23.png","hash":"c23d30fcabbf4d962b2e86c3e41798cdf830b34e","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-40-09.png","hash":"68d7f7bb7c0772e3e37a89c030882c0ef4b0cbc7","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-50-09.png","hash":"877522f53022e55d2b7008729a3432581c36b411","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-50-17.png","hash":"94a44f400d24e3018788ad9478d0f66d39805b54","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-50-26.png","hash":"356b7b15e1719551c41904c40815b0b1c3ec7bd3","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-55-15.png","hash":"23a106f396e851dce3a638ed4dc40a62a3341e4d","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-55-32.png","hash":"a1777465eb5cd09446e2a7ac4e11e950e897044a","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-55-42.png","hash":"9231953f60864817c0a257038984febdbba5ab03","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-03-00.png","hash":"abb59708a25bf2cf400b35fc264d45470b3de05d","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-01-06.png","hash":"f26cc542e53232a871cd2b708e9cd325173ac5ac","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-20-05.png","hash":"86158ba98c4c16ea2a49e2c8cbc46d5f5771e843","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-22-02.png","hash":"1ae191e1e35cd95c64e51b5a227807ca016c3572","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-29-17.png","hash":"d911bc7972ca369c44c2b46e385a904d22577cae","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-30-36.png","hash":"eeb9850d84a6137f8e680bf6b3dfac26701a9834","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-29-34.png","hash":"7db2e9796ac1705549957f297b9679fe2a406e96","modified":1681718060189},{"_id":"public/article_img/2022-10-24-14-28-44.png","hash":"ce34b554448169a84570828a7765d292a9b8e815","modified":1681718060189},{"_id":"public/article_img/2022-10-27-14-16-43.png","hash":"ae739b7fc421f0c18cdc0ce45034dff5a9729d0d","modified":1681718060189},{"_id":"public/article_img/2022-10-24-14-47-45.png","hash":"d05881b947c0f828d4d1bfb643324982fb74b1ed","modified":1681718060189},{"_id":"public/article_img/2022-10-27-15-12-46.png","hash":"3ad58b3a01d7f0abfcfa49f4dbee21d8e75d32c2","modified":1681718060189},{"_id":"public/article_img/2022-10-27-15-32-33.png","hash":"c0aacab6597e628b14a8813087c1b597d5060f09","modified":1681718060189},{"_id":"public/article_img/2022-10-27-15-54-08.png","hash":"2f2753c9458a79af14b793b918103cc22de4ef66","modified":1681718060189},{"_id":"public/article_img/2022-10-28-17-09-17.png","hash":"c6cf5de0b47123f31078cc93562d008f12188490","modified":1681718060189},{"_id":"public/article_img/2022-10-27-16-10-17.png","hash":"2a2fa2ff53f29c712293dde96a2aae658e135c01","modified":1681718060189},{"_id":"public/article_img/2022-10-28-19-11-33.png","hash":"b7cc715e6c9d0b77898181ae1a9a3c29bd1e28b7","modified":1681718060189},{"_id":"public/article_img/2022-10-28-19-32-16.png","hash":"df9c57645acdaf979dc63c381f73d59f5ce65c5e","modified":1681718060189},{"_id":"public/article_img/2022-10-28-19-37-42.png","hash":"7e4d455d1c262f7eee815ad4dfb85bb10a178274","modified":1681718060189},{"_id":"public/article_img/2022-10-28-19-52-39.png","hash":"ec170493a06e3d50c4f6471c1af3c8fa0a4f1b9a","modified":1681718060189},{"_id":"public/article_img/2022-10-28-19-53-14.png","hash":"3d65dfaf067c4336b7ce4571d176285c2512d3ce","modified":1681718060189},{"_id":"public/article_img/2022-10-29-13-44-18.png","hash":"f0e968225f52e1cc85555b29b0968979c6fc337d","modified":1681718060189},{"_id":"public/article_img/2022-10-29-13-58-15.png","hash":"08525f9d7ab4e9f9d7d61f07393a823f08e47929","modified":1681718060189},{"_id":"public/article_img/2022-10-29-14-44-06.png","hash":"26022b78120ff0dd6a0414404fe4022e2742ff05","modified":1681718060189},{"_id":"public/article_img/2022-10-29-14-50-09.png","hash":"f47be6ab6c6fc33f00c6a7d59c7fa7e1c023e9f9","modified":1681718060189},{"_id":"public/article_img/2022-10-29-15-01-54.png","hash":"3cb5366abf35d0a89ce4e3a84f370f4710a17a02","modified":1681718060189},{"_id":"public/article_img/2022-10-29-15-02-48.png","hash":"f02046610711bec2c8c13882d14e02702f35a2cb","modified":1681718060189},{"_id":"public/article_img/2022-10-29-18-15-59.png","hash":"52c2590b804db88ac890f4fb5a5096703354aac1","modified":1681718060189},{"_id":"public/article_img/2022-11-01-17-16-23.png","hash":"15fe7ddf41c083a554ec19e25dcf285a60d4cf64","modified":1681718060189},{"_id":"public/article_img/2022-11-01-17-16-55.png","hash":"e964d03ff85011adca52fea5ab88990bc6dd6662","modified":1681718060189},{"_id":"public/article_img/2022-11-01-19-12-45.png","hash":"b47feaac433e3a3c9be9d9a48f82f984a5fe3469","modified":1681718060189},{"_id":"public/article_img/2022-11-02-15-16-52.png","hash":"e36e64f694b7b1d0d54671abdcebee07d7c67c95","modified":1681718060189},{"_id":"public/article_img/2022-11-10-16-13-24.png","hash":"385a75ba0297bb6127ffaec938f08ac5b8a0ec1d","modified":1681718060189},{"_id":"public/article_img/2022-11-10-16-13-36.png","hash":"b294c1d2956a3b9c5435676912f41779bde4536f","modified":1681718060189},{"_id":"public/article_img/2022-11-10-16-25-36.png","hash":"6f0eb595df514d5c0393ac84de1a4e113c85f875","modified":1681718060189},{"_id":"public/article_img/2022-11-10-16-26-15.png","hash":"eb188f833d18a7e5dca8bb86fd75c8270763fa3d","modified":1681718060189},{"_id":"public/article_img/2022-11-10-16-28-11.png","hash":"ebf8fe30b649bab0f588b3033e5de80b7a4f8e3a","modified":1681718060189},{"_id":"public/article_img/2022-11-12-14-23-16.png","hash":"58781421824901c9f1ba3dbcbc8424784a655726","modified":1681718060189},{"_id":"public/article_img/2022-11-12-14-39-20.png","hash":"335073dcd4c5f6ed2c2fa93d55f9754fefb6b169","modified":1681718060189},{"_id":"public/article_img/2022-11-12-14-57-30.png","hash":"41b1373c542fefd7a00b0004e363ace6fefc8fa4","modified":1681718060189},{"_id":"public/article_img/2022-11-14-14-33-55.png","hash":"b35d82e8f28d1fa301c121d71dd23f31090b5dfb","modified":1681718060189},{"_id":"public/article_img/2022-11-15-16-11-14.png","hash":"ea00717d463ef936026872b814bf7dee1961a262","modified":1681718060189},{"_id":"public/article_img/2022-11-15-16-24-42.png","hash":"f9eb6ac7811d981f9c2dcf40b88aef6ca45743ec","modified":1681718060189},{"_id":"public/article_img/2022-11-17-13-46-15.png","hash":"e4369e196e3c007807010eb9dc2de9e47a6f3180","modified":1681718060189},{"_id":"public/article_img/2022-11-17-13-53-01.png","hash":"5f4b023710d93aa7c83ed8cd76b4a886ac7bb32c","modified":1681718060189},{"_id":"public/article_img/2022-11-17-14-47-05.png","hash":"ecb7e37175af5d5d086764addc097d04550ac5ea","modified":1681718060189},{"_id":"public/article_img/2022-11-17-15-41-49.png","hash":"e0961f1cdd09ff0dd89e786247ae1399dd7d8337","modified":1681718060189},{"_id":"public/article_img/2022-11-18-13-08-21.png","hash":"9f44783c1847777a20b7c4e4924e42e9178f0690","modified":1681718060189},{"_id":"public/article_img/2022-11-18-13-08-34.png","hash":"db73a27020075242e3888a0b4917269e75b6ee4f","modified":1681718060189},{"_id":"public/article_img/2022-11-18-13-37-14.png","hash":"79d2c9a544b4d68f2a82048149731ea286d40d8c","modified":1681718060189},{"_id":"public/article_img/2022-11-19-14-21-12.png","hash":"7532435f20397952c5cbcc06b1491b24a7bc6c0f","modified":1681718060189},{"_id":"public/article_img/2022-11-19-14-23-11.png","hash":"d6cdfc01ed22a0f367dbb223d238ad331009da3d","modified":1681718060189},{"_id":"public/article_img/2022-11-20-20-31-42.png","hash":"d9c242b8f93cd5614d4cff2306cda5a4030dc468","modified":1681718060189},{"_id":"public/article_img/2022-11-19-14-31-19.png","hash":"3aa61b324ceae1f9020ca7bf00f23bc008efbea8","modified":1681718060189},{"_id":"public/article_img/2022-11-20-20-33-26.png","hash":"dc1b7c263d61244f3b5dff79a3f46ce7650563e8","modified":1681718060189},{"_id":"public/article_img/2022-11-20-20-43-49.png","hash":"6ac67a04a65538c7dbce8cdd4e8bc51f931d9346","modified":1681718060189},{"_id":"public/article_img/2022-11-20-21-04-47.png","hash":"363194772d6acc7379062e276ee2f1d24b9a8826","modified":1681718060189},{"_id":"public/article_img/2022-11-21-13-59-43.png","hash":"5f6f5b0d527a2db15101010b0a88a95a46ed36c6","modified":1681718060189},{"_id":"public/article_img/2022-11-20-21-04-39.png","hash":"76886e17de3661cee30d88cfcc97543d96101533","modified":1681718060189},{"_id":"public/article_img/2022-11-21-18-38-09.png","hash":"8fdf80a0ac7515ce4ce43edef25cf48126ac93c4","modified":1681718060189},{"_id":"public/article_img/2022-11-21-18-08-07.png","hash":"de07c2a02f109a1e273232aa150eb6738be3e091","modified":1681718060189},{"_id":"public/article_img/2022-11-21-18-44-53.png","hash":"786476dcdc2262f0efb4bd7907487c656693b965","modified":1681718060189},{"_id":"public/article_img/2022-11-21-18-04-01.png","hash":"d9815ab76a9540024850f272481a08224a4aed2d","modified":1681718060189},{"_id":"public/article_img/2022-11-21-18-45-12.png","hash":"07921677770d9d49b02985d7b94fe3acdfd5997c","modified":1681718060189},{"_id":"public/article_img/2023-01-29-18-13-30.png","hash":"f91f5da5940f76e3f43aac60fba8c079e01dbef0","modified":1681718060189},{"_id":"public/article_img/2023-01-29-17-59-12.png","hash":"a0b5b42bfb1eff1bdd85e3b390090f3c3ebb96ed","modified":1681718060189},{"_id":"public/article_img/2023-01-29-18-15-41.png","hash":"30e2ec8e5623c437e8db4224b24a88593c7a8669","modified":1681718060189},{"_id":"public/article_img/2023-01-29-19-28-42.png","hash":"d84f74aba175e8effa90abfeaae0fe2dcead2334","modified":1681718060189},{"_id":"public/article_img/2023-01-29-19-37-56.png","hash":"fa473e2786693d21dcdf5a46794fc6a3530be2dc","modified":1681718060189},{"_id":"public/article_img/2023-01-29-19-58-58.png","hash":"e3ab6694b287b8ee91b612acb716b4cfa3b23890","modified":1681718060189},{"_id":"public/article_img/2023-01-30-13-26-02.png","hash":"655ad56262e553b1de860a899eecf6eefc1e4f63","modified":1681718060189},{"_id":"public/article_img/2023-01-30-18-59-45.png","hash":"ced4bd899065603807fea30b17fac57be880ca6d","modified":1681718060189},{"_id":"public/article_img/2023-01-30-19-01-11.png","hash":"bcae25d9a27ad4406237476a9ec8679c5c552232","modified":1681718060189},{"_id":"public/article_img/2023-01-30-18-59-59.png","hash":"b33cebedffb3916a9aafac6084ab028172cccbd9","modified":1681718060189},{"_id":"public/article_img/2023-01-30-20-12-26.png","hash":"4f4554252bd72c2531ca3ba92f7e11c274daf7a9","modified":1681718060189},{"_id":"public/article_img/2023-01-30-20-10-34.png","hash":"b4bd329c423a3be854732fe2101f34cd82f59c5e","modified":1681718060189},{"_id":"public/article_img/2023-01-30-20-14-01.png","hash":"5a5b52c19f341f911bc0533244ddd2ce5155e5af","modified":1681718060189},{"_id":"public/article_img/2023-01-30-20-18-46.png","hash":"5c72402786763d3d831ffe29ebb4788bfc294cdd","modified":1681718060189},{"_id":"public/article_img/2023-03-18-18-55-20.png","hash":"4583b8482e1c5cf4470fb84d323eb97387e750fc","modified":1681718060189},{"_id":"public/article_img/2023-03-18-18-56-04.png","hash":"c0c82f87e39a5093f38a0b0e09b5f1bd0246b989","modified":1681718060189},{"_id":"public/article_img/2023-03-18-19-01-01.png","hash":"729449fdd549d4a1874af1ac94a8b9bdebd4f2ff","modified":1681718060189},{"_id":"public/article_img/2023-03-18-19-24-34.png","hash":"e5029e3d8b0852044a9ef98bbca6e197e495b26c","modified":1681718060189},{"_id":"public/article_img/2023-03-22-12-23-50.png","hash":"6f411ee52c13b528f640f5a9437b13bef6ed65ac","modified":1681718060189},{"_id":"public/article_img/2023-03-22-12-25-07.png","hash":"883e09284c1d50e3c0c6fca1b24a42e3cca54933","modified":1681718060189},{"_id":"public/article_img/2023-03-22-12-49-01.png","hash":"181f6d7e1dea6bcc603da44163f6d90c9ab61d22","modified":1681718060189},{"_id":"public/article_img/2023-03-22-12-56-23.png","hash":"578f8069d993ba67906e4ba8dd1f6ce1bc2a035a","modified":1681718060189},{"_id":"public/article_img/2023-03-22-13-00-16.png","hash":"91dda246e14ad2caddd53f5b3ba3b6a0b2f6c992","modified":1681718060189},{"_id":"public/article_img/2023-03-25-15-16-38.png","hash":"a1d2baec40c715045f030e22f1e6c54addacebf6","modified":1681718060189},{"_id":"public/article_img/2023-03-25-15-11-00.png","hash":"f0ed874ec73475c52cdcaed7008b8de4a115787b","modified":1681718060189},{"_id":"public/article_img/2023-03-25-15-20-53.png","hash":"989fcfdf3b0fda1da5f2a29adddefab6f9772331","modified":1681718060189},{"_id":"public/article_img/2023-03-25-15-26-06.png","hash":"8ebe41c3c162fed81cb03efe21f38855c1bb29dd","modified":1681718060189},{"_id":"public/article_img/2023-03-25-15-33-19.png","hash":"fed50b13d69a9d273f694a0e5d964bae31927889","modified":1681718060189},{"_id":"public/article_img/2023-03-25-15-32-24.png","hash":"d4efe67cdfa2154547510f0cdbbb817afa2102e6","modified":1681718060189},{"_id":"public/article_img/2023-03-25-15-36-39.png","hash":"77e36324e0ab336dab107346cc4c7b93fbab679e","modified":1681718060189},{"_id":"public/article_img/2023-03-26-13-34-47.png","hash":"8ed8f6ecf72f2c7f17e7136d885bd94a0047f38c","modified":1681718060189},{"_id":"public/article_img/2023-03-26-13-35-34.png","hash":"5cf8c850b20be881c34f161a544397cc431b81da","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-03-35.png","hash":"0f3b69a6408e8cb6b4a73a3f28c399a4e48af416","modified":1681718060189},{"_id":"public/article_img/2023-03-26-18-08-33.png","hash":"f3d7209be9c785f4cbde618988cff380f18a9681","modified":1681718060189},{"_id":"public/article_img/2023-03-26-18-26-36.png","hash":"d4f096c32f5457fc46b270ce4d5e0700e5c8a0c5","modified":1681718060189},{"_id":"public/article_img/2023-03-26-18-48-25.png","hash":"0c81e8827b5d39b16b04928b0d178a7e34cee40a","modified":1681718060189},{"_id":"public/article_img/2023-03-26-18-56-23.png","hash":"ecc6d2814c5b6689e704b6b0e625b2c5fe0167fc","modified":1681718060189},{"_id":"public/article_img/2023-03-26-19-14-54.png","hash":"7b3d96b88fe7feee2be18b8a3028ef3b227c5f67","modified":1681718060189},{"_id":"public/article_img/2023-03-26-19-14-59.png","hash":"035442270e5ca9d4fd134e8f3894940265532dbf","modified":1681718060189},{"_id":"public/article_img/2023-03-26-19-17-06.png","hash":"1552935e56d6fa2e5c5b32acbf1b1ef0978bdfb3","modified":1681718060189},{"_id":"public/article_img/2023-03-26-19-17-26.png","hash":"b887a13e35e6c4d5d7a4811a3549caea7ca86593","modified":1681718060189},{"_id":"public/article_img/2023-03-29-13-40-25.png","hash":"0fe32aeb0e069c594c494fc38c052b0e13d65a66","modified":1681718060189},{"_id":"public/img/bg/Blender_cover.jpg","hash":"796e5d5a58b7c6b7cd0b3dd42434d683a4f8a481","modified":1681718060189},{"_id":"public/img/bg/EulerAngle.jpg","hash":"3ae3b34018cdd22ca036d9784b61245b42b45b8f","modified":1681718060189},{"_id":"public/img/bg/Logo.jpg","hash":"0c2f49c6175e04fafdaadb64d8df192979803890","modified":1681718060189},{"_id":"public/img/bg/Logo.png","hash":"df0ab2f66e3644b4d6951baaeff5824686c80fbc","modified":1681718060189},{"_id":"public/img/bg/opengl.jpg","hash":"9d1f1133409327051af41fa0291d5f769c2604c3","modified":1681718060189},{"_id":"public/img/bg/profile.jpg","hash":"74ef610c7cc2a0ae383c608b9e59923208581b4c","modified":1681718060189},{"_id":"public/img/bg/unity_logo.jpg","hash":"43447ecf42da5172258c6362350bcc7ba335c97c","modified":1681718060189},{"_id":"public/img/bg/wechat.jpg","hash":"4182333419b7fde017c6c34dc08767d3d868cce1","modified":1681718060189},{"_id":"public/article_img/![](/article_img/2022-10-12-19-20-22.png).png","hash":"55432063b7d4f19b3abf10415cce9d4e5e2883cc","modified":1681718060189},{"_id":"public/article_img/![](/article_img/2022-10-24-14-28-16.png).png","hash":"ef8f56bc99dddbda87cc5ef428553302b7b30b85","modified":1681718060189},{"_id":"public/article_img/![](/article_img/2023-03-22-12-23-50.png).png","hash":"883e09284c1d50e3c0c6fca1b24a42e3cca54933","modified":1681718060189},{"_id":"public/article_img/2022-05-30-19-01-47.png","hash":"ca2d8c2e6c6b54183c97c3f4bd360e95d1a54c74","modified":1681718060189},{"_id":"public/article_img/2022-05-30-19-03-35.png","hash":"c2e866178cf983d0cfe1aa038425472f7acee240","modified":1681718060189},{"_id":"public/article_img/2022-05-31-14-18-58.png","hash":"b9a7139c5bdaf6e5db16b7a8413b1e3ab23630d7","modified":1681718060189},{"_id":"public/article_img/2022-05-31-15-48-55.png","hash":"4d46759e0cd502639178910c9e95c54e314ea5ff","modified":1681718060189},{"_id":"public/article_img/2022-05-31-16-12-25.png","hash":"ec74d41977cf0abf5056caded9aa9b88af62966f","modified":1681718060189},{"_id":"public/article_img/2022-05-31-16-12-50.png","hash":"bd2b8343d8e913d4db216cc10056448eb57b4529","modified":1681718060189},{"_id":"public/article_img/2022-06-20-14-08-41.png","hash":"05002bb28f4ab5ee54f1189ffe22ddf65910b496","modified":1681718060189},{"_id":"public/article_img/2022-06-06-18-35-54.png","hash":"6be1df14e318133e1f7ed4a0a3c84e450a325e43","modified":1681718060189},{"_id":"public/article_img/2022-06-20-14-41-24.png","hash":"7eaa2f3d1b0684816e1acc6475460ce5758bc2a1","modified":1681718060189},{"_id":"public/article_img/2022-08-01-18-08-53.png","hash":"31279d78550f5e21ceb0e570e45891ffe7af5813","modified":1681718060189},{"_id":"public/article_img/2022-08-01-18-03-38.png","hash":"050155e074d15b444c7b8a9776c6dc241afd0319","modified":1681718060189},{"_id":"public/article_img/2022-08-01-18-15-35.png","hash":"959c7a4f960cfe8a8a87d5bfb9c9c932b62a9b27","modified":1681718060189},{"_id":"public/article_img/2022-08-03-17-35-43.png","hash":"cef751918702699d6d9409a6c2343f5c797a2445","modified":1681718060189},{"_id":"public/article_img/2022-08-10-16-12-45.png","hash":"750ffcd40592edc266a2a21eb7c1df5f049edce3","modified":1681718060189},{"_id":"public/article_img/2022-08-26-15-12-11.png","hash":"1d51afba2ce825e15dacc7766a2cd9b81a6dcf98","modified":1681718060189},{"_id":"public/article_img/2022-08-26-15-16-08.png","hash":"607891053a8057c948fe8f423af1741b7c72af72","modified":1681718060189},{"_id":"public/article_img/2022-08-27-09-10-34.png","hash":"7dbdeabde67d50f5be466e18fca466d25a051376","modified":1681718060189},{"_id":"public/article_img/2022-08-27-09-14-04.png","hash":"3251eda86b675721cf92a679ac1c6b96ef20b216","modified":1681718060189},{"_id":"public/article_img/2022-08-27-09-15-15.png","hash":"e9343bef545e889fba609e1608be329e0caff760","modified":1681718060189},{"_id":"public/article_img/2022-08-29-15-42-40.png","hash":"d3266a537705a5c009307e9942d3fb3698927358","modified":1681718060189},{"_id":"public/article_img/2022-08-29-16-17-54.png","hash":"2746f1fa918980a06cd359a91101671d9e0bea3e","modified":1681718060189},{"_id":"public/article_img/2022-08-29-16-24-47.png","hash":"b165b5fe2290faad8ae8bf4b7f0c88084d3a76d2","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-44-02.png","hash":"611e6d0aacac0e2136e0ba7031592c9ecf7120e0","modified":1681718060189},{"_id":"public/article_img/2022-09-27-11-50-26.png","hash":"b52d456aa359accf5bd2894e07bb9e923384a906","modified":1681718060189},{"_id":"public/article_img/2022-09-28-16-15-11.png","hash":"5669b36a5224debf2a1947362153b7797911643f","modified":1681718060189},{"_id":"public/article_img/2022-09-29-15-45-06.png","hash":"9e4e41ea63cab044dc495cf95010a7a0ff995128","modified":1681718060189},{"_id":"public/article_img/2022-09-29-15-45-33.png","hash":"e72d675daff15c3dcd71b82034b6f92d2171e4be","modified":1681718060189},{"_id":"public/article_img/2022-09-29-15-52-40.png","hash":"396bbefad1974c6b136a564a713525a4483a35aa","modified":1681718060189},{"_id":"public/article_img/2022-09-30-14-48-32.png","hash":"680dfc7afb1390028ba9dd283b1f5c26e54e3404","modified":1681718060189},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1681718060189},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1681718060189},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1681718060189},{"_id":"public/js/color-schema.js","hash":"781e5c82556f279f99c97ffd13f359bd1a445145","modified":1681718060189},{"_id":"public/js/boot.js","hash":"6b7319b36ca2e2d3afe336623ef438994f3d26de","modified":1681718060189},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1681718060189},{"_id":"public/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1681718060189},{"_id":"public/js/leancloud.js","hash":"ed23208de670d7a5900f2669cc715e2479885958","modified":1681718060189},{"_id":"public/js/plugins.js","hash":"b4ca98f68bf09a74678932e4ac73ac56a7c01e03","modified":1681718060189},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1681718060189},{"_id":"public/js/utils.js","hash":"d49d462f8547de07ca49e1ea195dff864b08706b","modified":1681718060189},{"_id":"public/css/main.css","hash":"c7bff703a51103b8cfcef9deec8d041001c9c599","modified":1681718060189},{"_id":"public/article_img/2022-10-08-14-55-02.png","hash":"c42df55757047401594f46f58fb3f02fcdbb0dec","modified":1681718060189},{"_id":"public/article_img/2022-10-09-14-52-21.png","hash":"532415bdce5970d5a862edd9f1db8ae459b965c4","modified":1681718060189},{"_id":"public/article_img/2022-10-11-18-10-27.png","hash":"73eeeabc10aa597437ca2572c30d9e4fce1b9d71","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-34-50.png","hash":"c97f81f8633de9a20be12a1977ca55e8e6d5b864","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-46-03.png","hash":"3fb738d2a064dd910c0914853d87fd472194cf4a","modified":1681718060189},{"_id":"public/article_img/2022-10-12-12-51-23.png","hash":"70da84a9c83747d6117c6a6e414e97eed115529e","modified":1681718060189},{"_id":"public/article_img/2022-10-12-13-03-11.png","hash":"0792eb4591aa01adf92a83fb5bf8e86e709ad759","modified":1681718060189},{"_id":"public/article_img/2022-10-13-14-51-20.png","hash":"f87435455792d652881421db4eced41581d8af9b","modified":1681718060189},{"_id":"public/article_img/2022-10-15-15-38-04.png","hash":"f3850d72b541092ee5591bb9fbc0058fb624c274","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-36-58.png","hash":"80c9fd8bf7c35fabe981854aa7ce09ee6daad8eb","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-36-13.png","hash":"a19547e41fec0bb3565e3129c3653abd5ac80735","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-37-36.png","hash":"3c0d8066675325859322f17fb95bc14ac2f85159","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-25-50.png","hash":"92eebc26516af1929aa045162f4247e5e44956be","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-42-29.png","hash":"a4726012621f46f40f3820af18fae7f255e4a441","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-59-42.png","hash":"af8b7a7f05dc89e531399afb22423450974e6f1d","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-58-49.png","hash":"f43b0d22628f375478605dac5f482e0a12b997a6","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-17-26.png","hash":"7a1d4fa5091def58c5c4aa8a9933e88ac1548d53","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-32-53.png","hash":"6640695e678feeccaf6daec81744d399143fa389","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-32-59.png","hash":"0b0d1240c6c002947aa6a9a907e70af8cc2ea42b","modified":1681718060189},{"_id":"public/article_img/2022-10-27-14-21-46.png","hash":"c73f02f6f2f973145816dfdd949616d2096d2bc5","modified":1681718060189},{"_id":"public/article_img/2022-10-29-12-19-29.png","hash":"cf2b664bcdeb16e395d64efdf0f4f2f7285128c2","modified":1681718060189},{"_id":"public/article_img/2022-11-01-17-15-23.png","hash":"d7c854d5a7a92f8b595af80d9231ae054c53cbad","modified":1681718060189},{"_id":"public/article_img/2022-11-01-17-30-18.png","hash":"e4a0760dc342621e7901f1a416300857fbf14ef4","modified":1681718060189},{"_id":"public/article_img/2022-11-01-16-58-12.png","hash":"56109401dbd7081b6f20c1fd41bd3c5dde07a182","modified":1681718060189},{"_id":"public/article_img/2022-11-01-19-10-25.png","hash":"06e3c69c66a5cd6c4940b0d6c667ed1ac2d4410d","modified":1681718060189},{"_id":"public/article_img/2022-11-01-19-04-15.png","hash":"1362961b315907f0a04935c109969a08494c8f0c","modified":1681718060189},{"_id":"public/article_img/2022-11-10-16-24-26.png","hash":"73f60bca62a9abaf280dc9a95288ad9005991744","modified":1681718060189},{"_id":"public/article_img/2022-11-21-14-09-38.png","hash":"4be4f3c44f3f6f9b24e97b3adea7ba6754e5249e","modified":1681718060189},{"_id":"public/article_img/2022-11-21-14-31-23.png","hash":"5c3b1eb11af2bdc729d60099162e4483bcaae323","modified":1681718060189},{"_id":"public/article_img/2023-01-29-19-14-03.png","hash":"d3266a537705a5c009307e9942d3fb3698927358","modified":1681718060189},{"_id":"public/article_img/2023-01-29-19-36-25.png","hash":"3a13dc3c1e0da45b1b8ac66ee950b9b77424ea3a","modified":1681718060189},{"_id":"public/article_img/2023-01-29-20-04-48.png","hash":"231ac4958f3840da4a8198b868563b57e68817b0","modified":1681718060189},{"_id":"public/article_img/2023-01-30-13-46-43.png","hash":"4c5a9c652ac4d5085c7b382797231fdb6fecd009","modified":1681718060189},{"_id":"public/article_img/2023-03-18-18-55-07.png","hash":"a903910d7683d3169bc82d5a798790b5b9bb7e71","modified":1681718060189},{"_id":"public/article_img/2023-03-18-18-56-36.png","hash":"00082c13c382f1fa00f74e7752f77d35ae09e6b2","modified":1681718060189},{"_id":"public/article_img/2023-03-18-19-00-23.png","hash":"c8f4db87f5677297f56cd2c2f47ef9265d8a924a","modified":1681718060189},{"_id":"public/article_img/2023-03-18-19-05-21.png","hash":"f46de393393d03ee5741869f2215fcfe8abc89a8","modified":1681718060189},{"_id":"public/article_img/2023-03-22-12-13-16.png","hash":"150e9b8082668fdaed3c1cf25ec30e69d0e4d1df","modified":1681718060189},{"_id":"public/article_img/2023-03-25-14-47-55.png","hash":"af8384fc3346ce177a87887ce54ba74f8886a05f","modified":1681718060189},{"_id":"public/article_img/2023-03-25-15-24-46.png","hash":"5d6a98400341540888f7d14d8adcb6988604db84","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-17-25.png","hash":"1924f3fc8f250f5007071255786b76168976ef71","modified":1681718060189},{"_id":"public/article_img/2023-03-26-14-42-38.png","hash":"9721e974d81aaf7a36d03e7a585a6a9bd38edd3a","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-38-26.png","hash":"9aabeae9c563feaf2077f0249c62fd280d08cb17","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-38-35.png","hash":"db8b9ccd5db4109840e12854b13220c7021dcb75","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-38-40.png","hash":"0e0c29c8bef3304b54fc9e990ffda44bfdf88545","modified":1681718060189},{"_id":"public/article_img/2023-03-26-16-10-17.png","hash":"8acc9ada6403f8a121ef7b3b1c22459cd3ea9318","modified":1681718060189},{"_id":"public/article_img/2023-03-26-16-15-40.png","hash":"208f683578f8552c5fd7a3520c195f5ddc7092bc","modified":1681718060189},{"_id":"public/article_img/2023-03-26-18-50-00.png","hash":"d492e3ebe8f8c1dc3f25d05e9cccc6b3d349a226","modified":1681718060189},{"_id":"public/article_img/2023-03-26-19-22-16.png","hash":"fbf0166f58559dd645b68d27ca2b75557d27fc5b","modified":1681718060189},{"_id":"public/article_img/2023-03-26-19-18-48.png","hash":"ed939f88f4ff0a473cce0aae6b7966e558700d36","modified":1681718060189},{"_id":"public/img/bg/LearnedMM.png","hash":"af8384fc3346ce177a87887ce54ba74f8886a05f","modified":1681718060189},{"_id":"public/img/bg/P5R.jpg","hash":"1fbd4481f16dd964aa4d01bebbbb8464e1fe0901","modified":1681718060189},{"_id":"public/img/bg/PBDR.png","hash":"2485b0b4cd688f88afeb0b75421f591028db1cd5","modified":1681718060189},{"_id":"public/img/bg/West4.jpg","hash":"5c2f03d61e3a4810325cd8bce66bf28883827643","modified":1681718060189},{"_id":"public/img/bg/bg.png","hash":"a39d439a556f47f159ceba84b787483ff5a3acd6","modified":1681718060189},{"_id":"public/img/bg/kite.webp","hash":"62a2ba05b4e1587d2d28d90a025357b3c1c8d0fa","modified":1681718060189},{"_id":"public/article_img/![](/article_img/2022-08-01-18-03-38.png).png","hash":"31279d78550f5e21ceb0e570e45891ffe7af5813","modified":1681718060189},{"_id":"public/article_img/2022-05-30-18-51-12.png","hash":"6dd9180e8b0d94c5bdc47cef6507fdd363dd2929","modified":1681718060189},{"_id":"public/article_img/2022-08-03-10-12-36.png","hash":"1390648b57ee3191a722d6f071dcbbad7e11b138","modified":1681718060189},{"_id":"public/article_img/2022-08-26-15-10-45.png","hash":"cc517c1d612fa14cb6a0e2fdef88da8a60533d9c","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-33-36.png","hash":"18eac1b77d92b9e0a436f5df8259687e6387bc58","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-35-15.png","hash":"8823027f417f83897385827bced2be78f4e9f0ce","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-41-41.png","hash":"8e85c51872fbc7eb8470a1e7c404e8a89b046a72","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-54-29.png","hash":"860478dbd9a6d8849842f2ac2c9e52f4ef24da9f","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-54-37.png","hash":"23cc10537308a6265d1868709ec88cdeef9542ad","modified":1681718060189},{"_id":"public/article_img/2022-10-08-14-54-52.png","hash":"8d4719a0b3f809d85c0f38541bae31ec236dc790","modified":1681718060189},{"_id":"public/article_img/2022-10-09-14-51-30.png","hash":"3076d7ed0edbf09917f119fb0f6d766eb3339bcb","modified":1681718060189},{"_id":"public/article_img/2022-10-09-14-25-53.png","hash":"aa5b41daf062326a094109ec6c1a0239da3e0bc6","modified":1681718060189},{"_id":"public/article_img/2022-10-09-15-26-37.png","hash":"c89b53f06b600c3ae6d2384b5b61bf0b0051431f","modified":1681718060189},{"_id":"public/article_img/2022-10-09-14-51-38.png","hash":"dc72ab3a282903eea97ce49022b05192bf53fd6e","modified":1681718060189},{"_id":"public/article_img/2022-10-20-11-13-35.png","hash":"154f004ecb6289077f57450b65bb4b4ca040f137","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-19-42.png","hash":"57e8c77e9412597d4d1ef2430bb6c34a0d6d2fb7","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-20-18.png","hash":"c8700f82cb042f5153f08a795ff18729cf3fe3e9","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-35-10.png","hash":"2ce8a97c47a75aa90bc26e375e5cdc43e7d04e39","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-05-34.png","hash":"db03507be981f8cb4ab63a9d5f5d506802668b09","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-06-05.png","hash":"8b1d0015ae1f2d517c1c4812139dc5cc8ab59417","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-22-42.png","hash":"43e69e8dd6270c9dace39c8d0860af9869bfae89","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-23-45.png","hash":"f51a720b810017b7c7bfa279953b49968eb20674","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-27-38.png","hash":"9de6d452c35eb0ffb555853fce6483b94add06df","modified":1681718060189},{"_id":"public/article_img/2022-10-29-13-41-49.png","hash":"9619c1c0349f37166082afb309167f50926bc98e","modified":1681718060189},{"_id":"public/article_img/2022-10-29-12-58-05.png","hash":"7ecc01dd5dccad39aa5b0a853acfbfea179c0465","modified":1681718060189},{"_id":"public/article_img/2022-11-01-17-17-08.png","hash":"436bab29920629180d77d8a4e2202ded25fb0bb8","modified":1681718060189},{"_id":"public/article_img/2022-11-01-19-40-30.png","hash":"87e001c0f440171bb472c4f793ea4d08ea789aa6","modified":1681718060189},{"_id":"public/article_img/2022-11-02-15-34-54.png","hash":"9478f14941394c37163aa4175e0aabfd5b75948d","modified":1681718060189},{"_id":"public/article_img/2022-11-18-12-16-39.png","hash":"25c2a3d4345dbb5d536c40ab432ee89f14291087","modified":1681718060189},{"_id":"public/article_img/2022-11-18-13-34-06.png","hash":"5cab00a06edc7bcdfe5097b207d88528eddcfb35","modified":1681718060189},{"_id":"public/article_img/2022-11-18-13-34-17.png","hash":"5cab00a06edc7bcdfe5097b207d88528eddcfb35","modified":1681718060189},{"_id":"public/article_img/2022-11-19-14-23-51.png","hash":"b28b3619fc6f605879cc594aa8582bacdcca7f8b","modified":1681718060189},{"_id":"public/article_img/2022-11-21-15-13-44.png","hash":"96b65fee1be1d1a929ef4ef3f6cafabd1a9c12cf","modified":1681718060189},{"_id":"public/article_img/2023-01-29-18-19-47.png","hash":"027b85191df7d76cc0b33a1fe713dcf63155b1e8","modified":1681718060189},{"_id":"public/article_img/2023-01-29-19-24-00.png","hash":"2336498d53fe3504cab672f580912efcf309b0dc","modified":1681718060189},{"_id":"public/article_img/2023-03-18-19-08-12.png","hash":"426e590064d48037afed57df00e984e5dfd618a0","modified":1681718060189},{"_id":"public/article_img/2023-03-26-14-43-26.png","hash":"257aa96e3983626e2ffd8e6121f38f274d69a032","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-19-55.png","hash":"8886dd9119879c42f834a08b818a536f9c3388b9","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-28-33.png","hash":"22da9ece6c0255f4b9506ee4eb98f8fcf53852f0","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-36-18.png","hash":"97fa1bbd64718054a7206333b49dcba4c7711e53","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-43-07.png","hash":"199381321daf2b1bed3389a893dfa06bebaa1af3","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-43-27.png","hash":"a952327bb7a9414beb58cd92d384ee2e268318d9","modified":1681718060189},{"_id":"public/article_img/2023-03-26-16-07-46.png","hash":"baf49b21c329bf5c64792acea1fa3d3daaca2050","modified":1681718060189},{"_id":"public/article_img/2023-03-26-16-13-26.png","hash":"4165f55d70262177f7cb17451d8a032b4ec563ea","modified":1681718060189},{"_id":"public/article_img/2023-03-26-16-15-31.png","hash":"6b5e356f31742c7b953c9b56ba58beab256a8324","modified":1681718060189},{"_id":"public/img/bg/3DSlicerLogo.png","hash":"e3c9443753142fb1c89977c8ef152438d125172b","modified":1681718060189},{"_id":"public/img/bg/games105.jpg","hash":"ec2d053b480473aeeeac2cf161182d153a1eb955","modified":1681718060189},{"_id":"public/article_img/2022-08-27-09-21-26.png","hash":"1f3483ec957b8d68058293c9f9c1762a23f9c6b8","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-53-37.png","hash":"e57e1850a17bdd378560796e22f17ac781119ab4","modified":1681718060189},{"_id":"public/article_img/2022-08-29-18-56-35.png","hash":"841f1f903c7832621eaa19839b851fcff394aa7d","modified":1681718060189},{"_id":"public/article_img/2022-08-29-19-04-50.png","hash":"f4429372706e83980b2e5e5297215ec87087c47d","modified":1681718060189},{"_id":"public/article_img/2022-09-26-21-08-46.png","hash":"13898ce64db5eace1f6cb933416352503cb839fc","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-26-47.png","hash":"6d394b2beea10805d3815cbfc8c1d44df13d0c09","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-27-57.png","hash":"7589b8da377118f80446486bb57198996c127884","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-27-00.png","hash":"972bacc43bc7179a55db725ce59413a9fb7af563","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-08-44.png","hash":"a00bb8eb2e0205dbe8f289bc08924e06a8496e9e","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-51-07.png","hash":"e1bd39459d51e349c78b5aff8b34894b08a4dbb3","modified":1681718060189},{"_id":"public/article_img/2022-10-22-14-57-34.png","hash":"976b7c68647b015ee3680924046ba5a358cd2c98","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-03-45.png","hash":"1d1b8f8381a4e700f4b498a36462f0d81676abb7","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-26-34.png","hash":"130e8bd2afd761d711718706b44ac14e4bdd9d83","modified":1681718060189},{"_id":"public/article_img/2022-10-29-13-46-16.png","hash":"1960f3d8b78ada9d5a160a37d9ba19f81d89a490","modified":1681718060189},{"_id":"public/article_img/2022-10-29-13-50-48.png","hash":"eb498eb79a5cf48f709f4943816a97ed9de7fcda","modified":1681718060189},{"_id":"public/article_img/2022-10-29-13-50-58.png","hash":"3c46be248f611175e181361b2052450683d76f69","modified":1681718060189},{"_id":"public/article_img/2022-10-29-13-55-20.png","hash":"291e7cd4c7e6b895bfc5002de2d4f18eaa677e57","modified":1681718060189},{"_id":"public/article_img/2022-11-01-19-40-57.png","hash":"446e2eb550febd0d688ecc44fcc96ce63a5e3f08","modified":1681718060189},{"_id":"public/article_img/2022-11-02-15-31-22.png","hash":"da46723565706dd123ac7d9724a3d1586dd2aa6e","modified":1681718060189},{"_id":"public/article_img/2022-11-18-13-09-41.png","hash":"d8006e451b1a75b8ac692890c036d34bb43f2a21","modified":1681718060189},{"_id":"public/article_img/2022-11-21-18-56-51.png","hash":"891c839c7566616186421006130c295d755b5f2f","modified":1681718060189},{"_id":"public/article_img/2022-11-21-18-50-48.png","hash":"d502774da8bd471aedb936b5b88d04d5186bf620","modified":1681718060189},{"_id":"public/article_img/2023-01-29-17-57-41.png","hash":"d04c2763a5bb43e70692891b809d162000caaba8","modified":1681718060189},{"_id":"public/article_img/2023-01-30-15-47-25.png","hash":"6c62bb3117ad9ea3a31e02530ef0408c56ced04c","modified":1681718060189},{"_id":"public/article_img/2023-03-17-15-28-09.png","hash":"e424acef74bc0fd1a23fe7b692ec0cc419a6c7c6","modified":1681718060189},{"_id":"public/article_img/2023-03-17-15-39-57.png","hash":"2f0bdc04268a2b975c916c241b7c8a681377cbc0","modified":1681718060189},{"_id":"public/article_img/2023-03-17-16-13-42.png","hash":"f88c83c88962dbbefdb9fb9d9e5054e4ce26e81b","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-42-58.png","hash":"e62c35b755abacd2fb5bb16c04c9e35641e88939","modified":1681718060189},{"_id":"public/article_img/2023-03-26-16-13-32.png","hash":"57c8d4677b7be646696edca76a9310a527f3636e","modified":1681718060189},{"_id":"public/article_img/Opt_color.png","hash":"8d1d6ce6ab3dd0fba97dfa3621c10c2ea4a02e0b","modified":1681718060189},{"_id":"public/img/bg/nanjing.jpeg","hash":"bbe4d2dc4d9fad68a0ea7bacec1d07427ac2543f","modified":1681718060189},{"_id":"public/article_img/2022-08-27-09-09-18.png","hash":"c242cea22d7970c81097fbe17920d00c398da22f","modified":1681718060189},{"_id":"public/article_img/2022-08-27-09-21-42.png","hash":"041dcca2876358c735fb8b216a7bae633b752824","modified":1681718060189},{"_id":"public/article_img/2022-09-26-14-26-50.png","hash":"d64646f9ddfa34cc25285e4fdbd4514bfee4e8a8","modified":1681718060189},{"_id":"public/article_img/2022-09-29-15-45-22.png","hash":"d381775c6b2de476b083a85a8a2260e069b15d85","modified":1681718060189},{"_id":"public/article_img/2022-10-20-11-13-23.png","hash":"3cdcd8918086cbd993d506e1bca77f6a9d21e626","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-48-13.png","hash":"8c8a0e29d8f8f8eb8cea1e5169d349d1ea3162ed","modified":1681718060189},{"_id":"public/article_img/2022-10-20-11-16-05.png","hash":"441ef891c39b75274c67e081498363e039bf692f","modified":1681718060189},{"_id":"public/article_img/2022-10-22-15-06-25.png","hash":"ce465513a45a258ae7183bda4756954eb2eedeb0","modified":1681718060189},{"_id":"public/article_img/2022-10-29-13-44-32.png","hash":"7f6fee8368afa14dc0d764d25cbc89e6256c010f","modified":1681718060189},{"_id":"public/article_img/2022-10-29-13-55-07.png","hash":"790f8571202201a3c9b3ddeed485eca82025c82c","modified":1681718060189},{"_id":"public/article_img/2022-10-29-14-51-40.png","hash":"58dbb27d734b9aac0bbf35d52de418b119d78b9e","modified":1681718060189},{"_id":"public/article_img/2022-11-02-15-36-15.png","hash":"82b98c8cd108c4689740697dc0dc3932aa0bcf35","modified":1681718060189},{"_id":"public/article_img/2022-11-14-15-19-54.png","hash":"90b07a1957270224d736014d4756a53951c799fc","modified":1681718060189},{"_id":"public/article_img/2022-11-21-18-43-13.png","hash":"a941456976979b4fe2c6cb47d042bbfe27168c58","modified":1681718060189},{"_id":"public/article_img/2023-03-17-15-21-58.png","hash":"0ce8891a09f721f1a2e239b830b19c555890f91d","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-38-16.png","hash":"d361dea0206fb2da4cbef81b0e0b52903f66ac02","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-48-40.png","hash":"0c3c2e7e3c566fa6e0d36348095dee61aba3a50e","modified":1681718060189},{"_id":"public/article_img/Opt_pose.png","hash":"807c6122492ca123c34b4e5810f1e42499f2fa6e","modified":1681718060189},{"_id":"public/img/bg/West2.jpg","hash":"cb02a7cc32956aad55ea4085e642a1791ee1ef60","modified":1681718060189},{"_id":"public/img/bg/RayTracing_weekend.jpg","hash":"db554a58efaf190332b815c2001fc725d5b0aa29","modified":1681718060189},{"_id":"public/article_img/2022-08-29-16-32-11.png","hash":"bd7d8ecbb8fbbafee35f638f784835e5dd53f355","modified":1681718060189},{"_id":"public/article_img/2022-10-19-14-13-14.png","hash":"fcbbef45971cc4607e2aff6a8b73484b4a6567f9","modified":1681718060189},{"_id":"public/article_img/QQ图片20220803200133.jpg","hash":"b1fc9181f0fa07b6bd0a1eb22cbf72bcb186a58b","modified":1681718060189},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1681718060189},{"_id":"public/article_img/2022-06-20-18-11-02.png","hash":"4a33b51b7f2449e3207fd76f61e33c53ed3bbc3a","modified":1681718060189},{"_id":"public/article_img/2022-08-29-16-32-22.png","hash":"835af9b9ff7ae4686a7e956ab241036744852ce6","modified":1681718060189},{"_id":"public/article_img/2023-01-29-20-58-10.png","hash":"7f82778142b3c0ec5452537eff6efe57f8f17ce2","modified":1681718060189},{"_id":"public/article_img/2023-03-26-15-41-54.png","hash":"33cfd0c1cd0ec8b90be5af8bbeff74f39753b8ee","modified":1681718060189},{"_id":"public/article_img/2022-06-20-18-05-00.png","hash":"4d688a0d63c116c78024d1f202fe76068787bafb","modified":1681718060189},{"_id":"public/article_img/2022-08-29-19-00-52.png","hash":"8b8076195c9793d3bd7ab36fa28b06450c37d090","modified":1681718060189},{"_id":"public/article_img/2023-01-29-18-24-21.png","hash":"1e9b8d40aa28d7c325f386b84a6cc23825a39dad","modified":1681718060189},{"_id":"public/article_img/2023-03-26-16-08-09.png","hash":"e206537d742a623138e0b2d5354d4219fce2918b","modified":1681718060189},{"_id":"public/article_img/2023-03-26-18-32-27.png","hash":"9cf282f9644dc8c9452a387f371e97eeeaf619dd","modified":1681718060189},{"_id":"public/article_img/2023-03-29-14-23-17.png","hash":"ae604f6d4f526a36a8609acc39270687c6a13afc","modified":1681718060189},{"_id":"public/img/bg/cg_bg.png","hash":"313e52b451a968a2fd8b3aba460727c8e0e44a4f","modified":1681718060189},{"_id":"public/article_img/2022-11-10-16-34-14.png","hash":"f9855ab59a93eae2fc13ddca1b2bae1b693365b0","modified":1681718060189},{"_id":"public/article_img/2023-03-29-13-43-09.png","hash":"36fe062d9e29efe0c6a59f857665c78cfb359702","modified":1681718060189},{"_id":"public/article_img/2022-10-29-18-20-06.png","hash":"ff7b4e059f8e03e36270a33f3833a8170bb40bac","modified":1681718060189},{"_id":"public/article_img/2022-11-15-16-01-34.png","hash":"ad1b03c09066824ed1c084479ebbd063246aaa45","modified":1681718060189},{"_id":"public/article_img/2023-01-29-17-32-38.png","hash":"2f85f45b3db23658c0c3cd11d87b7196af35c0b2","modified":1681718060189},{"_id":"public/article_img/2023-01-29-17-32-40.png","hash":"2f85f45b3db23658c0c3cd11d87b7196af35c0b2","modified":1681718060189},{"_id":"public/article_img/2023-01-30-13-57-25.png","hash":"711d21f1e6ed93a73202a859e64df8cf957eacb2","modified":1681718060189},{"_id":"public/article_img/2023-01-29-17-47-19.png","hash":"5082028205cd9b4babbd02db555f4b6ae8fbd4c1","modified":1681718060189},{"_id":"public/img/bg/PBDR_Cover.png","hash":"b2b75b4600da606038bb6ee431f67962ed714b8e","modified":1681718060189},{"_id":"public/article_img/2022-11-15-16-04-20.png","hash":"7c339adc1a5bd48b81dd93c01a58a5890d5237f5","modified":1681718060189},{"_id":"public/article_img/2023-01-29-17-48-34.png","hash":"e02afed0273453fd6625896036184c8fb7d140ec","modified":1681718060189},{"_id":"public/img/bg/Motion_Matching.png","hash":"f3fe812c1c9ea33e6182c06317cf9f6467e3da80","modified":1681718060189},{"_id":"public/article_img/2023-01-29-17-48-09.png","hash":"bf184fca3bb2c71da519eb969a34b69cd33906bf","modified":1681718060189},{"_id":"public/article_img/2022-11-12-15-18-18.png","hash":"de6b5baf97b2ef9d6411b688ec8a51ed3790966f","modified":1681718060189},{"_id":"public/article_img/2023-01-29-17-49-24.png","hash":"ade3a654f94121b279a5dfb1b2472c285251dcc5","modified":1681718060189},{"_id":"public/article_img/2023-01-29-19-17-23.png","hash":"dcb098ec77cd2a3fdee836f3a9c324d79da59548","modified":1681718060189},{"_id":"public/img/bg/asoul.jpg","hash":"3187fcfb754e535dc08d38874c497c6d5a4b0cb6","modified":1681718060189},{"_id":"public/article_img/2023-03-14-15-48-56.png","hash":"aba1ae48a03239a1483e2ca9a7929fe226735f82","modified":1681718060189},{"_id":"public/article_img/2023-03-29-13-26-38.png","hash":"3539d5d876e1c245ec48f9db7f526c7cd2294fbd","modified":1681718060189},{"_id":"public/article_img/2022-10-27-14-53-37.png","hash":"5e48814c5018b291b1aae15adec2f717bcd840ce","modified":1681718060189},{"_id":"public/article_img/2022-11-02-15-10-07.png","hash":"a868cc4947141b3004b91d2794f689bd1e012631","modified":1681718060189},{"_id":"public/article_img/2022-10-27-14-53-13.png","hash":"a41d1dbf3ebb98fcb8dd8c85edd7552f5e5e279f","modified":1681718060189},{"_id":"public/img/bg/Pink_city.png","hash":"5ea089d73c4f3fbe1c2af7e481a0c84606595572","modified":1681718060189},{"_id":"public/article_img/CompDecompWithExtraFeatures.gif","hash":"a2d6f84e43f5b29b720244bb9b7b47ccbc94f607","modified":1681718060189},{"_id":"public/article_img/LMM_L.gif","hash":"e6f2abac787d2a3a269fbca63b246aab098a61d7","modified":1681718060189},{"_id":"public/article_img/LMM_M.gif","hash":"2fe4d99bc6e3f09a659f3375a5a804083b8bb2ca","modified":1681718060189},{"_id":"public/article_img/CompDecomp.gif","hash":"360a8e12bbeec1655d9d61df1eafa91b1cdbf648","modified":1681718060189},{"_id":"public/article_img/mm_1.gif","hash":"daf82d952ee3bc7d11eb74619c9d0ac7de278589","modified":1681718060189},{"_id":"source/_posts/C++Review_How.md","hash":"495a7825803080ec3b20829fc963247883e59ea4","modified":1682063200330},{"_id":"source/article_img/2023-04-19-12-13-27.png","hash":"41915621b9c399c98b1b73997291b3870892e918","modified":1681877607513},{"_id":"source/img/bg/cpp.jpg","hash":"c412a0d3716bf5fe77b57b51d526ac6255623b13","modified":1681875306150},{"_id":"source/article_img/2023-04-19-12-51-20.png","hash":"417dda15903b14828b444db162e829fa05cdbbb3","modified":1681879880432},{"_id":"public/2023/04/17/C++Review_How/index.html","hash":"cca3d49ffcd2c11cce9d6d5994abadf5e4c805ce","modified":1682063572703},{"_id":"public/archives/2023/04/index.html","hash":"4a9d631330bcaf8b4401594cffcdd6ffa6c2bdf4","modified":1681885305978},{"_id":"public/tags/C/index.html","hash":"a9bcaaaeef6573fdd08ef0b4bbe09c8fdcad43dc","modified":1681885305978},{"_id":"public/categories/C/index.html","hash":"e86d8def4b6acd000b0ddfce592707e5d8ac151d","modified":1681885305978},{"_id":"public/img/bg/cpp.jpg","hash":"c412a0d3716bf5fe77b57b51d526ac6255623b13","modified":1681885269957},{"_id":"public/article_img/2023-04-19-12-13-27.png","hash":"41915621b9c399c98b1b73997291b3870892e918","modified":1681885269957},{"_id":"public/article_img/2023-04-19-12-51-20.png","hash":"417dda15903b14828b444db162e829fa05cdbbb3","modified":1681885269957},{"_id":"source/.vscode/settings.json","hash":"2801863299206117e6d1d4ace8bda660512052d2","modified":1681971769720},{"_id":"source/article_img/2023-04-19-16-20-25.png","hash":"cdeaaf55c338e16882677aca7cf2b286a59ab99a","modified":1681892425350},{"_id":"source/article_img/2023-04-21-13-49-02.png","hash":"7a95cdb1beac0bd23ace9def76419506ab827a6e","modified":1682056142830},{"_id":"source/article_img/2023-04-21-13-52-38.png","hash":"8565e8c4e6f987948c0a69f122aaa3a2e1c56741","modified":1682056358354},{"_id":"source/article_img/2023-04-21-14-03-00.png","hash":"30fa992b3fe8eea3d4de7f38beb4fa2240f3a853","modified":1682057042275},{"_id":"source/article_img/2023-04-21-14-35-19.png","hash":"1fe7ae43dc8ba8da583ae4115a2b6caf3cb50bd3","modified":1682058919783},{"_id":"source/article_img/2023-04-21-14-36-18.png","hash":"7c924cdf27948fea9ccd0a4337ca2d3dfcdfecd0","modified":1682058978766},{"_id":"public/article_img/2023-04-19-16-20-25.png","hash":"cdeaaf55c338e16882677aca7cf2b286a59ab99a","modified":1682063572703},{"_id":"public/article_img/2023-04-21-13-49-02.png","hash":"7a95cdb1beac0bd23ace9def76419506ab827a6e","modified":1682063572703},{"_id":"public/article_img/2023-04-21-14-03-00.png","hash":"30fa992b3fe8eea3d4de7f38beb4fa2240f3a853","modified":1682063572703},{"_id":"public/article_img/2023-04-21-13-52-38.png","hash":"8565e8c4e6f987948c0a69f122aaa3a2e1c56741","modified":1682063572703},{"_id":"public/article_img/2023-04-21-14-35-19.png","hash":"1fe7ae43dc8ba8da583ae4115a2b6caf3cb50bd3","modified":1682063572703},{"_id":"public/article_img/2023-04-21-14-36-18.png","hash":"7c924cdf27948fea9ccd0a4337ca2d3dfcdfecd0","modified":1682063572703}],"Category":[{"name":"-[杂谈]","_id":"clgkjiglh0003w0je4je3fdm4"},{"name":"-[3DSlicer]","_id":"clgkjigll0008w0je1f6ihaxu"},{"name":"-[笔记]","_id":"clgkjiglo000ew0jeg1vo1yku"},{"name":"-[Games101笔记]","_id":"clgkjiglv000pw0je6qs64gy0"},{"name":"-[Games105笔记]","_id":"clgkjigm90024w0je3qjrh5if"},{"name":"-[练习]","_id":"clgkjigmb002cw0je4fwc4ydq"},{"name":"-[Ray Tracing 笔记]","_id":"clgkjigmc002gw0jeflyl17wl"},{"name":"-游戏Demo","_id":"clgkjigmc002lw0jefad492z7"},{"name":"-[OpenGL笔记]","_id":"clgkjigmd002ow0je85ku3yk4"},{"name":"-[动画TA]","_id":"clgkjigmi003nw0je9q1m1hik"},{"name":"-[C++]","_id":"clgnb2che0001woje0441holu"}],"Data":[],"Page":[{"title":"about","layout":"about","date":"2022-04-06T07:36:41.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\nlayout: about\ndate: 2022-04-06 15:36:41\n---\n","updated":"2022-09-24T10:43:41.800Z","path":"about/index.html","comments":1,"_id":"clgkjiglb0000w0jeblxv1zcm","content":"","site":{"data":{}},"wordcount":0,"excerpt":"","more":""}],"Post":[{"title":"2022年4月25日讨论","date":"2022-04-26T08:00:43.000Z","hide":true,"_content":"\n杂谈\n<!-- more -->\n\n# 2022年4月25日讨论\n## 意识形态为政治行动而服务\n 引：[【bilibili】欧盟不只是弱鸡——傅正](https://www.bilibili.com/video/BV1PL4y1V7Nw?spm_id_from=333.880.my_history.page.click)\n\n论点：**不论是自由主义，民族主义亦或是共产主义的意识形态，其本质都是工具，为了达成某种政治目的，要时刻把握意识形态是工具不是目的**。这和温铁军强调的思考问题应该去意识形态化的观点不谋而合。\n\n美国作为民主自由最大的代言人，依旧可以为了自身利益扶植南美独裁国家，依旧可以与沙特君主制国家联盟，依旧可以放弃自由贸易为本国产业铲除国外竞争对手；同样，代表无产阶级的苏联也可以为了苏联利益放弃农民利益大搞工农剪刀差，也可以强调奉献暂时放弃提高工人生活水平，也可以实行存在市场的新经济政策。国家是多个利益集团交织在一起的复杂的利益体，国家的政策往往是多个利益集团之间互相妥协的产物。\n\n因此，此前的一些观点是不够成熟的。比如不能因为共产主义和自由主义这种解构民族主义的意识形态的出现就判民族主义死刑，阶级是客观存在的，民族也是客观存在的。**所谓民族主义和自由主义，都只是用来最大化团结本国人民的工具**。美国选择自由主义，是因为在没有民族认同的新大陆，自由主义是最能团结美国人民的意识形态。自由主义当然是有代价的，由于强调公民自由，控制新冠成为天方夜谭，国内治安问题无法解决；同时，不能光明正大的干涉别国经济和内政，不能侵犯他国人权（表面上），否则会激起国内人民反对。同理，中华民族伟大复兴带有的民族主义色彩也是因为这是最能团结中国人民的意识形态，其同样也会有代价。虽然有这些代价的存在，但美国当权者依旧需要自由主义，中国依旧需要民族主义，这就是意识形态的威力，它们诞生是为政治服务，但一旦其开始为政治服务，国家的政策必然会出现意识形态惯性。\n\n这样看，许多问题其实根本就是伪命题，国家因为其代表的过于复杂的利益纠葛，导致甚至有时候看起来有一种为了存在而存在的意味。这都是很正常的，不必时时刻刻用意识形态来约束国家的行为，意识形态是被发明的，不是世界上本就存在的绝对真理。因此，讨论国家修不修本身就是伪命题，没有任何一个国家能做到像意识形态描述的那样单纯，因为其背后的利益集团本就是不单纯的，**不必把国家抽象化，拟人化和神话**，单纯的认为美国就是自由民主的，苏联就是为了无产阶级的，这种单纯的想法会导致看到这些国家的政策不符合其倡导的意识形态的时候，就感到受到欺骗，感到这些国家背离初心，不再是那个民主灯塔或者不再是那个苏维埃，其实他们本就不是。一个国家永远不会像其自我介绍的那样伟大。\n\n诚然，意识形态十分具有吸引力，听起来伟光正，让人热血沸腾，某种程度上意识形态确实是代表了人类的崇高理想，其被创造出来的初衷可能确实不是为政治服务，但幼稚的相信某些国家就完全代表了某些意识形态，将意识形态的成功与否与该国家绑定，这是不合理的。","source":"_posts/20220425讨论.md","raw":"---\ntitle: 2022年4月25日讨论\ndate: 2022-04-26 16:00:43\ntags: [意识形态]\nhide: true\ncategories: \n   -[杂谈]\n---\n\n杂谈\n<!-- more -->\n\n# 2022年4月25日讨论\n## 意识形态为政治行动而服务\n 引：[【bilibili】欧盟不只是弱鸡——傅正](https://www.bilibili.com/video/BV1PL4y1V7Nw?spm_id_from=333.880.my_history.page.click)\n\n论点：**不论是自由主义，民族主义亦或是共产主义的意识形态，其本质都是工具，为了达成某种政治目的，要时刻把握意识形态是工具不是目的**。这和温铁军强调的思考问题应该去意识形态化的观点不谋而合。\n\n美国作为民主自由最大的代言人，依旧可以为了自身利益扶植南美独裁国家，依旧可以与沙特君主制国家联盟，依旧可以放弃自由贸易为本国产业铲除国外竞争对手；同样，代表无产阶级的苏联也可以为了苏联利益放弃农民利益大搞工农剪刀差，也可以强调奉献暂时放弃提高工人生活水平，也可以实行存在市场的新经济政策。国家是多个利益集团交织在一起的复杂的利益体，国家的政策往往是多个利益集团之间互相妥协的产物。\n\n因此，此前的一些观点是不够成熟的。比如不能因为共产主义和自由主义这种解构民族主义的意识形态的出现就判民族主义死刑，阶级是客观存在的，民族也是客观存在的。**所谓民族主义和自由主义，都只是用来最大化团结本国人民的工具**。美国选择自由主义，是因为在没有民族认同的新大陆，自由主义是最能团结美国人民的意识形态。自由主义当然是有代价的，由于强调公民自由，控制新冠成为天方夜谭，国内治安问题无法解决；同时，不能光明正大的干涉别国经济和内政，不能侵犯他国人权（表面上），否则会激起国内人民反对。同理，中华民族伟大复兴带有的民族主义色彩也是因为这是最能团结中国人民的意识形态，其同样也会有代价。虽然有这些代价的存在，但美国当权者依旧需要自由主义，中国依旧需要民族主义，这就是意识形态的威力，它们诞生是为政治服务，但一旦其开始为政治服务，国家的政策必然会出现意识形态惯性。\n\n这样看，许多问题其实根本就是伪命题，国家因为其代表的过于复杂的利益纠葛，导致甚至有时候看起来有一种为了存在而存在的意味。这都是很正常的，不必时时刻刻用意识形态来约束国家的行为，意识形态是被发明的，不是世界上本就存在的绝对真理。因此，讨论国家修不修本身就是伪命题，没有任何一个国家能做到像意识形态描述的那样单纯，因为其背后的利益集团本就是不单纯的，**不必把国家抽象化，拟人化和神话**，单纯的认为美国就是自由民主的，苏联就是为了无产阶级的，这种单纯的想法会导致看到这些国家的政策不符合其倡导的意识形态的时候，就感到受到欺骗，感到这些国家背离初心，不再是那个民主灯塔或者不再是那个苏维埃，其实他们本就不是。一个国家永远不会像其自我介绍的那样伟大。\n\n诚然，意识形态十分具有吸引力，听起来伟光正，让人热血沸腾，某种程度上意识形态确实是代表了人类的崇高理想，其被创造出来的初衷可能确实不是为政治服务，但幼稚的相信某些国家就完全代表了某些意识形态，将意识形态的成功与否与该国家绑定，这是不合理的。","slug":"20220425讨论","published":1,"updated":"2022-09-24T10:44:01.025Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigle0001w0je5zy5cbu4","content":"<p>杂谈</p>\n<span id=\"more\"></span>\n\n<h1 id=\"2022年4月25日讨论\"><a href=\"#2022年4月25日讨论\" class=\"headerlink\" title=\"2022年4月25日讨论\"></a>2022年4月25日讨论</h1><h2 id=\"意识形态为政治行动而服务\"><a href=\"#意识形态为政治行动而服务\" class=\"headerlink\" title=\"意识形态为政治行动而服务\"></a>意识形态为政治行动而服务</h2><p> 引：<a href=\"https://www.bilibili.com/video/BV1PL4y1V7Nw?spm_id_from=333.880.my_history.page.click\">【bilibili】欧盟不只是弱鸡——傅正</a></p>\n<p>论点：<strong>不论是自由主义，民族主义亦或是共产主义的意识形态，其本质都是工具，为了达成某种政治目的，要时刻把握意识形态是工具不是目的</strong>。这和温铁军强调的思考问题应该去意识形态化的观点不谋而合。</p>\n<p>美国作为民主自由最大的代言人，依旧可以为了自身利益扶植南美独裁国家，依旧可以与沙特君主制国家联盟，依旧可以放弃自由贸易为本国产业铲除国外竞争对手；同样，代表无产阶级的苏联也可以为了苏联利益放弃农民利益大搞工农剪刀差，也可以强调奉献暂时放弃提高工人生活水平，也可以实行存在市场的新经济政策。国家是多个利益集团交织在一起的复杂的利益体，国家的政策往往是多个利益集团之间互相妥协的产物。</p>\n<p>因此，此前的一些观点是不够成熟的。比如不能因为共产主义和自由主义这种解构民族主义的意识形态的出现就判民族主义死刑，阶级是客观存在的，民族也是客观存在的。<strong>所谓民族主义和自由主义，都只是用来最大化团结本国人民的工具</strong>。美国选择自由主义，是因为在没有民族认同的新大陆，自由主义是最能团结美国人民的意识形态。自由主义当然是有代价的，由于强调公民自由，控制新冠成为天方夜谭，国内治安问题无法解决；同时，不能光明正大的干涉别国经济和内政，不能侵犯他国人权（表面上），否则会激起国内人民反对。同理，中华民族伟大复兴带有的民族主义色彩也是因为这是最能团结中国人民的意识形态，其同样也会有代价。虽然有这些代价的存在，但美国当权者依旧需要自由主义，中国依旧需要民族主义，这就是意识形态的威力，它们诞生是为政治服务，但一旦其开始为政治服务，国家的政策必然会出现意识形态惯性。</p>\n<p>这样看，许多问题其实根本就是伪命题，国家因为其代表的过于复杂的利益纠葛，导致甚至有时候看起来有一种为了存在而存在的意味。这都是很正常的，不必时时刻刻用意识形态来约束国家的行为，意识形态是被发明的，不是世界上本就存在的绝对真理。因此，讨论国家修不修本身就是伪命题，没有任何一个国家能做到像意识形态描述的那样单纯，因为其背后的利益集团本就是不单纯的，<strong>不必把国家抽象化，拟人化和神话</strong>，单纯的认为美国就是自由民主的，苏联就是为了无产阶级的，这种单纯的想法会导致看到这些国家的政策不符合其倡导的意识形态的时候，就感到受到欺骗，感到这些国家背离初心，不再是那个民主灯塔或者不再是那个苏维埃，其实他们本就不是。一个国家永远不会像其自我介绍的那样伟大。</p>\n<p>诚然，意识形态十分具有吸引力，听起来伟光正，让人热血沸腾，某种程度上意识形态确实是代表了人类的崇高理想，其被创造出来的初衷可能确实不是为政治服务，但幼稚的相信某些国家就完全代表了某些意识形态，将意识形态的成功与否与该国家绑定，这是不合理的。</p>\n","site":{"data":{}},"wordcount":1144,"excerpt":"<p>杂谈</p>","more":"<h1 id=\"2022年4月25日讨论\"><a href=\"#2022年4月25日讨论\" class=\"headerlink\" title=\"2022年4月25日讨论\"></a>2022年4月25日讨论</h1><h2 id=\"意识形态为政治行动而服务\"><a href=\"#意识形态为政治行动而服务\" class=\"headerlink\" title=\"意识形态为政治行动而服务\"></a>意识形态为政治行动而服务</h2><p> 引：<a href=\"https://www.bilibili.com/video/BV1PL4y1V7Nw?spm_id_from=333.880.my_history.page.click\">【bilibili】欧盟不只是弱鸡——傅正</a></p>\n<p>论点：<strong>不论是自由主义，民族主义亦或是共产主义的意识形态，其本质都是工具，为了达成某种政治目的，要时刻把握意识形态是工具不是目的</strong>。这和温铁军强调的思考问题应该去意识形态化的观点不谋而合。</p>\n<p>美国作为民主自由最大的代言人，依旧可以为了自身利益扶植南美独裁国家，依旧可以与沙特君主制国家联盟，依旧可以放弃自由贸易为本国产业铲除国外竞争对手；同样，代表无产阶级的苏联也可以为了苏联利益放弃农民利益大搞工农剪刀差，也可以强调奉献暂时放弃提高工人生活水平，也可以实行存在市场的新经济政策。国家是多个利益集团交织在一起的复杂的利益体，国家的政策往往是多个利益集团之间互相妥协的产物。</p>\n<p>因此，此前的一些观点是不够成熟的。比如不能因为共产主义和自由主义这种解构民族主义的意识形态的出现就判民族主义死刑，阶级是客观存在的，民族也是客观存在的。<strong>所谓民族主义和自由主义，都只是用来最大化团结本国人民的工具</strong>。美国选择自由主义，是因为在没有民族认同的新大陆，自由主义是最能团结美国人民的意识形态。自由主义当然是有代价的，由于强调公民自由，控制新冠成为天方夜谭，国内治安问题无法解决；同时，不能光明正大的干涉别国经济和内政，不能侵犯他国人权（表面上），否则会激起国内人民反对。同理，中华民族伟大复兴带有的民族主义色彩也是因为这是最能团结中国人民的意识形态，其同样也会有代价。虽然有这些代价的存在，但美国当权者依旧需要自由主义，中国依旧需要民族主义，这就是意识形态的威力，它们诞生是为政治服务，但一旦其开始为政治服务，国家的政策必然会出现意识形态惯性。</p>\n<p>这样看，许多问题其实根本就是伪命题，国家因为其代表的过于复杂的利益纠葛，导致甚至有时候看起来有一种为了存在而存在的意味。这都是很正常的，不必时时刻刻用意识形态来约束国家的行为，意识形态是被发明的，不是世界上本就存在的绝对真理。因此，讨论国家修不修本身就是伪命题，没有任何一个国家能做到像意识形态描述的那样单纯，因为其背后的利益集团本就是不单纯的，<strong>不必把国家抽象化，拟人化和神话</strong>，单纯的认为美国就是自由民主的，苏联就是为了无产阶级的，这种单纯的想法会导致看到这些国家的政策不符合其倡导的意识形态的时候，就感到受到欺骗，感到这些国家背离初心，不再是那个民主灯塔或者不再是那个苏维埃，其实他们本就不是。一个国家永远不会像其自我介绍的那样伟大。</p>\n<p>诚然，意识形态十分具有吸引力，听起来伟光正，让人热血沸腾，某种程度上意识形态确实是代表了人类的崇高理想，其被创造出来的初衷可能确实不是为政治服务，但幼稚的相信某些国家就完全代表了某些意识形态，将意识形态的成功与否与该国家绑定，这是不合理的。</p>"},{"title":"3DSlicer配置与编译","date":"2022-06-18T16:00:00.000Z","index_img":"/img/bg/3DSlicerLogo.png","_content":"\n3DSlicer配置与编译\n<!-- more -->\n\n# 3DSlicer配置与编译\n## 1.安装编译所需工具\n参考[官方文档](https://slicer.readthedocs.io/en/latest/developer_guide/build_instructions/windows.html)和[CSDN文档](https://blog.csdn.net/yaoxingdong/article/details/108051384)\n\n![](/article_img/2022-05-30-18-51-12.png)\n### 个人版本:  \nCMake 3.23.2  \nGit 2.26.2  \nVS 2022 (最好安装所有与V143和CMake相关的包，防止编译出错)  \nQt 5.15.2 (Qt必须5.15以上版本，但Qt6取消了Qt Script，没有尝试是否有影响)  \nNSIS  \n\nQt 5.15开始官方取消离线安装包，需要用\n[在线下载工具](http://download.qt.io/official_releases/online_installers/)\n\n第一次登录时注意选择个人用户，否则会自动下载商业版。\n\n## 2. 按照官方文档开始编译\n可能会报错\n\n![](/article_img/2022-05-30-19-01-47.png)\n\n![](/article_img/2022-05-30-19-02-18.png)\n\n![](/article_img/2022-05-30-19-03-35.png)\n\n将箭头所指处换成\\git\\Git\\usr\\bin\\patch.exe  **git安装位置因人而异**， 之后继续点击**Configure**直到方框中红色项全部变为白色，之后后点击**generate**生成。\n\n之后点击**Open Project**，将**All_BUILD**设为启动项目。再点击生成，之后可能要等待非常长的时间，生成的文件也会很大，大约50G。\n\n![](/article_img/2022-05-30-19-12-19.png)\n\n很幸运没什么问题生成完成了，如果之后再次生成有什么问题可以参考开头的博客（\n![](/article_img/2022-05-31-14-18-58.png)\n\n## 3. 打开文件\n\n编译全部成功之后，会在 \\S4D\\Slicer-build 目录下生成一个 Slicer.exe 的可执行文件，双击即可打开3D-slicer 程序。\n\n![](/article_img/2022-05-31-15-48-06.png)\n\n这只是一个启动程序，用来配置环境变量之类的，看到下图等一会就会启动3DSlicer软件了。\n\n![](/article_img/2022-05-31-15-45-30.png)\n\n3Dslicer启动之后这个窗口也不能关闭\n\n![](/article_img/2022-05-31-15-48-55.png)\n\n**标志着我们编译成功了！！！**\n\n## 4. 进行测试（可能可以跳过）\n\n根据官方文档进行操作\n\n![](/article_img/2022-05-31-15-59-31.png)\n\n打开CMD，切换到 \\S4D\\Slicer-build 目录，运行**Slicer.exe --VisualStudioProject**命令，之后会启动VS 2022\n\n文档中的Select build configuration指：\n![](/article_img/2022-05-31-16-12-50.png)\n\n开始生成之后，会自动执行600多个测试，期间会不断跳出各种测试窗口，不用理会（这个过程也很长，不做好像也没什么。。）\n\n![](/article_img/2022-05-31-16-22-07.png)\n\n可能会报错，先点击重试，会自动跳过（也不一定用到报错的这个功能）\n\n![](/article_img/2022-05-31-16-23-44.png)\n\n**之后就可以正常使用了**\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/3DSlicer配置编译.md","raw":"---\ntitle: 3DSlicer配置与编译\ndate: 2022-06-19 \nindex_img: \"/img/bg/3DSlicerLogo.png\"\ntags: [3DSlicer]\ncategories: \n   -[3DSlicer]\n---\n\n3DSlicer配置与编译\n<!-- more -->\n\n# 3DSlicer配置与编译\n## 1.安装编译所需工具\n参考[官方文档](https://slicer.readthedocs.io/en/latest/developer_guide/build_instructions/windows.html)和[CSDN文档](https://blog.csdn.net/yaoxingdong/article/details/108051384)\n\n![](/article_img/2022-05-30-18-51-12.png)\n### 个人版本:  \nCMake 3.23.2  \nGit 2.26.2  \nVS 2022 (最好安装所有与V143和CMake相关的包，防止编译出错)  \nQt 5.15.2 (Qt必须5.15以上版本，但Qt6取消了Qt Script，没有尝试是否有影响)  \nNSIS  \n\nQt 5.15开始官方取消离线安装包，需要用\n[在线下载工具](http://download.qt.io/official_releases/online_installers/)\n\n第一次登录时注意选择个人用户，否则会自动下载商业版。\n\n## 2. 按照官方文档开始编译\n可能会报错\n\n![](/article_img/2022-05-30-19-01-47.png)\n\n![](/article_img/2022-05-30-19-02-18.png)\n\n![](/article_img/2022-05-30-19-03-35.png)\n\n将箭头所指处换成\\git\\Git\\usr\\bin\\patch.exe  **git安装位置因人而异**， 之后继续点击**Configure**直到方框中红色项全部变为白色，之后后点击**generate**生成。\n\n之后点击**Open Project**，将**All_BUILD**设为启动项目。再点击生成，之后可能要等待非常长的时间，生成的文件也会很大，大约50G。\n\n![](/article_img/2022-05-30-19-12-19.png)\n\n很幸运没什么问题生成完成了，如果之后再次生成有什么问题可以参考开头的博客（\n![](/article_img/2022-05-31-14-18-58.png)\n\n## 3. 打开文件\n\n编译全部成功之后，会在 \\S4D\\Slicer-build 目录下生成一个 Slicer.exe 的可执行文件，双击即可打开3D-slicer 程序。\n\n![](/article_img/2022-05-31-15-48-06.png)\n\n这只是一个启动程序，用来配置环境变量之类的，看到下图等一会就会启动3DSlicer软件了。\n\n![](/article_img/2022-05-31-15-45-30.png)\n\n3Dslicer启动之后这个窗口也不能关闭\n\n![](/article_img/2022-05-31-15-48-55.png)\n\n**标志着我们编译成功了！！！**\n\n## 4. 进行测试（可能可以跳过）\n\n根据官方文档进行操作\n\n![](/article_img/2022-05-31-15-59-31.png)\n\n打开CMD，切换到 \\S4D\\Slicer-build 目录，运行**Slicer.exe --VisualStudioProject**命令，之后会启动VS 2022\n\n文档中的Select build configuration指：\n![](/article_img/2022-05-31-16-12-50.png)\n\n开始生成之后，会自动执行600多个测试，期间会不断跳出各种测试窗口，不用理会（这个过程也很长，不做好像也没什么。。）\n\n![](/article_img/2022-05-31-16-22-07.png)\n\n可能会报错，先点击重试，会自动跳过（也不一定用到报错的这个功能）\n\n![](/article_img/2022-05-31-16-23-44.png)\n\n**之后就可以正常使用了**\n\n\n\n\n\n\n\n\n\n\n\n","slug":"3DSlicer配置编译","published":1,"updated":"2022-10-28T11:58:26.906Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglg0002w0jeh5n4fklm","content":"<p>3DSlicer配置与编译</p>\n<span id=\"more\"></span>\n\n<h1 id=\"3DSlicer配置与编译\"><a href=\"#3DSlicer配置与编译\" class=\"headerlink\" title=\"3DSlicer配置与编译\"></a>3DSlicer配置与编译</h1><h2 id=\"1-安装编译所需工具\"><a href=\"#1-安装编译所需工具\" class=\"headerlink\" title=\"1.安装编译所需工具\"></a>1.安装编译所需工具</h2><p>参考<a href=\"https://slicer.readthedocs.io/en/latest/developer_guide/build_instructions/windows.html\">官方文档</a>和<a href=\"https://blog.csdn.net/yaoxingdong/article/details/108051384\">CSDN文档</a></p>\n<p><img src=\"/article_img/2022-05-30-18-51-12.png\"></p>\n<h3 id=\"个人版本\"><a href=\"#个人版本\" class=\"headerlink\" title=\"个人版本:\"></a>个人版本:</h3><p>CMake 3.23.2<br>Git 2.26.2<br>VS 2022 (最好安装所有与V143和CMake相关的包，防止编译出错)<br>Qt 5.15.2 (Qt必须5.15以上版本，但Qt6取消了Qt Script，没有尝试是否有影响)<br>NSIS  </p>\n<p>Qt 5.15开始官方取消离线安装包，需要用<br><a href=\"http://download.qt.io/official_releases/online_installers/\">在线下载工具</a></p>\n<p>第一次登录时注意选择个人用户，否则会自动下载商业版。</p>\n<h2 id=\"2-按照官方文档开始编译\"><a href=\"#2-按照官方文档开始编译\" class=\"headerlink\" title=\"2. 按照官方文档开始编译\"></a>2. 按照官方文档开始编译</h2><p>可能会报错</p>\n<p><img src=\"/article_img/2022-05-30-19-01-47.png\"></p>\n<p><img src=\"/article_img/2022-05-30-19-02-18.png\"></p>\n<p><img src=\"/article_img/2022-05-30-19-03-35.png\"></p>\n<p>将箭头所指处换成\\git\\Git\\usr\\bin\\patch.exe  <strong>git安装位置因人而异</strong>， 之后继续点击<strong>Configure</strong>直到方框中红色项全部变为白色，之后后点击<strong>generate</strong>生成。</p>\n<p>之后点击<strong>Open Project</strong>，将<strong>All_BUILD</strong>设为启动项目。再点击生成，之后可能要等待非常长的时间，生成的文件也会很大，大约50G。</p>\n<p><img src=\"/article_img/2022-05-30-19-12-19.png\"></p>\n<p>很幸运没什么问题生成完成了，如果之后再次生成有什么问题可以参考开头的博客（<br><img src=\"/article_img/2022-05-31-14-18-58.png\"></p>\n<h2 id=\"3-打开文件\"><a href=\"#3-打开文件\" class=\"headerlink\" title=\"3. 打开文件\"></a>3. 打开文件</h2><p>编译全部成功之后，会在 \\S4D\\Slicer-build 目录下生成一个 Slicer.exe 的可执行文件，双击即可打开3D-slicer 程序。</p>\n<p><img src=\"/article_img/2022-05-31-15-48-06.png\"></p>\n<p>这只是一个启动程序，用来配置环境变量之类的，看到下图等一会就会启动3DSlicer软件了。</p>\n<p><img src=\"/article_img/2022-05-31-15-45-30.png\"></p>\n<p>3Dslicer启动之后这个窗口也不能关闭</p>\n<p><img src=\"/article_img/2022-05-31-15-48-55.png\"></p>\n<p><strong>标志着我们编译成功了！！！</strong></p>\n<h2 id=\"4-进行测试（可能可以跳过）\"><a href=\"#4-进行测试（可能可以跳过）\" class=\"headerlink\" title=\"4. 进行测试（可能可以跳过）\"></a>4. 进行测试（可能可以跳过）</h2><p>根据官方文档进行操作</p>\n<p><img src=\"/article_img/2022-05-31-15-59-31.png\"></p>\n<p>打开CMD，切换到 \\S4D\\Slicer-build 目录，运行<strong>Slicer.exe –VisualStudioProject</strong>命令，之后会启动VS 2022</p>\n<p>文档中的Select build configuration指：<br><img src=\"/article_img/2022-05-31-16-12-50.png\"></p>\n<p>开始生成之后，会自动执行600多个测试，期间会不断跳出各种测试窗口，不用理会（这个过程也很长，不做好像也没什么。。）</p>\n<p><img src=\"/article_img/2022-05-31-16-22-07.png\"></p>\n<p>可能会报错，先点击重试，会自动跳过（也不一定用到报错的这个功能）</p>\n<p><img src=\"/article_img/2022-05-31-16-23-44.png\"></p>\n<p><strong>之后就可以正常使用了</strong></p>\n","site":{"data":{}},"wordcount":814,"excerpt":"<p>3DSlicer配置与编译</p>","more":"<h1 id=\"3DSlicer配置与编译\"><a href=\"#3DSlicer配置与编译\" class=\"headerlink\" title=\"3DSlicer配置与编译\"></a>3DSlicer配置与编译</h1><h2 id=\"1-安装编译所需工具\"><a href=\"#1-安装编译所需工具\" class=\"headerlink\" title=\"1.安装编译所需工具\"></a>1.安装编译所需工具</h2><p>参考<a href=\"https://slicer.readthedocs.io/en/latest/developer_guide/build_instructions/windows.html\">官方文档</a>和<a href=\"https://blog.csdn.net/yaoxingdong/article/details/108051384\">CSDN文档</a></p>\n<p><img src=\"/article_img/2022-05-30-18-51-12.png\"></p>\n<h3 id=\"个人版本\"><a href=\"#个人版本\" class=\"headerlink\" title=\"个人版本:\"></a>个人版本:</h3><p>CMake 3.23.2<br>Git 2.26.2<br>VS 2022 (最好安装所有与V143和CMake相关的包，防止编译出错)<br>Qt 5.15.2 (Qt必须5.15以上版本，但Qt6取消了Qt Script，没有尝试是否有影响)<br>NSIS  </p>\n<p>Qt 5.15开始官方取消离线安装包，需要用<br><a href=\"http://download.qt.io/official_releases/online_installers/\">在线下载工具</a></p>\n<p>第一次登录时注意选择个人用户，否则会自动下载商业版。</p>\n<h2 id=\"2-按照官方文档开始编译\"><a href=\"#2-按照官方文档开始编译\" class=\"headerlink\" title=\"2. 按照官方文档开始编译\"></a>2. 按照官方文档开始编译</h2><p>可能会报错</p>\n<p><img src=\"/article_img/2022-05-30-19-01-47.png\"></p>\n<p><img src=\"/article_img/2022-05-30-19-02-18.png\"></p>\n<p><img src=\"/article_img/2022-05-30-19-03-35.png\"></p>\n<p>将箭头所指处换成\\git\\Git\\usr\\bin\\patch.exe  <strong>git安装位置因人而异</strong>， 之后继续点击<strong>Configure</strong>直到方框中红色项全部变为白色，之后后点击<strong>generate</strong>生成。</p>\n<p>之后点击<strong>Open Project</strong>，将<strong>All_BUILD</strong>设为启动项目。再点击生成，之后可能要等待非常长的时间，生成的文件也会很大，大约50G。</p>\n<p><img src=\"/article_img/2022-05-30-19-12-19.png\"></p>\n<p>很幸运没什么问题生成完成了，如果之后再次生成有什么问题可以参考开头的博客（<br><img src=\"/article_img/2022-05-31-14-18-58.png\"></p>\n<h2 id=\"3-打开文件\"><a href=\"#3-打开文件\" class=\"headerlink\" title=\"3. 打开文件\"></a>3. 打开文件</h2><p>编译全部成功之后，会在 \\S4D\\Slicer-build 目录下生成一个 Slicer.exe 的可执行文件，双击即可打开3D-slicer 程序。</p>\n<p><img src=\"/article_img/2022-05-31-15-48-06.png\"></p>\n<p>这只是一个启动程序，用来配置环境变量之类的，看到下图等一会就会启动3DSlicer软件了。</p>\n<p><img src=\"/article_img/2022-05-31-15-45-30.png\"></p>\n<p>3Dslicer启动之后这个窗口也不能关闭</p>\n<p><img src=\"/article_img/2022-05-31-15-48-55.png\"></p>\n<p><strong>标志着我们编译成功了！！！</strong></p>\n<h2 id=\"4-进行测试（可能可以跳过）\"><a href=\"#4-进行测试（可能可以跳过）\" class=\"headerlink\" title=\"4. 进行测试（可能可以跳过）\"></a>4. 进行测试（可能可以跳过）</h2><p>根据官方文档进行操作</p>\n<p><img src=\"/article_img/2022-05-31-15-59-31.png\"></p>\n<p>打开CMD，切换到 \\S4D\\Slicer-build 目录，运行<strong>Slicer.exe –VisualStudioProject</strong>命令，之后会启动VS 2022</p>\n<p>文档中的Select build configuration指：<br><img src=\"/article_img/2022-05-31-16-12-50.png\"></p>\n<p>开始生成之后，会自动执行600多个测试，期间会不断跳出各种测试窗口，不用理会（这个过程也很长，不做好像也没什么。。）</p>\n<p><img src=\"/article_img/2022-05-31-16-22-07.png\"></p>\n<p>可能会报错，先点击重试，会自动跳过（也不一定用到报错的这个功能）</p>\n<p><img src=\"/article_img/2022-05-31-16-23-44.png\"></p>\n<p><strong>之后就可以正常使用了</strong></p>"},{"title":"3DSlicer配置与编译","date":"2022-08-06T16:00:00.000Z","index_img":"/img/bg/3DSlicerLogo.png","hide":true,"_content":"# 3DSlicer插件制作\n## 参考文档：  \n[3DSlicer建立C++插件步骤](https://blog.csdn.net/sang_12345/article/details/121805914)  \n[3DSlicer: Module-Create Loadable](https://www.freesion.com/article/1531976481/)  \n[官方文档](https://slicer.readthedocs.io/en/latest/developer_guide/extensions.html)\n\n## 1.准备工作\n如果选择开发命令行接口（Command Line Interface (CLI)）或者可加载插件需要先编译3DSlicer，如果是**单纯python脚本不需要编译3DSlicer**\n![](/article_img/2022-06-06-18-35-54.png)\n## 2. 插件模板生成\n使用3DSlicer自带的Extension Wizard模块可以方便的创建插件。这里建立一个script类型的插件，具体参考官方文档，会自动生成一个script类型的插件的模板python文件，可以在这个模板文件中进行修改。\n## 3. 插件功能开发流程\n3DSlicer功能强大完全可以仅使用3DSlicer和代码编辑器就可以进行插件的实现和调试，这里就仅使用pycharm作为编辑器（没有配置python编译器，编译调试均在3DSlicer中进行）\n\n![](/article_img/2022-06-20-14-08-41.png)\n\n**Python Interactor** 可以在左上角的 **View** 中打开，或者使用快捷键 **ctrl+ 3** 打开，利用模板生成的按钮可以进行调试：\n\n### **常用按钮**\n\n**Reload**：可以重新加载插件，编辑python文件之后保存，点击这个按钮就可以重载插件，十分方便用于调试。注：对上方的**Help & Acknowledge** 的修改需要重启之后才能应用。\n**Edit UI**：直接从Designer打开 ui 文件，方便直接对插件界面进行修改（对界面的修改仅限于左侧部分界面，右侧窗口不能修改）\n\n## 4. 插件功能实现\n\n对插件功能的实现主要是利用3DSlicer本身集成的python package和其自定义的包进行开发，也可以使用3DSlicer不包含的第三方包，使用方法是利用3DSlicer中的pip\n\n```python\ntry:\n    import library_name\nexcept:\n    slicer.util.pip_install('library_name')\n    import library_name\n```\n\n### **1）参考文档**\n[Script Repository](https://slicer.readthedocs.io/en/latest/developer_guide/script_repository.html#change-slice-orientation) 介绍常用功能实现的脚本\n\n[slicer package](https://slicer.readthedocs.io/en/latest/developer_guide/slicer.html#slicer.util.MRMLNodeNotFoundException) 对 **slicer** 库进行介绍,开发插件常用的主要功能的实现都需要使用这个库，来对3DSlicer软件进行定制，[部分slicer库函数代码介绍](mwoehlke-kitware.github.io/Slicer/Base/slicer.html#slicer.util.quit)\n\n### **2）导入图像功能实现**\n\n本插件主要处理的图像是2D图像，格式为jpeg，png等，这些图导入3DSlicer时不能直接将这些格式的图像导入，需要先转换成3DSlicer支持的数据类型，图片格式一般要转换成 **Volume** 类型，具体[数据类型](https://www.slicer.org/wiki/Documentation/4.8/SlicerApplication/SupportedDataFormat)参考如下：\n\n![](/article_img/2022-06-20-14-41-24.png)\n\n导入的图片有几种不同的方法，都是利用 **slicer** 库：\n\n```python\n# loadNodeFromFile方法，这个会导入同文件夹中的好几张图片，尽管只选择导入一个文件\nslicer.util.loadNodeFromFile('filepath', 'VolumeFile')\n\n# loadVolume方法，可以设定只导入一张，**选择这个方法**\nloadedVolumeNode = slicer.util.loadVolume('filepath', {\"singleFile\": True})\n\n# 直接调用3DSlicer的导入数据模块，但不能得到用户选择的文件路径\nslicer.util.openAddDataDialog()\n```\n\n这三种方法导入之后，都会自动显示到右侧窗口，覆盖之前显示的内容。\n\n针对前两种方法，要获得用户选择的文件需要使用3DSlicer自带的 **qt** 库，这里的qt库不是一般我们在python中使用的 **pyqt** 库，一开始没有找到这个库，以为需要导入 **pyqt**，但是 **pyqt** 的函数都需要定义在一个继承自qt的库，这里不满足这个条件，之后在[论坛讨论](https://discourse.slicer.org/t/opendialog-does-not-load-node-into-scene/23874)中找到了解决方法：\n```python\nimport qt\n\nd = qt.QFileDialog()\nd.exec()\nslicer.util.loadVolume(d.selectedFiles()[0])\n```\n\n这里其实本来也有3DSlicer封装好的函数，用来打开文件浏览器，\n\n```python\n# openDialog()方法，但是这个函数暂时出了bug，在写文章一周前才在源码层面解决，所以就用上面那种方法。\nimport slicer\n\n io = slicer.app.ioManager()\n params = {}\n io.openDialog(\"VolumeFile\", slicer.qSlicerFileDialog.Read, params)\n```\n\n### **3）显示图像实现**\n\n![](/article_img/2022-06-20-18-05-00.png)\n\n在3DSlicer中，其右侧的窗口不能直接显示jpeg，png等等图片，需要先 **Load** 也就是上述的导入，在导入之后，会自动将图片显示在右侧，就算不是三维图像也会在 **yellow** 层和 **Green** 层（也就是三视图的另外两个方向），所以需要自定义显示的窗口\n\n```python\n# 显示到红色窗口\nred_logic = slicer.app.layoutManager().sliceWidget(\"Red\").sliceLogic()\nred_logic.GetSliceCompositeNode().SetBackgroundVolumeID(VolumeName.GetID())\n# 将图像移到窗口中间，相当于点击上图中的Reset field of view\nslicer.util.resetSliceViews()\n```\n\n![](/article_img/2022-06-20-18-11-02.png)\n\n希望实现的效果如上图，左侧是原始图像，右侧是处理之后的图像。但是 **yellow** 窗口默认方向是 **sagittal** 用如下代码进行更改\n\n```python\n# 改变黄色窗口的显示方向\nslice_node = slicer.app.layoutManager().sliceWidget(\"Yellow\").mrmlSliceNode()\nslice_to_ras = slice_node.GetSliceToRAS()\ntransform = vtk.vtkTransform()\ntransform.SetMatrix(slice_to_ras)\ntransform.RotateX(90)\ntransform.RotateZ(90)\nslice_to_ras.DeepCopy(transform.GetMatrix())\nslice_node.UpdateMatrices()\n```\n\n### **4）显示图像实现**","source":"_posts/3DSlicer插件制作.md","raw":"---\ntitle: 3DSlicer配置与编译\ndate: 2022-08-07\nindex_img: \"/img/bg/3DSlicerLogo.png\"\ntags: [3DSlicer]\nhide: true\ncategories: \n   -[笔记]\n---\n# 3DSlicer插件制作\n## 参考文档：  \n[3DSlicer建立C++插件步骤](https://blog.csdn.net/sang_12345/article/details/121805914)  \n[3DSlicer: Module-Create Loadable](https://www.freesion.com/article/1531976481/)  \n[官方文档](https://slicer.readthedocs.io/en/latest/developer_guide/extensions.html)\n\n## 1.准备工作\n如果选择开发命令行接口（Command Line Interface (CLI)）或者可加载插件需要先编译3DSlicer，如果是**单纯python脚本不需要编译3DSlicer**\n![](/article_img/2022-06-06-18-35-54.png)\n## 2. 插件模板生成\n使用3DSlicer自带的Extension Wizard模块可以方便的创建插件。这里建立一个script类型的插件，具体参考官方文档，会自动生成一个script类型的插件的模板python文件，可以在这个模板文件中进行修改。\n## 3. 插件功能开发流程\n3DSlicer功能强大完全可以仅使用3DSlicer和代码编辑器就可以进行插件的实现和调试，这里就仅使用pycharm作为编辑器（没有配置python编译器，编译调试均在3DSlicer中进行）\n\n![](/article_img/2022-06-20-14-08-41.png)\n\n**Python Interactor** 可以在左上角的 **View** 中打开，或者使用快捷键 **ctrl+ 3** 打开，利用模板生成的按钮可以进行调试：\n\n### **常用按钮**\n\n**Reload**：可以重新加载插件，编辑python文件之后保存，点击这个按钮就可以重载插件，十分方便用于调试。注：对上方的**Help & Acknowledge** 的修改需要重启之后才能应用。\n**Edit UI**：直接从Designer打开 ui 文件，方便直接对插件界面进行修改（对界面的修改仅限于左侧部分界面，右侧窗口不能修改）\n\n## 4. 插件功能实现\n\n对插件功能的实现主要是利用3DSlicer本身集成的python package和其自定义的包进行开发，也可以使用3DSlicer不包含的第三方包，使用方法是利用3DSlicer中的pip\n\n```python\ntry:\n    import library_name\nexcept:\n    slicer.util.pip_install('library_name')\n    import library_name\n```\n\n### **1）参考文档**\n[Script Repository](https://slicer.readthedocs.io/en/latest/developer_guide/script_repository.html#change-slice-orientation) 介绍常用功能实现的脚本\n\n[slicer package](https://slicer.readthedocs.io/en/latest/developer_guide/slicer.html#slicer.util.MRMLNodeNotFoundException) 对 **slicer** 库进行介绍,开发插件常用的主要功能的实现都需要使用这个库，来对3DSlicer软件进行定制，[部分slicer库函数代码介绍](mwoehlke-kitware.github.io/Slicer/Base/slicer.html#slicer.util.quit)\n\n### **2）导入图像功能实现**\n\n本插件主要处理的图像是2D图像，格式为jpeg，png等，这些图导入3DSlicer时不能直接将这些格式的图像导入，需要先转换成3DSlicer支持的数据类型，图片格式一般要转换成 **Volume** 类型，具体[数据类型](https://www.slicer.org/wiki/Documentation/4.8/SlicerApplication/SupportedDataFormat)参考如下：\n\n![](/article_img/2022-06-20-14-41-24.png)\n\n导入的图片有几种不同的方法，都是利用 **slicer** 库：\n\n```python\n# loadNodeFromFile方法，这个会导入同文件夹中的好几张图片，尽管只选择导入一个文件\nslicer.util.loadNodeFromFile('filepath', 'VolumeFile')\n\n# loadVolume方法，可以设定只导入一张，**选择这个方法**\nloadedVolumeNode = slicer.util.loadVolume('filepath', {\"singleFile\": True})\n\n# 直接调用3DSlicer的导入数据模块，但不能得到用户选择的文件路径\nslicer.util.openAddDataDialog()\n```\n\n这三种方法导入之后，都会自动显示到右侧窗口，覆盖之前显示的内容。\n\n针对前两种方法，要获得用户选择的文件需要使用3DSlicer自带的 **qt** 库，这里的qt库不是一般我们在python中使用的 **pyqt** 库，一开始没有找到这个库，以为需要导入 **pyqt**，但是 **pyqt** 的函数都需要定义在一个继承自qt的库，这里不满足这个条件，之后在[论坛讨论](https://discourse.slicer.org/t/opendialog-does-not-load-node-into-scene/23874)中找到了解决方法：\n```python\nimport qt\n\nd = qt.QFileDialog()\nd.exec()\nslicer.util.loadVolume(d.selectedFiles()[0])\n```\n\n这里其实本来也有3DSlicer封装好的函数，用来打开文件浏览器，\n\n```python\n# openDialog()方法，但是这个函数暂时出了bug，在写文章一周前才在源码层面解决，所以就用上面那种方法。\nimport slicer\n\n io = slicer.app.ioManager()\n params = {}\n io.openDialog(\"VolumeFile\", slicer.qSlicerFileDialog.Read, params)\n```\n\n### **3）显示图像实现**\n\n![](/article_img/2022-06-20-18-05-00.png)\n\n在3DSlicer中，其右侧的窗口不能直接显示jpeg，png等等图片，需要先 **Load** 也就是上述的导入，在导入之后，会自动将图片显示在右侧，就算不是三维图像也会在 **yellow** 层和 **Green** 层（也就是三视图的另外两个方向），所以需要自定义显示的窗口\n\n```python\n# 显示到红色窗口\nred_logic = slicer.app.layoutManager().sliceWidget(\"Red\").sliceLogic()\nred_logic.GetSliceCompositeNode().SetBackgroundVolumeID(VolumeName.GetID())\n# 将图像移到窗口中间，相当于点击上图中的Reset field of view\nslicer.util.resetSliceViews()\n```\n\n![](/article_img/2022-06-20-18-11-02.png)\n\n希望实现的效果如上图，左侧是原始图像，右侧是处理之后的图像。但是 **yellow** 窗口默认方向是 **sagittal** 用如下代码进行更改\n\n```python\n# 改变黄色窗口的显示方向\nslice_node = slicer.app.layoutManager().sliceWidget(\"Yellow\").mrmlSliceNode()\nslice_to_ras = slice_node.GetSliceToRAS()\ntransform = vtk.vtkTransform()\ntransform.SetMatrix(slice_to_ras)\ntransform.RotateX(90)\ntransform.RotateZ(90)\nslice_to_ras.DeepCopy(transform.GetMatrix())\nslice_node.UpdateMatrices()\n```\n\n### **4）显示图像实现**","slug":"3DSlicer插件制作","published":1,"updated":"2022-09-24T10:44:01.040Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglj0005w0je5tne58oy","content":"<h1 id=\"3DSlicer插件制作\"><a href=\"#3DSlicer插件制作\" class=\"headerlink\" title=\"3DSlicer插件制作\"></a>3DSlicer插件制作</h1><h2 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h2><p><a href=\"https://blog.csdn.net/sang_12345/article/details/121805914\">3DSlicer建立C++插件步骤</a><br><a href=\"https://www.freesion.com/article/1531976481/\">3DSlicer: Module-Create Loadable</a><br><a href=\"https://slicer.readthedocs.io/en/latest/developer_guide/extensions.html\">官方文档</a></p>\n<h2 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1.准备工作\"></a>1.准备工作</h2><p>如果选择开发命令行接口（Command Line Interface (CLI)）或者可加载插件需要先编译3DSlicer，如果是<strong>单纯python脚本不需要编译3DSlicer</strong><br><img src=\"/article_img/2022-06-06-18-35-54.png\"></p>\n<h2 id=\"2-插件模板生成\"><a href=\"#2-插件模板生成\" class=\"headerlink\" title=\"2. 插件模板生成\"></a>2. 插件模板生成</h2><p>使用3DSlicer自带的Extension Wizard模块可以方便的创建插件。这里建立一个script类型的插件，具体参考官方文档，会自动生成一个script类型的插件的模板python文件，可以在这个模板文件中进行修改。</p>\n<h2 id=\"3-插件功能开发流程\"><a href=\"#3-插件功能开发流程\" class=\"headerlink\" title=\"3. 插件功能开发流程\"></a>3. 插件功能开发流程</h2><p>3DSlicer功能强大完全可以仅使用3DSlicer和代码编辑器就可以进行插件的实现和调试，这里就仅使用pycharm作为编辑器（没有配置python编译器，编译调试均在3DSlicer中进行）</p>\n<p><img src=\"/article_img/2022-06-20-14-08-41.png\"></p>\n<p><strong>Python Interactor</strong> 可以在左上角的 <strong>View</strong> 中打开，或者使用快捷键 <strong>ctrl+ 3</strong> 打开，利用模板生成的按钮可以进行调试：</p>\n<h3 id=\"常用按钮\"><a href=\"#常用按钮\" class=\"headerlink\" title=\"常用按钮\"></a><strong>常用按钮</strong></h3><p><strong>Reload</strong>：可以重新加载插件，编辑python文件之后保存，点击这个按钮就可以重载插件，十分方便用于调试。注：对上方的<strong>Help &amp; Acknowledge</strong> 的修改需要重启之后才能应用。<br><strong>Edit UI</strong>：直接从Designer打开 ui 文件，方便直接对插件界面进行修改（对界面的修改仅限于左侧部分界面，右侧窗口不能修改）</p>\n<h2 id=\"4-插件功能实现\"><a href=\"#4-插件功能实现\" class=\"headerlink\" title=\"4. 插件功能实现\"></a>4. 插件功能实现</h2><p>对插件功能的实现主要是利用3DSlicer本身集成的python package和其自定义的包进行开发，也可以使用3DSlicer不包含的第三方包，使用方法是利用3DSlicer中的pip</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    <span class=\"hljs-keyword\">import</span> library_name<br><span class=\"hljs-keyword\">except</span>:<br>    slicer.util.pip_install(<span class=\"hljs-string\">&#x27;library_name&#x27;</span>)<br>    <span class=\"hljs-keyword\">import</span> library_name<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1）参考文档\"><a href=\"#1）参考文档\" class=\"headerlink\" title=\"1）参考文档\"></a><strong>1）参考文档</strong></h3><p><a href=\"https://slicer.readthedocs.io/en/latest/developer_guide/script_repository.html#change-slice-orientation\">Script Repository</a> 介绍常用功能实现的脚本</p>\n<p><a href=\"https://slicer.readthedocs.io/en/latest/developer_guide/slicer.html#slicer.util.MRMLNodeNotFoundException\">slicer package</a> 对 <strong>slicer</strong> 库进行介绍,开发插件常用的主要功能的实现都需要使用这个库，来对3DSlicer软件进行定制，<a href=\"mwoehlke-kitware.github.io/Slicer/Base/slicer.html#slicer.util.quit\">部分slicer库函数代码介绍</a></p>\n<h3 id=\"2）导入图像功能实现\"><a href=\"#2）导入图像功能实现\" class=\"headerlink\" title=\"2）导入图像功能实现\"></a><strong>2）导入图像功能实现</strong></h3><p>本插件主要处理的图像是2D图像，格式为jpeg，png等，这些图导入3DSlicer时不能直接将这些格式的图像导入，需要先转换成3DSlicer支持的数据类型，图片格式一般要转换成 <strong>Volume</strong> 类型，具体<a href=\"https://www.slicer.org/wiki/Documentation/4.8/SlicerApplication/SupportedDataFormat\">数据类型</a>参考如下：</p>\n<p><img src=\"/article_img/2022-06-20-14-41-24.png\"></p>\n<p>导入的图片有几种不同的方法，都是利用 <strong>slicer</strong> 库：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># loadNodeFromFile方法，这个会导入同文件夹中的好几张图片，尽管只选择导入一个文件</span><br>slicer.util.loadNodeFromFile(<span class=\"hljs-string\">&#x27;filepath&#x27;</span>, <span class=\"hljs-string\">&#x27;VolumeFile&#x27;</span>)<br><br><span class=\"hljs-comment\"># loadVolume方法，可以设定只导入一张，**选择这个方法**</span><br>loadedVolumeNode = slicer.util.loadVolume(<span class=\"hljs-string\">&#x27;filepath&#x27;</span>, &#123;<span class=\"hljs-string\">&quot;singleFile&quot;</span>: <span class=\"hljs-literal\">True</span>&#125;)<br><br><span class=\"hljs-comment\"># 直接调用3DSlicer的导入数据模块，但不能得到用户选择的文件路径</span><br>slicer.util.openAddDataDialog()<br></code></pre></td></tr></table></figure>\n\n<p>这三种方法导入之后，都会自动显示到右侧窗口，覆盖之前显示的内容。</p>\n<p>针对前两种方法，要获得用户选择的文件需要使用3DSlicer自带的 <strong>qt</strong> 库，这里的qt库不是一般我们在python中使用的 <strong>pyqt</strong> 库，一开始没有找到这个库，以为需要导入 <strong>pyqt</strong>，但是 <strong>pyqt</strong> 的函数都需要定义在一个继承自qt的库，这里不满足这个条件，之后在<a href=\"https://discourse.slicer.org/t/opendialog-does-not-load-node-into-scene/23874\">论坛讨论</a>中找到了解决方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> qt<br><br>d = qt.QFileDialog()<br>d.<span class=\"hljs-built_in\">exec</span>()<br>slicer.util.loadVolume(d.selectedFiles()[<span class=\"hljs-number\">0</span>])<br></code></pre></td></tr></table></figure>\n\n<p>这里其实本来也有3DSlicer封装好的函数，用来打开文件浏览器，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># openDialog()方法，但是这个函数暂时出了bug，在写文章一周前才在源码层面解决，所以就用上面那种方法。</span><br><span class=\"hljs-keyword\">import</span> slicer<br><br> io = slicer.app.ioManager()<br> params = &#123;&#125;<br> io.openDialog(<span class=\"hljs-string\">&quot;VolumeFile&quot;</span>, slicer.qSlicerFileDialog.Read, params)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3）显示图像实现\"><a href=\"#3）显示图像实现\" class=\"headerlink\" title=\"3）显示图像实现\"></a><strong>3）显示图像实现</strong></h3><p><img src=\"/article_img/2022-06-20-18-05-00.png\"></p>\n<p>在3DSlicer中，其右侧的窗口不能直接显示jpeg，png等等图片，需要先 <strong>Load</strong> 也就是上述的导入，在导入之后，会自动将图片显示在右侧，就算不是三维图像也会在 <strong>yellow</strong> 层和 <strong>Green</strong> 层（也就是三视图的另外两个方向），所以需要自定义显示的窗口</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 显示到红色窗口</span><br>red_logic = slicer.app.layoutManager().sliceWidget(<span class=\"hljs-string\">&quot;Red&quot;</span>).sliceLogic()<br>red_logic.GetSliceCompositeNode().SetBackgroundVolumeID(VolumeName.GetID())<br><span class=\"hljs-comment\"># 将图像移到窗口中间，相当于点击上图中的Reset field of view</span><br>slicer.util.resetSliceViews()<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-06-20-18-11-02.png\"></p>\n<p>希望实现的效果如上图，左侧是原始图像，右侧是处理之后的图像。但是 <strong>yellow</strong> 窗口默认方向是 <strong>sagittal</strong> 用如下代码进行更改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 改变黄色窗口的显示方向</span><br>slice_node = slicer.app.layoutManager().sliceWidget(<span class=\"hljs-string\">&quot;Yellow&quot;</span>).mrmlSliceNode()<br>slice_to_ras = slice_node.GetSliceToRAS()<br>transform = vtk.vtkTransform()<br>transform.SetMatrix(slice_to_ras)<br>transform.RotateX(<span class=\"hljs-number\">90</span>)<br>transform.RotateZ(<span class=\"hljs-number\">90</span>)<br>slice_to_ras.DeepCopy(transform.GetMatrix())<br>slice_node.UpdateMatrices()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4）显示图像实现\"><a href=\"#4）显示图像实现\" class=\"headerlink\" title=\"4）显示图像实现\"></a><strong>4）显示图像实现</strong></h3>","site":{"data":{}},"wordcount":2635,"excerpt":"","more":"<h1 id=\"3DSlicer插件制作\"><a href=\"#3DSlicer插件制作\" class=\"headerlink\" title=\"3DSlicer插件制作\"></a>3DSlicer插件制作</h1><h2 id=\"参考文档：\"><a href=\"#参考文档：\" class=\"headerlink\" title=\"参考文档：\"></a>参考文档：</h2><p><a href=\"https://blog.csdn.net/sang_12345/article/details/121805914\">3DSlicer建立C++插件步骤</a><br><a href=\"https://www.freesion.com/article/1531976481/\">3DSlicer: Module-Create Loadable</a><br><a href=\"https://slicer.readthedocs.io/en/latest/developer_guide/extensions.html\">官方文档</a></p>\n<h2 id=\"1-准备工作\"><a href=\"#1-准备工作\" class=\"headerlink\" title=\"1.准备工作\"></a>1.准备工作</h2><p>如果选择开发命令行接口（Command Line Interface (CLI)）或者可加载插件需要先编译3DSlicer，如果是<strong>单纯python脚本不需要编译3DSlicer</strong><br><img src=\"/article_img/2022-06-06-18-35-54.png\"></p>\n<h2 id=\"2-插件模板生成\"><a href=\"#2-插件模板生成\" class=\"headerlink\" title=\"2. 插件模板生成\"></a>2. 插件模板生成</h2><p>使用3DSlicer自带的Extension Wizard模块可以方便的创建插件。这里建立一个script类型的插件，具体参考官方文档，会自动生成一个script类型的插件的模板python文件，可以在这个模板文件中进行修改。</p>\n<h2 id=\"3-插件功能开发流程\"><a href=\"#3-插件功能开发流程\" class=\"headerlink\" title=\"3. 插件功能开发流程\"></a>3. 插件功能开发流程</h2><p>3DSlicer功能强大完全可以仅使用3DSlicer和代码编辑器就可以进行插件的实现和调试，这里就仅使用pycharm作为编辑器（没有配置python编译器，编译调试均在3DSlicer中进行）</p>\n<p><img src=\"/article_img/2022-06-20-14-08-41.png\"></p>\n<p><strong>Python Interactor</strong> 可以在左上角的 <strong>View</strong> 中打开，或者使用快捷键 <strong>ctrl+ 3</strong> 打开，利用模板生成的按钮可以进行调试：</p>\n<h3 id=\"常用按钮\"><a href=\"#常用按钮\" class=\"headerlink\" title=\"常用按钮\"></a><strong>常用按钮</strong></h3><p><strong>Reload</strong>：可以重新加载插件，编辑python文件之后保存，点击这个按钮就可以重载插件，十分方便用于调试。注：对上方的<strong>Help &amp; Acknowledge</strong> 的修改需要重启之后才能应用。<br><strong>Edit UI</strong>：直接从Designer打开 ui 文件，方便直接对插件界面进行修改（对界面的修改仅限于左侧部分界面，右侧窗口不能修改）</p>\n<h2 id=\"4-插件功能实现\"><a href=\"#4-插件功能实现\" class=\"headerlink\" title=\"4. 插件功能实现\"></a>4. 插件功能实现</h2><p>对插件功能的实现主要是利用3DSlicer本身集成的python package和其自定义的包进行开发，也可以使用3DSlicer不包含的第三方包，使用方法是利用3DSlicer中的pip</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">try</span>:<br>    <span class=\"hljs-keyword\">import</span> library_name<br><span class=\"hljs-keyword\">except</span>:<br>    slicer.util.pip_install(<span class=\"hljs-string\">&#x27;library_name&#x27;</span>)<br>    <span class=\"hljs-keyword\">import</span> library_name<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1）参考文档\"><a href=\"#1）参考文档\" class=\"headerlink\" title=\"1）参考文档\"></a><strong>1）参考文档</strong></h3><p><a href=\"https://slicer.readthedocs.io/en/latest/developer_guide/script_repository.html#change-slice-orientation\">Script Repository</a> 介绍常用功能实现的脚本</p>\n<p><a href=\"https://slicer.readthedocs.io/en/latest/developer_guide/slicer.html#slicer.util.MRMLNodeNotFoundException\">slicer package</a> 对 <strong>slicer</strong> 库进行介绍,开发插件常用的主要功能的实现都需要使用这个库，来对3DSlicer软件进行定制，<a href=\"mwoehlke-kitware.github.io/Slicer/Base/slicer.html#slicer.util.quit\">部分slicer库函数代码介绍</a></p>\n<h3 id=\"2）导入图像功能实现\"><a href=\"#2）导入图像功能实现\" class=\"headerlink\" title=\"2）导入图像功能实现\"></a><strong>2）导入图像功能实现</strong></h3><p>本插件主要处理的图像是2D图像，格式为jpeg，png等，这些图导入3DSlicer时不能直接将这些格式的图像导入，需要先转换成3DSlicer支持的数据类型，图片格式一般要转换成 <strong>Volume</strong> 类型，具体<a href=\"https://www.slicer.org/wiki/Documentation/4.8/SlicerApplication/SupportedDataFormat\">数据类型</a>参考如下：</p>\n<p><img src=\"/article_img/2022-06-20-14-41-24.png\"></p>\n<p>导入的图片有几种不同的方法，都是利用 <strong>slicer</strong> 库：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># loadNodeFromFile方法，这个会导入同文件夹中的好几张图片，尽管只选择导入一个文件</span><br>slicer.util.loadNodeFromFile(<span class=\"hljs-string\">&#x27;filepath&#x27;</span>, <span class=\"hljs-string\">&#x27;VolumeFile&#x27;</span>)<br><br><span class=\"hljs-comment\"># loadVolume方法，可以设定只导入一张，**选择这个方法**</span><br>loadedVolumeNode = slicer.util.loadVolume(<span class=\"hljs-string\">&#x27;filepath&#x27;</span>, &#123;<span class=\"hljs-string\">&quot;singleFile&quot;</span>: <span class=\"hljs-literal\">True</span>&#125;)<br><br><span class=\"hljs-comment\"># 直接调用3DSlicer的导入数据模块，但不能得到用户选择的文件路径</span><br>slicer.util.openAddDataDialog()<br></code></pre></td></tr></table></figure>\n\n<p>这三种方法导入之后，都会自动显示到右侧窗口，覆盖之前显示的内容。</p>\n<p>针对前两种方法，要获得用户选择的文件需要使用3DSlicer自带的 <strong>qt</strong> 库，这里的qt库不是一般我们在python中使用的 <strong>pyqt</strong> 库，一开始没有找到这个库，以为需要导入 <strong>pyqt</strong>，但是 <strong>pyqt</strong> 的函数都需要定义在一个继承自qt的库，这里不满足这个条件，之后在<a href=\"https://discourse.slicer.org/t/opendialog-does-not-load-node-into-scene/23874\">论坛讨论</a>中找到了解决方法：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">import</span> qt<br><br>d = qt.QFileDialog()<br>d.<span class=\"hljs-built_in\">exec</span>()<br>slicer.util.loadVolume(d.selectedFiles()[<span class=\"hljs-number\">0</span>])<br></code></pre></td></tr></table></figure>\n\n<p>这里其实本来也有3DSlicer封装好的函数，用来打开文件浏览器，</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># openDialog()方法，但是这个函数暂时出了bug，在写文章一周前才在源码层面解决，所以就用上面那种方法。</span><br><span class=\"hljs-keyword\">import</span> slicer<br><br> io = slicer.app.ioManager()<br> params = &#123;&#125;<br> io.openDialog(<span class=\"hljs-string\">&quot;VolumeFile&quot;</span>, slicer.qSlicerFileDialog.Read, params)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3）显示图像实现\"><a href=\"#3）显示图像实现\" class=\"headerlink\" title=\"3）显示图像实现\"></a><strong>3）显示图像实现</strong></h3><p><img src=\"/article_img/2022-06-20-18-05-00.png\"></p>\n<p>在3DSlicer中，其右侧的窗口不能直接显示jpeg，png等等图片，需要先 <strong>Load</strong> 也就是上述的导入，在导入之后，会自动将图片显示在右侧，就算不是三维图像也会在 <strong>yellow</strong> 层和 <strong>Green</strong> 层（也就是三视图的另外两个方向），所以需要自定义显示的窗口</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 显示到红色窗口</span><br>red_logic = slicer.app.layoutManager().sliceWidget(<span class=\"hljs-string\">&quot;Red&quot;</span>).sliceLogic()<br>red_logic.GetSliceCompositeNode().SetBackgroundVolumeID(VolumeName.GetID())<br><span class=\"hljs-comment\"># 将图像移到窗口中间，相当于点击上图中的Reset field of view</span><br>slicer.util.resetSliceViews()<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-06-20-18-11-02.png\"></p>\n<p>希望实现的效果如上图，左侧是原始图像，右侧是处理之后的图像。但是 <strong>yellow</strong> 窗口默认方向是 <strong>sagittal</strong> 用如下代码进行更改</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-comment\"># 改变黄色窗口的显示方向</span><br>slice_node = slicer.app.layoutManager().sliceWidget(<span class=\"hljs-string\">&quot;Yellow&quot;</span>).mrmlSliceNode()<br>slice_to_ras = slice_node.GetSliceToRAS()<br>transform = vtk.vtkTransform()<br>transform.SetMatrix(slice_to_ras)<br>transform.RotateX(<span class=\"hljs-number\">90</span>)<br>transform.RotateZ(<span class=\"hljs-number\">90</span>)<br>slice_to_ras.DeepCopy(transform.GetMatrix())<br>slice_node.UpdateMatrices()<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4）显示图像实现\"><a href=\"#4）显示图像实现\" class=\"headerlink\" title=\"4）显示图像实现\"></a><strong>4）显示图像实现</strong></h3>"},{"title":"Blender快捷键总结","date":"2023-02-23T16:00:00.000Z","index_img":"/img/bg/Blender_cover.jpg","_content":"\nBlender快捷键总结\n<!-- more -->\n\n# 常用快捷键\n\n1. **鼠标中键**： 旋转视角\n2. **鼠标中键+shift**： 平移视角\n3. **tab**： 进入编辑模式\n4. **选中+1/2/3**： 分别对物体的点/线/面进行操作\n5. **alt+z*： 透视模式选择\n6. **~**： 切换视图（顶视图/左视图等等） \n7. **shift+s**： 游标菜单（移动物体轴心的方法：先移动游标，再退出编辑模式右键物体，将轴心移动到游标）\n8. **shift+a**： 添加物体\n9.  **g+z/x/y**： 沿x/y/z轴移动（按住ctrl标准距离移动）\n10. **ctrl+b**： 倒角（使用滚轮细化倒角）\n11. **ctrl+r**： 添加环线\n12. **alt+鼠标点击面/线**： 选择一圈所有的面/线\n13. **选中+s**： 缩放\n14. **选中面+i**： InsertFace插入面\n15. **选中一圈边+f**： 填充面\n16. **选中点+j**： 连线\n17. **ctrl+a**： 应用菜单（如应用缩放）\n18. **alt+s**： 法线缩放（做尾巴用）","source":"_posts/Blender常用快捷键.md","raw":"---\ntitle: Blender快捷键总结\ndate: 2023-02-24\nindex_img: \"/img/bg/Blender_cover.jpg\"\ntags: [Blender]\ncategories: \n   -[笔记]\n---\n\nBlender快捷键总结\n<!-- more -->\n\n# 常用快捷键\n\n1. **鼠标中键**： 旋转视角\n2. **鼠标中键+shift**： 平移视角\n3. **tab**： 进入编辑模式\n4. **选中+1/2/3**： 分别对物体的点/线/面进行操作\n5. **alt+z*： 透视模式选择\n6. **~**： 切换视图（顶视图/左视图等等） \n7. **shift+s**： 游标菜单（移动物体轴心的方法：先移动游标，再退出编辑模式右键物体，将轴心移动到游标）\n8. **shift+a**： 添加物体\n9.  **g+z/x/y**： 沿x/y/z轴移动（按住ctrl标准距离移动）\n10. **ctrl+b**： 倒角（使用滚轮细化倒角）\n11. **ctrl+r**： 添加环线\n12. **alt+鼠标点击面/线**： 选择一圈所有的面/线\n13. **选中+s**： 缩放\n14. **选中面+i**： InsertFace插入面\n15. **选中一圈边+f**： 填充面\n16. **选中点+j**： 连线\n17. **ctrl+a**： 应用菜单（如应用缩放）\n18. **alt+s**： 法线缩放（做尾巴用）","slug":"Blender常用快捷键","published":1,"updated":"2023-03-17T07:07:55.624Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglk0006w0jecfsj7o2h","content":"<p>Blender快捷键总结</p>\n<span id=\"more\"></span>\n\n<h1 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h1><ol>\n<li><strong>鼠标中键</strong>： 旋转视角</li>\n<li><strong>鼠标中键+shift</strong>： 平移视角</li>\n<li><strong>tab</strong>： 进入编辑模式</li>\n<li><strong>选中+1&#x2F;2&#x2F;3</strong>： 分别对物体的点&#x2F;线&#x2F;面进行操作</li>\n<li>*<em>alt+z</em>： 透视模式选择</li>\n<li>**~**： 切换视图（顶视图&#x2F;左视图等等） </li>\n<li><strong>shift+s</strong>： 游标菜单（移动物体轴心的方法：先移动游标，再退出编辑模式右键物体，将轴心移动到游标）</li>\n<li><strong>shift+a</strong>： 添加物体</li>\n<li><strong>g+z&#x2F;x&#x2F;y</strong>： 沿x&#x2F;y&#x2F;z轴移动（按住ctrl标准距离移动）</li>\n<li><strong>ctrl+b</strong>： 倒角（使用滚轮细化倒角）</li>\n<li><strong>ctrl+r</strong>： 添加环线</li>\n<li><strong>alt+鼠标点击面&#x2F;线</strong>： 选择一圈所有的面&#x2F;线</li>\n<li><strong>选中+s</strong>： 缩放</li>\n<li><strong>选中面+i</strong>： InsertFace插入面</li>\n<li><strong>选中一圈边+f</strong>： 填充面</li>\n<li><strong>选中点+j</strong>： 连线</li>\n<li><strong>ctrl+a</strong>： 应用菜单（如应用缩放）</li>\n<li><strong>alt+s</strong>： 法线缩放（做尾巴用）</li>\n</ol>\n","site":{"data":{}},"wordcount":388,"excerpt":"<p>Blender快捷键总结</p>","more":"<h1 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h1><ol>\n<li><strong>鼠标中键</strong>： 旋转视角</li>\n<li><strong>鼠标中键+shift</strong>： 平移视角</li>\n<li><strong>tab</strong>： 进入编辑模式</li>\n<li><strong>选中+1&#x2F;2&#x2F;3</strong>： 分别对物体的点&#x2F;线&#x2F;面进行操作</li>\n<li>*<em>alt+z</em>： 透视模式选择</li>\n<li>**~**： 切换视图（顶视图&#x2F;左视图等等） </li>\n<li><strong>shift+s</strong>： 游标菜单（移动物体轴心的方法：先移动游标，再退出编辑模式右键物体，将轴心移动到游标）</li>\n<li><strong>shift+a</strong>： 添加物体</li>\n<li><strong>g+z&#x2F;x&#x2F;y</strong>： 沿x&#x2F;y&#x2F;z轴移动（按住ctrl标准距离移动）</li>\n<li><strong>ctrl+b</strong>： 倒角（使用滚轮细化倒角）</li>\n<li><strong>ctrl+r</strong>： 添加环线</li>\n<li><strong>alt+鼠标点击面&#x2F;线</strong>： 选择一圈所有的面&#x2F;线</li>\n<li><strong>选中+s</strong>： 缩放</li>\n<li><strong>选中面+i</strong>： InsertFace插入面</li>\n<li><strong>选中一圈边+f</strong>： 填充面</li>\n<li><strong>选中点+j</strong>： 连线</li>\n<li><strong>ctrl+a</strong>： 应用菜单（如应用缩放）</li>\n<li><strong>alt+s</strong>： 法线缩放（做尾巴用）</li>\n</ol>"},{"title":"Games101-1-线代基础","date":"2022-07-19T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-1-线代基础\n<!-- more -->\n\n# Games101现代计算机图形学入门-2\n\n# 线性代数基础知识\n\n## 点乘\n\n### 点乘计算方法\n![](/article_img/2022-07-21-13-46-46.png)\n\n点乘常用来计算两个向量间的**夹角**\n\n![](/article_img/2022-07-21-13-53-30.png)\n\n点乘常用来计算一个向量在另一个向量上的**投影**，借助这个可以将向量进行分解\n\n![](/article_img/2022-07-21-13-55-49.png)\n\n判断**前和后**：点乘正值表示在前，点乘负值表示在后，点乘0表示垂直\n\n判断两个向量的**接近程度**：越接近点乘值越接近1，越远离点乘值越接近-1（都是单位向量）\n\n![](/article_img/2022-07-21-14-00-29.png)\n\n## 叉乘\n\n### **右手定则**\n\n用来判断结果向量的方向\n\n![](/article_img/2022-07-21-14-08-35.png)\n\n### 叉乘运算规律\n\n![](/article_img/2022-07-21-14-10-55.png)\n\n### 叉乘在代数中的计算法则\n\n![](/article_img/2022-07-21-14-12-24.png)\n\n### 叉乘的作用\n\n1. 判断左和右： 正左负右\n2. 判定内与外\n    ![](/article_img/2022-07-21-14-15-24.png)\n\n## 矩阵\n\n1. 矩阵的乘法\n2. 矩阵的转置\n3. 单位矩阵和逆矩阵\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)","source":"_posts/Games101-1-线代基础.md","raw":"---\ntitle: Games101-1-线代基础\ndate: 2022-07-20\nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-1-线代基础\n<!-- more -->\n\n# Games101现代计算机图形学入门-2\n\n# 线性代数基础知识\n\n## 点乘\n\n### 点乘计算方法\n![](/article_img/2022-07-21-13-46-46.png)\n\n点乘常用来计算两个向量间的**夹角**\n\n![](/article_img/2022-07-21-13-53-30.png)\n\n点乘常用来计算一个向量在另一个向量上的**投影**，借助这个可以将向量进行分解\n\n![](/article_img/2022-07-21-13-55-49.png)\n\n判断**前和后**：点乘正值表示在前，点乘负值表示在后，点乘0表示垂直\n\n判断两个向量的**接近程度**：越接近点乘值越接近1，越远离点乘值越接近-1（都是单位向量）\n\n![](/article_img/2022-07-21-14-00-29.png)\n\n## 叉乘\n\n### **右手定则**\n\n用来判断结果向量的方向\n\n![](/article_img/2022-07-21-14-08-35.png)\n\n### 叉乘运算规律\n\n![](/article_img/2022-07-21-14-10-55.png)\n\n### 叉乘在代数中的计算法则\n\n![](/article_img/2022-07-21-14-12-24.png)\n\n### 叉乘的作用\n\n1. 判断左和右： 正左负右\n2. 判定内与外\n    ![](/article_img/2022-07-21-14-15-24.png)\n\n## 矩阵\n\n1. 矩阵的乘法\n2. 矩阵的转置\n3. 单位矩阵和逆矩阵\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)","slug":"Games101-1-线代基础","published":1,"updated":"2022-10-14T05:26:18.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglk0007w0je4nht6ilw","content":"<p>Games101-1-线代基础</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Games101现代计算机图形学入门-2\"><a href=\"#Games101现代计算机图形学入门-2\" class=\"headerlink\" title=\"Games101现代计算机图形学入门-2\"></a>Games101现代计算机图形学入门-2</h1><h1 id=\"线性代数基础知识\"><a href=\"#线性代数基础知识\" class=\"headerlink\" title=\"线性代数基础知识\"></a>线性代数基础知识</h1><h2 id=\"点乘\"><a href=\"#点乘\" class=\"headerlink\" title=\"点乘\"></a>点乘</h2><h3 id=\"点乘计算方法\"><a href=\"#点乘计算方法\" class=\"headerlink\" title=\"点乘计算方法\"></a>点乘计算方法</h3><p><img src=\"/article_img/2022-07-21-13-46-46.png\"></p>\n<p>点乘常用来计算两个向量间的<strong>夹角</strong></p>\n<p><img src=\"/article_img/2022-07-21-13-53-30.png\"></p>\n<p>点乘常用来计算一个向量在另一个向量上的<strong>投影</strong>，借助这个可以将向量进行分解</p>\n<p><img src=\"/article_img/2022-07-21-13-55-49.png\"></p>\n<p>判断<strong>前和后</strong>：点乘正值表示在前，点乘负值表示在后，点乘0表示垂直</p>\n<p>判断两个向量的<strong>接近程度</strong>：越接近点乘值越接近1，越远离点乘值越接近-1（都是单位向量）</p>\n<p><img src=\"/article_img/2022-07-21-14-00-29.png\"></p>\n<h2 id=\"叉乘\"><a href=\"#叉乘\" class=\"headerlink\" title=\"叉乘\"></a>叉乘</h2><h3 id=\"右手定则\"><a href=\"#右手定则\" class=\"headerlink\" title=\"右手定则\"></a><strong>右手定则</strong></h3><p>用来判断结果向量的方向</p>\n<p><img src=\"/article_img/2022-07-21-14-08-35.png\"></p>\n<h3 id=\"叉乘运算规律\"><a href=\"#叉乘运算规律\" class=\"headerlink\" title=\"叉乘运算规律\"></a>叉乘运算规律</h3><p><img src=\"/article_img/2022-07-21-14-10-55.png\"></p>\n<h3 id=\"叉乘在代数中的计算法则\"><a href=\"#叉乘在代数中的计算法则\" class=\"headerlink\" title=\"叉乘在代数中的计算法则\"></a>叉乘在代数中的计算法则</h3><p><img src=\"/article_img/2022-07-21-14-12-24.png\"></p>\n<h3 id=\"叉乘的作用\"><a href=\"#叉乘的作用\" class=\"headerlink\" title=\"叉乘的作用\"></a>叉乘的作用</h3><ol>\n<li>判断左和右： 正左负右</li>\n<li>判定内与外<br> <img src=\"/article_img/2022-07-21-14-15-24.png\"></li>\n</ol>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h2><ol>\n<li>矩阵的乘法</li>\n<li>矩阵的转置</li>\n<li>单位矩阵和逆矩阵</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a></p>\n<p><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a></p>\n","site":{"data":{}},"wordcount":258,"excerpt":"<p>Games101-1-线代基础</p>","more":"<h1 id=\"Games101现代计算机图形学入门-2\"><a href=\"#Games101现代计算机图形学入门-2\" class=\"headerlink\" title=\"Games101现代计算机图形学入门-2\"></a>Games101现代计算机图形学入门-2</h1><h1 id=\"线性代数基础知识\"><a href=\"#线性代数基础知识\" class=\"headerlink\" title=\"线性代数基础知识\"></a>线性代数基础知识</h1><h2 id=\"点乘\"><a href=\"#点乘\" class=\"headerlink\" title=\"点乘\"></a>点乘</h2><h3 id=\"点乘计算方法\"><a href=\"#点乘计算方法\" class=\"headerlink\" title=\"点乘计算方法\"></a>点乘计算方法</h3><p><img src=\"/article_img/2022-07-21-13-46-46.png\"></p>\n<p>点乘常用来计算两个向量间的<strong>夹角</strong></p>\n<p><img src=\"/article_img/2022-07-21-13-53-30.png\"></p>\n<p>点乘常用来计算一个向量在另一个向量上的<strong>投影</strong>，借助这个可以将向量进行分解</p>\n<p><img src=\"/article_img/2022-07-21-13-55-49.png\"></p>\n<p>判断<strong>前和后</strong>：点乘正值表示在前，点乘负值表示在后，点乘0表示垂直</p>\n<p>判断两个向量的<strong>接近程度</strong>：越接近点乘值越接近1，越远离点乘值越接近-1（都是单位向量）</p>\n<p><img src=\"/article_img/2022-07-21-14-00-29.png\"></p>\n<h2 id=\"叉乘\"><a href=\"#叉乘\" class=\"headerlink\" title=\"叉乘\"></a>叉乘</h2><h3 id=\"右手定则\"><a href=\"#右手定则\" class=\"headerlink\" title=\"右手定则\"></a><strong>右手定则</strong></h3><p>用来判断结果向量的方向</p>\n<p><img src=\"/article_img/2022-07-21-14-08-35.png\"></p>\n<h3 id=\"叉乘运算规律\"><a href=\"#叉乘运算规律\" class=\"headerlink\" title=\"叉乘运算规律\"></a>叉乘运算规律</h3><p><img src=\"/article_img/2022-07-21-14-10-55.png\"></p>\n<h3 id=\"叉乘在代数中的计算法则\"><a href=\"#叉乘在代数中的计算法则\" class=\"headerlink\" title=\"叉乘在代数中的计算法则\"></a>叉乘在代数中的计算法则</h3><p><img src=\"/article_img/2022-07-21-14-12-24.png\"></p>\n<h3 id=\"叉乘的作用\"><a href=\"#叉乘的作用\" class=\"headerlink\" title=\"叉乘的作用\"></a>叉乘的作用</h3><ol>\n<li>判断左和右： 正左负右</li>\n<li>判定内与外<br> <img src=\"/article_img/2022-07-21-14-15-24.png\"></li>\n</ol>\n<h2 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h2><ol>\n<li>矩阵的乘法</li>\n<li>矩阵的转置</li>\n<li>单位矩阵和逆矩阵</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a></p>\n<p><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a></p>"},{"title":"Games101-10-渲染中的高级话题","date":"2022-10-21T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-10-渲染中的高级话题\n<!-- more -->\n\n# 高级光线传播\n\n1. 无偏的光线传播方法  \n   双向路径追踪（BDPT）  \n   Metropolis光线传播（MLT）\n2. 有偏的光线传播方法  \n   Photon mapping（光子映射）  \n   Vertex connection and merging（VCM）\n3. Instant radiosity（VPL / many light methods）\n\n无偏和有偏的区别：  \n无偏方法没有任何系统错误；无论采样数是多少，无偏方法的期望永远是正确的值。  \n有偏方法只有在采样数趋于无穷时，期望才收敛于真实值。\n\n## Bidirectional Path Tracing(BDPT)\n\n![](/article_img/2022-10-22-14-07-59.png)\n\n![](/article_img/2022-10-22-14-08-44.png)\n\n适用于光线传输很复杂的场景，如上图所示，直接光照只在左上角，而整个场景基本都是由间接光照照亮的。和之前在[路径追踪](Games101-8-路径追踪.md)中要采取**重要性采样**的原因类似：从相机发出的路径难以到达光源，导致大量的路径浪费，产生严重的噪声。\n\n## Metropolis Light Transport(MLT)\n\nMetropolis是个人名  \nMLT是马尔可夫链蒙特卡罗（Markov Chain Monte Carlo / MCMC）的应用：根据当前采样找到下一次采样\n\n![](/article_img/2022-10-22-14-17-30.png)\n\n非常适用于在局部探索复杂的光路，一旦找到一条光路，就会生成一堆光路，从而相当于没有浪费采样。\n\n![](/article_img/2022-10-22-14-19-42.png)\n\n![](/article_img/2022-10-22-14-20-18.png)\n\n缺点：  \n难以估计收敛速率，可能计算了一天还没有明显进步。每个像素的收敛速率不同从而导致生成的图片有些“脏”，从而也不能渲染动画，因为每一帧的噪声都不同。\n\n## Photon Mapping（光子映射）\n\n一种有偏的两步方法，非常适合计算Specular-Diffuse-Specular (SDS) 路径以及生成焦散（caustics）现象。\n\n![](/article_img/2022-10-22-14-25-50.png)\n\n![](/article_img/2022-10-22-14-27-03.png)\n\n![](/article_img/2022-10-22-14-27-38.png)\n\n**光子映射步骤**：  \n1. 从光源发射光子，光子在场景中不断弹射直到碰到漫反射物体，之后将哪里有光子记录下来；\n2. 从相机发射sub-paths，同样在场景中弹射直到碰到漫反射物体，统计sub-paths到达的每个着色点周围的 N 个光子，计算这 N 个光子覆盖的区域面积。\n\n显然，单位面积内光子越多，这个着色点就应该越亮。\n\n![](/article_img/2022-10-22-14-35-10.png)\n\n只有面积无限小的时候，才能收敛于真实值，因此光子映射是有偏但一致的方法。\n\n![](/article_img/2022-10-22-14-36-55.png)\n\n为什么不确定一个面积统计光子数量，而要确定N个光子，计算覆盖面积？\n\n因为如果确定面积统计光子，这个面积不会随着光源发出光子的数量增加而减小，也就不会有一个趋向于无穷小的过程。\n\n## Vertex Connection and Merging\n\n一种BDPT和光子映射的组合。\n\n![](/article_img/2022-10-22-14-40-09.png)\n\n## Instant Radiosity（IR）\n\n有时也叫做多光源方法（Many-light approaches）\n\n![](/article_img/2022-10-22-14-41-23.png)\n\n![](/article_img/2022-10-22-14-42-29.png)\n\n\n# 高级外观建模\n\n1. 非表面模型  \n   Participating media（雾，云）  \n   头发/皮毛/纤维（BCSFDF）  \n   Granular material（颗粒材质）\n2. 表面模型  \n   Translucent material（BSSRDF）半透明材质  \n   布  \n   Detailed material\n3. 程序化外观\n\n## Participating Media（雾）\n\n![](/article_img/2022-10-22-14-51-07.png)\n\n![](/article_img/2022-10-22-14-50-09.png)\n\n![](/article_img/2022-10-22-14-50-17.png)\n\n![](/article_img/2022-10-22-14-50-26.png)\n\n## 头发/皮毛/纤维\n\nKajiya-Kay Model\n\n![](/article_img/2022-10-22-14-55-15.png)\n\nMarschner Model\n\n将头发看作一根玻璃柱，有三种类型的光线：直接反射光（R），两次折射（TT），折射反射再折射（TRT）\n\n![](/article_img/2022-10-22-14-55-32.png)\n\n![](/article_img/2022-10-22-14-55-42.png)\n\n![](/article_img/2022-10-22-14-57-34.png)\n\nMarschner模型已经能取得很不错的效果。\n\n但是将人类头发的模型（Marschner模型）应用于动物皮毛不能得到很好的效果\n\n![](/article_img/2022-10-22-14-59-42.png)\n\n因为动物的毛发中有很粗的Medulla对光线进行散射\n\n![](/article_img/2022-10-22-14-58-49.png)\n\n为了模拟真实的毛发结构，提出了双层玻璃柱模型（就是闫大神提出的），增加了medulla造成的散射。\n\n![](/article_img/2022-10-22-15-01-06.png)\n\n![](/article_img/2022-10-22-15-03-00.png)\n\n![](/article_img/2022-10-22-15-03-45.png)\n\n## Granular Material（颗粒材质）\n\n![](/article_img/2022-10-22-15-05-34.png)\n\n![](/article_img/2022-10-22-15-06-05.png)\n\n## 半透明材质\n\n![](/article_img/2022-10-22-15-06-25.png)\n\n次表面散射：  \n光线射入半透明物体后有可能会从任意方向射出。\n\n![](/article_img/2022-10-22-15-17-26.png)\n\n![](/article_img/2022-10-22-15-20-05.png)\n\n![](/article_img/2022-10-22-15-22-02.png)\n\n![](/article_img/2022-10-22-15-22-42.png)\n\nBSSRDF还适用于模拟人类皮肤\n\n![](/article_img/2022-10-22-15-23-45.png)\n\n## 布料\n\n![](/article_img/2022-10-22-15-26-34.png)\n\n## 表面细节\n\n真实的物体表面不会像渲染结果一样完美\n\n![](/article_img/2022-10-22-15-27-38.png)\n\n![](/article_img/2022-10-22-15-29-17.png)\n\n![](/article_img/2022-10-22-15-29-34.png)\n\n![](/article_img/2022-10-22-15-30-36.png)\n\n## 程序化外观\n\n利用噪声函数，模拟物体材质效果，每次要渲染的时候再计算应该如何显示。\n\n![](/article_img/2022-10-22-15-32-53.png)\n\n还可以定义3D噪声函数，来模拟物体内部的材质。\n\n![](/article_img/2022-10-22-15-32-59.png)\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=18&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_18.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_18.pdf)  \n  \n","source":"_posts/Games101-10-渲染中的高级话题.md","raw":"---\ntitle: Games101-10-渲染中的高级话题\ndate: 2022-10-22\nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-10-渲染中的高级话题\n<!-- more -->\n\n# 高级光线传播\n\n1. 无偏的光线传播方法  \n   双向路径追踪（BDPT）  \n   Metropolis光线传播（MLT）\n2. 有偏的光线传播方法  \n   Photon mapping（光子映射）  \n   Vertex connection and merging（VCM）\n3. Instant radiosity（VPL / many light methods）\n\n无偏和有偏的区别：  \n无偏方法没有任何系统错误；无论采样数是多少，无偏方法的期望永远是正确的值。  \n有偏方法只有在采样数趋于无穷时，期望才收敛于真实值。\n\n## Bidirectional Path Tracing(BDPT)\n\n![](/article_img/2022-10-22-14-07-59.png)\n\n![](/article_img/2022-10-22-14-08-44.png)\n\n适用于光线传输很复杂的场景，如上图所示，直接光照只在左上角，而整个场景基本都是由间接光照照亮的。和之前在[路径追踪](Games101-8-路径追踪.md)中要采取**重要性采样**的原因类似：从相机发出的路径难以到达光源，导致大量的路径浪费，产生严重的噪声。\n\n## Metropolis Light Transport(MLT)\n\nMetropolis是个人名  \nMLT是马尔可夫链蒙特卡罗（Markov Chain Monte Carlo / MCMC）的应用：根据当前采样找到下一次采样\n\n![](/article_img/2022-10-22-14-17-30.png)\n\n非常适用于在局部探索复杂的光路，一旦找到一条光路，就会生成一堆光路，从而相当于没有浪费采样。\n\n![](/article_img/2022-10-22-14-19-42.png)\n\n![](/article_img/2022-10-22-14-20-18.png)\n\n缺点：  \n难以估计收敛速率，可能计算了一天还没有明显进步。每个像素的收敛速率不同从而导致生成的图片有些“脏”，从而也不能渲染动画，因为每一帧的噪声都不同。\n\n## Photon Mapping（光子映射）\n\n一种有偏的两步方法，非常适合计算Specular-Diffuse-Specular (SDS) 路径以及生成焦散（caustics）现象。\n\n![](/article_img/2022-10-22-14-25-50.png)\n\n![](/article_img/2022-10-22-14-27-03.png)\n\n![](/article_img/2022-10-22-14-27-38.png)\n\n**光子映射步骤**：  \n1. 从光源发射光子，光子在场景中不断弹射直到碰到漫反射物体，之后将哪里有光子记录下来；\n2. 从相机发射sub-paths，同样在场景中弹射直到碰到漫反射物体，统计sub-paths到达的每个着色点周围的 N 个光子，计算这 N 个光子覆盖的区域面积。\n\n显然，单位面积内光子越多，这个着色点就应该越亮。\n\n![](/article_img/2022-10-22-14-35-10.png)\n\n只有面积无限小的时候，才能收敛于真实值，因此光子映射是有偏但一致的方法。\n\n![](/article_img/2022-10-22-14-36-55.png)\n\n为什么不确定一个面积统计光子数量，而要确定N个光子，计算覆盖面积？\n\n因为如果确定面积统计光子，这个面积不会随着光源发出光子的数量增加而减小，也就不会有一个趋向于无穷小的过程。\n\n## Vertex Connection and Merging\n\n一种BDPT和光子映射的组合。\n\n![](/article_img/2022-10-22-14-40-09.png)\n\n## Instant Radiosity（IR）\n\n有时也叫做多光源方法（Many-light approaches）\n\n![](/article_img/2022-10-22-14-41-23.png)\n\n![](/article_img/2022-10-22-14-42-29.png)\n\n\n# 高级外观建模\n\n1. 非表面模型  \n   Participating media（雾，云）  \n   头发/皮毛/纤维（BCSFDF）  \n   Granular material（颗粒材质）\n2. 表面模型  \n   Translucent material（BSSRDF）半透明材质  \n   布  \n   Detailed material\n3. 程序化外观\n\n## Participating Media（雾）\n\n![](/article_img/2022-10-22-14-51-07.png)\n\n![](/article_img/2022-10-22-14-50-09.png)\n\n![](/article_img/2022-10-22-14-50-17.png)\n\n![](/article_img/2022-10-22-14-50-26.png)\n\n## 头发/皮毛/纤维\n\nKajiya-Kay Model\n\n![](/article_img/2022-10-22-14-55-15.png)\n\nMarschner Model\n\n将头发看作一根玻璃柱，有三种类型的光线：直接反射光（R），两次折射（TT），折射反射再折射（TRT）\n\n![](/article_img/2022-10-22-14-55-32.png)\n\n![](/article_img/2022-10-22-14-55-42.png)\n\n![](/article_img/2022-10-22-14-57-34.png)\n\nMarschner模型已经能取得很不错的效果。\n\n但是将人类头发的模型（Marschner模型）应用于动物皮毛不能得到很好的效果\n\n![](/article_img/2022-10-22-14-59-42.png)\n\n因为动物的毛发中有很粗的Medulla对光线进行散射\n\n![](/article_img/2022-10-22-14-58-49.png)\n\n为了模拟真实的毛发结构，提出了双层玻璃柱模型（就是闫大神提出的），增加了medulla造成的散射。\n\n![](/article_img/2022-10-22-15-01-06.png)\n\n![](/article_img/2022-10-22-15-03-00.png)\n\n![](/article_img/2022-10-22-15-03-45.png)\n\n## Granular Material（颗粒材质）\n\n![](/article_img/2022-10-22-15-05-34.png)\n\n![](/article_img/2022-10-22-15-06-05.png)\n\n## 半透明材质\n\n![](/article_img/2022-10-22-15-06-25.png)\n\n次表面散射：  \n光线射入半透明物体后有可能会从任意方向射出。\n\n![](/article_img/2022-10-22-15-17-26.png)\n\n![](/article_img/2022-10-22-15-20-05.png)\n\n![](/article_img/2022-10-22-15-22-02.png)\n\n![](/article_img/2022-10-22-15-22-42.png)\n\nBSSRDF还适用于模拟人类皮肤\n\n![](/article_img/2022-10-22-15-23-45.png)\n\n## 布料\n\n![](/article_img/2022-10-22-15-26-34.png)\n\n## 表面细节\n\n真实的物体表面不会像渲染结果一样完美\n\n![](/article_img/2022-10-22-15-27-38.png)\n\n![](/article_img/2022-10-22-15-29-17.png)\n\n![](/article_img/2022-10-22-15-29-34.png)\n\n![](/article_img/2022-10-22-15-30-36.png)\n\n## 程序化外观\n\n利用噪声函数，模拟物体材质效果，每次要渲染的时候再计算应该如何显示。\n\n![](/article_img/2022-10-22-15-32-53.png)\n\n还可以定义3D噪声函数，来模拟物体内部的材质。\n\n![](/article_img/2022-10-22-15-32-59.png)\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=18&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_18.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_18.pdf)  \n  \n","slug":"Games101-10-渲染中的高级话题","published":1,"updated":"2022-10-22T07:36:24.684Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigln000bw0je4mvv08u1","content":"<p>Games101-10-渲染中的高级话题</p>\n<span id=\"more\"></span>\n\n<h1 id=\"高级光线传播\"><a href=\"#高级光线传播\" class=\"headerlink\" title=\"高级光线传播\"></a>高级光线传播</h1><ol>\n<li>无偏的光线传播方法<br>双向路径追踪（BDPT）<br>Metropolis光线传播（MLT）</li>\n<li>有偏的光线传播方法<br>Photon mapping（光子映射）<br>Vertex connection and merging（VCM）</li>\n<li>Instant radiosity（VPL &#x2F; many light methods）</li>\n</ol>\n<p>无偏和有偏的区别：<br>无偏方法没有任何系统错误；无论采样数是多少，无偏方法的期望永远是正确的值。<br>有偏方法只有在采样数趋于无穷时，期望才收敛于真实值。</p>\n<h2 id=\"Bidirectional-Path-Tracing-BDPT\"><a href=\"#Bidirectional-Path-Tracing-BDPT\" class=\"headerlink\" title=\"Bidirectional Path Tracing(BDPT)\"></a>Bidirectional Path Tracing(BDPT)</h2><p><img src=\"/article_img/2022-10-22-14-07-59.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-08-44.png\"></p>\n<p>适用于光线传输很复杂的场景，如上图所示，直接光照只在左上角，而整个场景基本都是由间接光照照亮的。和之前在<a href=\"Games101-8-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA.md\">路径追踪</a>中要采取<strong>重要性采样</strong>的原因类似：从相机发出的路径难以到达光源，导致大量的路径浪费，产生严重的噪声。</p>\n<h2 id=\"Metropolis-Light-Transport-MLT\"><a href=\"#Metropolis-Light-Transport-MLT\" class=\"headerlink\" title=\"Metropolis Light Transport(MLT)\"></a>Metropolis Light Transport(MLT)</h2><p>Metropolis是个人名<br>MLT是马尔可夫链蒙特卡罗（Markov Chain Monte Carlo &#x2F; MCMC）的应用：根据当前采样找到下一次采样</p>\n<p><img src=\"/article_img/2022-10-22-14-17-30.png\"></p>\n<p>非常适用于在局部探索复杂的光路，一旦找到一条光路，就会生成一堆光路，从而相当于没有浪费采样。</p>\n<p><img src=\"/article_img/2022-10-22-14-19-42.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-20-18.png\"></p>\n<p>缺点：<br>难以估计收敛速率，可能计算了一天还没有明显进步。每个像素的收敛速率不同从而导致生成的图片有些“脏”，从而也不能渲染动画，因为每一帧的噪声都不同。</p>\n<h2 id=\"Photon-Mapping（光子映射）\"><a href=\"#Photon-Mapping（光子映射）\" class=\"headerlink\" title=\"Photon Mapping（光子映射）\"></a>Photon Mapping（光子映射）</h2><p>一种有偏的两步方法，非常适合计算Specular-Diffuse-Specular (SDS) 路径以及生成焦散（caustics）现象。</p>\n<p><img src=\"/article_img/2022-10-22-14-25-50.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-27-03.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-27-38.png\"></p>\n<p><strong>光子映射步骤</strong>：  </p>\n<ol>\n<li>从光源发射光子，光子在场景中不断弹射直到碰到漫反射物体，之后将哪里有光子记录下来；</li>\n<li>从相机发射sub-paths，同样在场景中弹射直到碰到漫反射物体，统计sub-paths到达的每个着色点周围的 N 个光子，计算这 N 个光子覆盖的区域面积。</li>\n</ol>\n<p>显然，单位面积内光子越多，这个着色点就应该越亮。</p>\n<p><img src=\"/article_img/2022-10-22-14-35-10.png\"></p>\n<p>只有面积无限小的时候，才能收敛于真实值，因此光子映射是有偏但一致的方法。</p>\n<p><img src=\"/article_img/2022-10-22-14-36-55.png\"></p>\n<p>为什么不确定一个面积统计光子数量，而要确定N个光子，计算覆盖面积？</p>\n<p>因为如果确定面积统计光子，这个面积不会随着光源发出光子的数量增加而减小，也就不会有一个趋向于无穷小的过程。</p>\n<h2 id=\"Vertex-Connection-and-Merging\"><a href=\"#Vertex-Connection-and-Merging\" class=\"headerlink\" title=\"Vertex Connection and Merging\"></a>Vertex Connection and Merging</h2><p>一种BDPT和光子映射的组合。</p>\n<p><img src=\"/article_img/2022-10-22-14-40-09.png\"></p>\n<h2 id=\"Instant-Radiosity（IR）\"><a href=\"#Instant-Radiosity（IR）\" class=\"headerlink\" title=\"Instant Radiosity（IR）\"></a>Instant Radiosity（IR）</h2><p>有时也叫做多光源方法（Many-light approaches）</p>\n<p><img src=\"/article_img/2022-10-22-14-41-23.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-42-29.png\"></p>\n<h1 id=\"高级外观建模\"><a href=\"#高级外观建模\" class=\"headerlink\" title=\"高级外观建模\"></a>高级外观建模</h1><ol>\n<li>非表面模型<br>Participating media（雾，云）<br>头发&#x2F;皮毛&#x2F;纤维（BCSFDF）<br>Granular material（颗粒材质）</li>\n<li>表面模型<br>Translucent material（BSSRDF）半透明材质<br>布<br>Detailed material</li>\n<li>程序化外观</li>\n</ol>\n<h2 id=\"Participating-Media（雾）\"><a href=\"#Participating-Media（雾）\" class=\"headerlink\" title=\"Participating Media（雾）\"></a>Participating Media（雾）</h2><p><img src=\"/article_img/2022-10-22-14-51-07.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-50-09.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-50-17.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-50-26.png\"></p>\n<h2 id=\"头发-x2F-皮毛-x2F-纤维\"><a href=\"#头发-x2F-皮毛-x2F-纤维\" class=\"headerlink\" title=\"头发&#x2F;皮毛&#x2F;纤维\"></a>头发&#x2F;皮毛&#x2F;纤维</h2><p>Kajiya-Kay Model</p>\n<p><img src=\"/article_img/2022-10-22-14-55-15.png\"></p>\n<p>Marschner Model</p>\n<p>将头发看作一根玻璃柱，有三种类型的光线：直接反射光（R），两次折射（TT），折射反射再折射（TRT）</p>\n<p><img src=\"/article_img/2022-10-22-14-55-32.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-55-42.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-57-34.png\"></p>\n<p>Marschner模型已经能取得很不错的效果。</p>\n<p>但是将人类头发的模型（Marschner模型）应用于动物皮毛不能得到很好的效果</p>\n<p><img src=\"/article_img/2022-10-22-14-59-42.png\"></p>\n<p>因为动物的毛发中有很粗的Medulla对光线进行散射</p>\n<p><img src=\"/article_img/2022-10-22-14-58-49.png\"></p>\n<p>为了模拟真实的毛发结构，提出了双层玻璃柱模型（就是闫大神提出的），增加了medulla造成的散射。</p>\n<p><img src=\"/article_img/2022-10-22-15-01-06.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-03-00.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-03-45.png\"></p>\n<h2 id=\"Granular-Material（颗粒材质）\"><a href=\"#Granular-Material（颗粒材质）\" class=\"headerlink\" title=\"Granular Material（颗粒材质）\"></a>Granular Material（颗粒材质）</h2><p><img src=\"/article_img/2022-10-22-15-05-34.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-06-05.png\"></p>\n<h2 id=\"半透明材质\"><a href=\"#半透明材质\" class=\"headerlink\" title=\"半透明材质\"></a>半透明材质</h2><p><img src=\"/article_img/2022-10-22-15-06-25.png\"></p>\n<p>次表面散射：<br>光线射入半透明物体后有可能会从任意方向射出。</p>\n<p><img src=\"/article_img/2022-10-22-15-17-26.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-20-05.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-22-02.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-22-42.png\"></p>\n<p>BSSRDF还适用于模拟人类皮肤</p>\n<p><img src=\"/article_img/2022-10-22-15-23-45.png\"></p>\n<h2 id=\"布料\"><a href=\"#布料\" class=\"headerlink\" title=\"布料\"></a>布料</h2><p><img src=\"/article_img/2022-10-22-15-26-34.png\"></p>\n<h2 id=\"表面细节\"><a href=\"#表面细节\" class=\"headerlink\" title=\"表面细节\"></a>表面细节</h2><p>真实的物体表面不会像渲染结果一样完美</p>\n<p><img src=\"/article_img/2022-10-22-15-27-38.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-29-17.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-29-34.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-30-36.png\"></p>\n<h2 id=\"程序化外观\"><a href=\"#程序化外观\" class=\"headerlink\" title=\"程序化外观\"></a>程序化外观</h2><p>利用噪声函数，模拟物体材质效果，每次要渲染的时候再计算应该如何显示。</p>\n<p><img src=\"/article_img/2022-10-22-15-32-53.png\"></p>\n<p>还可以定义3D噪声函数，来模拟物体内部的材质。</p>\n<p><img src=\"/article_img/2022-10-22-15-32-59.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=18&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_18.pdf\">GAMES101_Lecture_18.pdf</a>  </p>\n","site":{"data":{}},"wordcount":1649,"excerpt":"<p>Games101-10-渲染中的高级话题</p>","more":"<h1 id=\"高级光线传播\"><a href=\"#高级光线传播\" class=\"headerlink\" title=\"高级光线传播\"></a>高级光线传播</h1><ol>\n<li>无偏的光线传播方法<br>双向路径追踪（BDPT）<br>Metropolis光线传播（MLT）</li>\n<li>有偏的光线传播方法<br>Photon mapping（光子映射）<br>Vertex connection and merging（VCM）</li>\n<li>Instant radiosity（VPL &#x2F; many light methods）</li>\n</ol>\n<p>无偏和有偏的区别：<br>无偏方法没有任何系统错误；无论采样数是多少，无偏方法的期望永远是正确的值。<br>有偏方法只有在采样数趋于无穷时，期望才收敛于真实值。</p>\n<h2 id=\"Bidirectional-Path-Tracing-BDPT\"><a href=\"#Bidirectional-Path-Tracing-BDPT\" class=\"headerlink\" title=\"Bidirectional Path Tracing(BDPT)\"></a>Bidirectional Path Tracing(BDPT)</h2><p><img src=\"/article_img/2022-10-22-14-07-59.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-08-44.png\"></p>\n<p>适用于光线传输很复杂的场景，如上图所示，直接光照只在左上角，而整个场景基本都是由间接光照照亮的。和之前在<a href=\"Games101-8-%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA.md\">路径追踪</a>中要采取<strong>重要性采样</strong>的原因类似：从相机发出的路径难以到达光源，导致大量的路径浪费，产生严重的噪声。</p>\n<h2 id=\"Metropolis-Light-Transport-MLT\"><a href=\"#Metropolis-Light-Transport-MLT\" class=\"headerlink\" title=\"Metropolis Light Transport(MLT)\"></a>Metropolis Light Transport(MLT)</h2><p>Metropolis是个人名<br>MLT是马尔可夫链蒙特卡罗（Markov Chain Monte Carlo &#x2F; MCMC）的应用：根据当前采样找到下一次采样</p>\n<p><img src=\"/article_img/2022-10-22-14-17-30.png\"></p>\n<p>非常适用于在局部探索复杂的光路，一旦找到一条光路，就会生成一堆光路，从而相当于没有浪费采样。</p>\n<p><img src=\"/article_img/2022-10-22-14-19-42.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-20-18.png\"></p>\n<p>缺点：<br>难以估计收敛速率，可能计算了一天还没有明显进步。每个像素的收敛速率不同从而导致生成的图片有些“脏”，从而也不能渲染动画，因为每一帧的噪声都不同。</p>\n<h2 id=\"Photon-Mapping（光子映射）\"><a href=\"#Photon-Mapping（光子映射）\" class=\"headerlink\" title=\"Photon Mapping（光子映射）\"></a>Photon Mapping（光子映射）</h2><p>一种有偏的两步方法，非常适合计算Specular-Diffuse-Specular (SDS) 路径以及生成焦散（caustics）现象。</p>\n<p><img src=\"/article_img/2022-10-22-14-25-50.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-27-03.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-27-38.png\"></p>\n<p><strong>光子映射步骤</strong>：  </p>\n<ol>\n<li>从光源发射光子，光子在场景中不断弹射直到碰到漫反射物体，之后将哪里有光子记录下来；</li>\n<li>从相机发射sub-paths，同样在场景中弹射直到碰到漫反射物体，统计sub-paths到达的每个着色点周围的 N 个光子，计算这 N 个光子覆盖的区域面积。</li>\n</ol>\n<p>显然，单位面积内光子越多，这个着色点就应该越亮。</p>\n<p><img src=\"/article_img/2022-10-22-14-35-10.png\"></p>\n<p>只有面积无限小的时候，才能收敛于真实值，因此光子映射是有偏但一致的方法。</p>\n<p><img src=\"/article_img/2022-10-22-14-36-55.png\"></p>\n<p>为什么不确定一个面积统计光子数量，而要确定N个光子，计算覆盖面积？</p>\n<p>因为如果确定面积统计光子，这个面积不会随着光源发出光子的数量增加而减小，也就不会有一个趋向于无穷小的过程。</p>\n<h2 id=\"Vertex-Connection-and-Merging\"><a href=\"#Vertex-Connection-and-Merging\" class=\"headerlink\" title=\"Vertex Connection and Merging\"></a>Vertex Connection and Merging</h2><p>一种BDPT和光子映射的组合。</p>\n<p><img src=\"/article_img/2022-10-22-14-40-09.png\"></p>\n<h2 id=\"Instant-Radiosity（IR）\"><a href=\"#Instant-Radiosity（IR）\" class=\"headerlink\" title=\"Instant Radiosity（IR）\"></a>Instant Radiosity（IR）</h2><p>有时也叫做多光源方法（Many-light approaches）</p>\n<p><img src=\"/article_img/2022-10-22-14-41-23.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-42-29.png\"></p>\n<h1 id=\"高级外观建模\"><a href=\"#高级外观建模\" class=\"headerlink\" title=\"高级外观建模\"></a>高级外观建模</h1><ol>\n<li>非表面模型<br>Participating media（雾，云）<br>头发&#x2F;皮毛&#x2F;纤维（BCSFDF）<br>Granular material（颗粒材质）</li>\n<li>表面模型<br>Translucent material（BSSRDF）半透明材质<br>布<br>Detailed material</li>\n<li>程序化外观</li>\n</ol>\n<h2 id=\"Participating-Media（雾）\"><a href=\"#Participating-Media（雾）\" class=\"headerlink\" title=\"Participating Media（雾）\"></a>Participating Media（雾）</h2><p><img src=\"/article_img/2022-10-22-14-51-07.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-50-09.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-50-17.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-50-26.png\"></p>\n<h2 id=\"头发-x2F-皮毛-x2F-纤维\"><a href=\"#头发-x2F-皮毛-x2F-纤维\" class=\"headerlink\" title=\"头发&#x2F;皮毛&#x2F;纤维\"></a>头发&#x2F;皮毛&#x2F;纤维</h2><p>Kajiya-Kay Model</p>\n<p><img src=\"/article_img/2022-10-22-14-55-15.png\"></p>\n<p>Marschner Model</p>\n<p>将头发看作一根玻璃柱，有三种类型的光线：直接反射光（R），两次折射（TT），折射反射再折射（TRT）</p>\n<p><img src=\"/article_img/2022-10-22-14-55-32.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-55-42.png\"></p>\n<p><img src=\"/article_img/2022-10-22-14-57-34.png\"></p>\n<p>Marschner模型已经能取得很不错的效果。</p>\n<p>但是将人类头发的模型（Marschner模型）应用于动物皮毛不能得到很好的效果</p>\n<p><img src=\"/article_img/2022-10-22-14-59-42.png\"></p>\n<p>因为动物的毛发中有很粗的Medulla对光线进行散射</p>\n<p><img src=\"/article_img/2022-10-22-14-58-49.png\"></p>\n<p>为了模拟真实的毛发结构，提出了双层玻璃柱模型（就是闫大神提出的），增加了medulla造成的散射。</p>\n<p><img src=\"/article_img/2022-10-22-15-01-06.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-03-00.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-03-45.png\"></p>\n<h2 id=\"Granular-Material（颗粒材质）\"><a href=\"#Granular-Material（颗粒材质）\" class=\"headerlink\" title=\"Granular Material（颗粒材质）\"></a>Granular Material（颗粒材质）</h2><p><img src=\"/article_img/2022-10-22-15-05-34.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-06-05.png\"></p>\n<h2 id=\"半透明材质\"><a href=\"#半透明材质\" class=\"headerlink\" title=\"半透明材质\"></a>半透明材质</h2><p><img src=\"/article_img/2022-10-22-15-06-25.png\"></p>\n<p>次表面散射：<br>光线射入半透明物体后有可能会从任意方向射出。</p>\n<p><img src=\"/article_img/2022-10-22-15-17-26.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-20-05.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-22-02.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-22-42.png\"></p>\n<p>BSSRDF还适用于模拟人类皮肤</p>\n<p><img src=\"/article_img/2022-10-22-15-23-45.png\"></p>\n<h2 id=\"布料\"><a href=\"#布料\" class=\"headerlink\" title=\"布料\"></a>布料</h2><p><img src=\"/article_img/2022-10-22-15-26-34.png\"></p>\n<h2 id=\"表面细节\"><a href=\"#表面细节\" class=\"headerlink\" title=\"表面细节\"></a>表面细节</h2><p>真实的物体表面不会像渲染结果一样完美</p>\n<p><img src=\"/article_img/2022-10-22-15-27-38.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-29-17.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-29-34.png\"></p>\n<p><img src=\"/article_img/2022-10-22-15-30-36.png\"></p>\n<h2 id=\"程序化外观\"><a href=\"#程序化外观\" class=\"headerlink\" title=\"程序化外观\"></a>程序化外观</h2><p>利用噪声函数，模拟物体材质效果，每次要渲染的时候再计算应该如何显示。</p>\n<p><img src=\"/article_img/2022-10-22-15-32-53.png\"></p>\n<p>还可以定义3D噪声函数，来模拟物体内部的材质。</p>\n<p><img src=\"/article_img/2022-10-22-15-32-59.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=18&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_18.pdf\">GAMES101_Lecture_18.pdf</a>  </p>"},{"title":"Games101-2-变换","date":"2022-07-20T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-2-变换， 对应Games101第三、四节课\n<!-- more -->\n\n# Games101现代计算机图形学入门-3\n\n![](/article_img/2022-10-15-15-38-04.png)\n\n# 线性变换\n\n## 缩放\n\n## 切变\n![](/article_img/2022-08-01-18-08-53.png)\n\n## 旋转\n![](/article_img/2022-08-01-18-15-35.png)\n\n旋转-a角度的矩阵就是旋转a角度的转置矩阵，也是逆矩阵\n\n# 仿射变换（齐次坐标）\n为了解决平移变换不能简单写成矩阵相乘 **x'= Mx**\n\n![](/article_img/2022-08-01-18-23-48.png)\n\n向量具有**平移不变性**，因此向量最后是0\n\n![](/article_img/2022-08-01-18-27-54.png)\n\n在齐次坐标下，点+点表示这两点的中点\n\n![](/article_img/2022-08-01-18-34-08.png)\n\n**逆变换对应逆矩阵**\n\n# 变换的组合\n\n![](/article_img/2022-08-01-18-43-06.png)\n\n# 三维变换\n\n![](/article_img/2022-08-01-18-50-39.png)\n\n![](/article_img/2022-08-01-18-53-06.png)\n\n**对这种矩阵来说，是先线性变换后仿射变换**\n\n## 三维旋转\n\n![](/article_img/2022-08-01-20-43-53.png)\n\n基于右手螺旋定则，y由z叉乘x得到，固正好相反\n\n![](/article_img/2022-08-03-10-12-36.png)\n\n### 罗格里德斯旋转公式\n\n![](/article_img/2022-08-03-10-22-45.png)\n\n# 视图变换\n\n确定相机位置\n\n![](/article_img/2022-08-03-10-31-16.png)\n\n![](/article_img/2022-08-03-10-39-27.png)\n\n将任意向量旋转到标准轴困难，故做逆操作，将标准轴转到任意向量，之后对旋转矩阵做逆变换，恰好旋转矩阵是**正交矩阵**，其逆矩阵就是转置矩阵。\n\n# 投影变换\n\n## 正交投影\n\n![](/article_img/2022-08-10-16-12-45.png)\n\n## 透视投影\n\n![](/article_img/2022-08-03-17-35-43.png)\n\n推导思路：先将Frustum挤压成一个长方体，之后再做一次正交投影\n\n推导过程：\n\n![](/article_img/2022-10-27-14-53-37.png)\n\n## 视锥\n\n![](/article_img/2022-08-03-20-29-06.png)\n\n1. aspect ratio: 宽高比（观测角度）\n2. Field of View(fovY): 可视角度\n\n![](/article_img/2022-08-11-08-56-46.png)\n\n# homework0\n\n## 代码\n```c++\n// 给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45◦，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。\n// 定义点P\nEigen::Vector3f p(2.0f, 1.0f, 1.0f);\n// 旋转矩阵\nEigen::Matrix3f rotation;\nrotation <<\n   std::cos(45.0 / 180.0 * acos(-1)), -std::sin(45.0 / 180.0 * acos(-1)), 0,\n   std::sin(45.0 / 180.0 * acos(-1)), std::cos(45.0 / 180.0 * acos(-1)), 0,\n   0, 0, 1;\n// 平移矩阵\nEigen::Matrix3f trans;\ntrans <<\n   1, 0, 1,\n   0, 1, 2,\n   0, 0, 1;\n// 变换\nstd::cout << trans * rotation * p;\n```\n重点关注点，向量和矩阵定义的方法\n\n# homework1\n\n## 代码\n```c++\n// get_model_matrix(float rotation_angle)\n\n   Eigen::Matrix4f model = Eigen::Matrix4f::Identity();\n\n   float angle = rotation_angle / 180.0f * 3.14;\n   float c = cosf(angle);\n   float s = sinf(angle);\n   Eigen::Matrix4f rotation;\n   rotation <<\n      c, -s, 0, 0,\n      s, c, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1;\n   model = model * rotation;\n\n\n// get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)\n\n   float n, f, t, b, r, l;\n   t = abs(zNear) * tanf((eye_fov * 3.14 / 180.0) / 2);\n   r = aspect_ratio * t;\n   b = -t;\n   l = -r;\n   n = -zNear;\n   f = -zFar;\n\n   Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();\n\n   Eigen::Matrix4f trans, scale, p2o, prep;\n   trans <<\n      1, 0, 0, -(r + l) / 2,\n      0, 1, 0, -(t + b) / 2,\n      0, 0, 1, -(n + f) / 2,\n      0, 0, 0, 1;\n   scale <<\n      2 / (r - l), 0, 0, 0,\n      0, 2 / (t - b), 0, 0,\n      0, 0, 2 / (n - f), 0,\n      0, 0, 0, 1;\n   p2o <<\n      n, 0, 0, 0,\n      0, n, 0, 0,\n      0, 0, n + f, -(n * f),\n      0, 0, 1, 0;\n\n   projection =  trans * scale * p2o * projection;\n```\n运行结果：\n![](/article_img/2022-08-11-11-15-21.png)\n注意：\n1. 角度要进行转换\n2. 一开始绘制的三角形是倒着的，是因为默认zNear和zFar是正值，但实际上其均为负值，故对其取负值。\n\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_03.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_03.pdf)  \n[GAMES101_Lecture_04.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_04.pdf)","source":"_posts/Games101-2-变换.md","raw":"---\ntitle: Games101-2-变换\ndate: 2022-07-21 \nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-2-变换， 对应Games101第三、四节课\n<!-- more -->\n\n# Games101现代计算机图形学入门-3\n\n![](/article_img/2022-10-15-15-38-04.png)\n\n# 线性变换\n\n## 缩放\n\n## 切变\n![](/article_img/2022-08-01-18-08-53.png)\n\n## 旋转\n![](/article_img/2022-08-01-18-15-35.png)\n\n旋转-a角度的矩阵就是旋转a角度的转置矩阵，也是逆矩阵\n\n# 仿射变换（齐次坐标）\n为了解决平移变换不能简单写成矩阵相乘 **x'= Mx**\n\n![](/article_img/2022-08-01-18-23-48.png)\n\n向量具有**平移不变性**，因此向量最后是0\n\n![](/article_img/2022-08-01-18-27-54.png)\n\n在齐次坐标下，点+点表示这两点的中点\n\n![](/article_img/2022-08-01-18-34-08.png)\n\n**逆变换对应逆矩阵**\n\n# 变换的组合\n\n![](/article_img/2022-08-01-18-43-06.png)\n\n# 三维变换\n\n![](/article_img/2022-08-01-18-50-39.png)\n\n![](/article_img/2022-08-01-18-53-06.png)\n\n**对这种矩阵来说，是先线性变换后仿射变换**\n\n## 三维旋转\n\n![](/article_img/2022-08-01-20-43-53.png)\n\n基于右手螺旋定则，y由z叉乘x得到，固正好相反\n\n![](/article_img/2022-08-03-10-12-36.png)\n\n### 罗格里德斯旋转公式\n\n![](/article_img/2022-08-03-10-22-45.png)\n\n# 视图变换\n\n确定相机位置\n\n![](/article_img/2022-08-03-10-31-16.png)\n\n![](/article_img/2022-08-03-10-39-27.png)\n\n将任意向量旋转到标准轴困难，故做逆操作，将标准轴转到任意向量，之后对旋转矩阵做逆变换，恰好旋转矩阵是**正交矩阵**，其逆矩阵就是转置矩阵。\n\n# 投影变换\n\n## 正交投影\n\n![](/article_img/2022-08-10-16-12-45.png)\n\n## 透视投影\n\n![](/article_img/2022-08-03-17-35-43.png)\n\n推导思路：先将Frustum挤压成一个长方体，之后再做一次正交投影\n\n推导过程：\n\n![](/article_img/2022-10-27-14-53-37.png)\n\n## 视锥\n\n![](/article_img/2022-08-03-20-29-06.png)\n\n1. aspect ratio: 宽高比（观测角度）\n2. Field of View(fovY): 可视角度\n\n![](/article_img/2022-08-11-08-56-46.png)\n\n# homework0\n\n## 代码\n```c++\n// 给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45◦，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。\n// 定义点P\nEigen::Vector3f p(2.0f, 1.0f, 1.0f);\n// 旋转矩阵\nEigen::Matrix3f rotation;\nrotation <<\n   std::cos(45.0 / 180.0 * acos(-1)), -std::sin(45.0 / 180.0 * acos(-1)), 0,\n   std::sin(45.0 / 180.0 * acos(-1)), std::cos(45.0 / 180.0 * acos(-1)), 0,\n   0, 0, 1;\n// 平移矩阵\nEigen::Matrix3f trans;\ntrans <<\n   1, 0, 1,\n   0, 1, 2,\n   0, 0, 1;\n// 变换\nstd::cout << trans * rotation * p;\n```\n重点关注点，向量和矩阵定义的方法\n\n# homework1\n\n## 代码\n```c++\n// get_model_matrix(float rotation_angle)\n\n   Eigen::Matrix4f model = Eigen::Matrix4f::Identity();\n\n   float angle = rotation_angle / 180.0f * 3.14;\n   float c = cosf(angle);\n   float s = sinf(angle);\n   Eigen::Matrix4f rotation;\n   rotation <<\n      c, -s, 0, 0,\n      s, c, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1;\n   model = model * rotation;\n\n\n// get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)\n\n   float n, f, t, b, r, l;\n   t = abs(zNear) * tanf((eye_fov * 3.14 / 180.0) / 2);\n   r = aspect_ratio * t;\n   b = -t;\n   l = -r;\n   n = -zNear;\n   f = -zFar;\n\n   Eigen::Matrix4f projection = Eigen::Matrix4f::Identity();\n\n   Eigen::Matrix4f trans, scale, p2o, prep;\n   trans <<\n      1, 0, 0, -(r + l) / 2,\n      0, 1, 0, -(t + b) / 2,\n      0, 0, 1, -(n + f) / 2,\n      0, 0, 0, 1;\n   scale <<\n      2 / (r - l), 0, 0, 0,\n      0, 2 / (t - b), 0, 0,\n      0, 0, 2 / (n - f), 0,\n      0, 0, 0, 1;\n   p2o <<\n      n, 0, 0, 0,\n      0, n, 0, 0,\n      0, 0, n + f, -(n * f),\n      0, 0, 1, 0;\n\n   projection =  trans * scale * p2o * projection;\n```\n运行结果：\n![](/article_img/2022-08-11-11-15-21.png)\n注意：\n1. 角度要进行转换\n2. 一开始绘制的三角形是倒着的，是因为默认zNear和zFar是正值，但实际上其均为负值，故对其取负值。\n\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_03.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_03.pdf)  \n[GAMES101_Lecture_04.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_04.pdf)","slug":"Games101-2-变换","published":1,"updated":"2022-11-10T06:24:03.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglo000cw0jec5nr74tc","content":"<p>Games101-2-变换， 对应Games101第三、四节课</p>\n<span id=\"more\"></span>\n\n<h1 id=\"Games101现代计算机图形学入门-3\"><a href=\"#Games101现代计算机图形学入门-3\" class=\"headerlink\" title=\"Games101现代计算机图形学入门-3\"></a>Games101现代计算机图形学入门-3</h1><p><img src=\"/article_img/2022-10-15-15-38-04.png\"></p>\n<h1 id=\"线性变换\"><a href=\"#线性变换\" class=\"headerlink\" title=\"线性变换\"></a>线性变换</h1><h2 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h2><h2 id=\"切变\"><a href=\"#切变\" class=\"headerlink\" title=\"切变\"></a>切变</h2><p><img src=\"/article_img/2022-08-01-18-08-53.png\"></p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p><img src=\"/article_img/2022-08-01-18-15-35.png\"></p>\n<p>旋转-a角度的矩阵就是旋转a角度的转置矩阵，也是逆矩阵</p>\n<h1 id=\"仿射变换（齐次坐标）\"><a href=\"#仿射变换（齐次坐标）\" class=\"headerlink\" title=\"仿射变换（齐次坐标）\"></a>仿射变换（齐次坐标）</h1><p>为了解决平移变换不能简单写成矩阵相乘 <strong>x’&#x3D; Mx</strong></p>\n<p><img src=\"/article_img/2022-08-01-18-23-48.png\"></p>\n<p>向量具有<strong>平移不变性</strong>，因此向量最后是0</p>\n<p><img src=\"/article_img/2022-08-01-18-27-54.png\"></p>\n<p>在齐次坐标下，点+点表示这两点的中点</p>\n<p><img src=\"/article_img/2022-08-01-18-34-08.png\"></p>\n<p><strong>逆变换对应逆矩阵</strong></p>\n<h1 id=\"变换的组合\"><a href=\"#变换的组合\" class=\"headerlink\" title=\"变换的组合\"></a>变换的组合</h1><p><img src=\"/article_img/2022-08-01-18-43-06.png\"></p>\n<h1 id=\"三维变换\"><a href=\"#三维变换\" class=\"headerlink\" title=\"三维变换\"></a>三维变换</h1><p><img src=\"/article_img/2022-08-01-18-50-39.png\"></p>\n<p><img src=\"/article_img/2022-08-01-18-53-06.png\"></p>\n<p><strong>对这种矩阵来说，是先线性变换后仿射变换</strong></p>\n<h2 id=\"三维旋转\"><a href=\"#三维旋转\" class=\"headerlink\" title=\"三维旋转\"></a>三维旋转</h2><p><img src=\"/article_img/2022-08-01-20-43-53.png\"></p>\n<p>基于右手螺旋定则，y由z叉乘x得到，固正好相反</p>\n<p><img src=\"/article_img/2022-08-03-10-12-36.png\"></p>\n<h3 id=\"罗格里德斯旋转公式\"><a href=\"#罗格里德斯旋转公式\" class=\"headerlink\" title=\"罗格里德斯旋转公式\"></a>罗格里德斯旋转公式</h3><p><img src=\"/article_img/2022-08-03-10-22-45.png\"></p>\n<h1 id=\"视图变换\"><a href=\"#视图变换\" class=\"headerlink\" title=\"视图变换\"></a>视图变换</h1><p>确定相机位置</p>\n<p><img src=\"/article_img/2022-08-03-10-31-16.png\"></p>\n<p><img src=\"/article_img/2022-08-03-10-39-27.png\"></p>\n<p>将任意向量旋转到标准轴困难，故做逆操作，将标准轴转到任意向量，之后对旋转矩阵做逆变换，恰好旋转矩阵是<strong>正交矩阵</strong>，其逆矩阵就是转置矩阵。</p>\n<h1 id=\"投影变换\"><a href=\"#投影变换\" class=\"headerlink\" title=\"投影变换\"></a>投影变换</h1><h2 id=\"正交投影\"><a href=\"#正交投影\" class=\"headerlink\" title=\"正交投影\"></a>正交投影</h2><p><img src=\"/article_img/2022-08-10-16-12-45.png\"></p>\n<h2 id=\"透视投影\"><a href=\"#透视投影\" class=\"headerlink\" title=\"透视投影\"></a>透视投影</h2><p><img src=\"/article_img/2022-08-03-17-35-43.png\"></p>\n<p>推导思路：先将Frustum挤压成一个长方体，之后再做一次正交投影</p>\n<p>推导过程：</p>\n<p><img src=\"/article_img/2022-10-27-14-53-37.png\"></p>\n<h2 id=\"视锥\"><a href=\"#视锥\" class=\"headerlink\" title=\"视锥\"></a>视锥</h2><p><img src=\"/article_img/2022-08-03-20-29-06.png\"></p>\n<ol>\n<li>aspect ratio: 宽高比（观测角度）</li>\n<li>Field of View(fovY): 可视角度</li>\n</ol>\n<p><img src=\"/article_img/2022-08-11-08-56-46.png\"></p>\n<h1 id=\"homework0\"><a href=\"#homework0\" class=\"headerlink\" title=\"homework0\"></a>homework0</h1><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45◦，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。</span><br><span class=\"hljs-comment\">// 定义点P</span><br><span class=\"hljs-function\">Eigen::Vector3f <span class=\"hljs-title\">p</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">1.0f</span>)</span></span>;<br><span class=\"hljs-comment\">// 旋转矩阵</span><br>Eigen::Matrix3f rotation;<br>rotation &lt;&lt;<br>   std::<span class=\"hljs-built_in\">cos</span>(<span class=\"hljs-number\">45.0</span> / <span class=\"hljs-number\">180.0</span> * <span class=\"hljs-built_in\">acos</span>(<span class=\"hljs-number\">-1</span>)), -std::<span class=\"hljs-built_in\">sin</span>(<span class=\"hljs-number\">45.0</span> / <span class=\"hljs-number\">180.0</span> * <span class=\"hljs-built_in\">acos</span>(<span class=\"hljs-number\">-1</span>)), <span class=\"hljs-number\">0</span>,<br>   std::<span class=\"hljs-built_in\">sin</span>(<span class=\"hljs-number\">45.0</span> / <span class=\"hljs-number\">180.0</span> * <span class=\"hljs-built_in\">acos</span>(<span class=\"hljs-number\">-1</span>)), std::<span class=\"hljs-built_in\">cos</span>(<span class=\"hljs-number\">45.0</span> / <span class=\"hljs-number\">180.0</span> * <span class=\"hljs-built_in\">acos</span>(<span class=\"hljs-number\">-1</span>)), <span class=\"hljs-number\">0</span>,<br>   <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-comment\">// 平移矩阵</span><br>Eigen::Matrix3f trans;<br>trans &lt;&lt;<br>   <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>,<br>   <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>,<br>   <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-comment\">// 变换</span><br>std::cout &lt;&lt; trans * rotation * p;<br></code></pre></td></tr></table></figure>\n<p>重点关注点，向量和矩阵定义的方法</p>\n<h1 id=\"homework1\"><a href=\"#homework1\" class=\"headerlink\" title=\"homework1\"></a>homework1</h1><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// get_model_matrix(float rotation_angle)</span><br><br>   Eigen::Matrix4f model = Eigen::Matrix4f::<span class=\"hljs-built_in\">Identity</span>();<br><br>   <span class=\"hljs-type\">float</span> angle = rotation_angle / <span class=\"hljs-number\">180.0f</span> * <span class=\"hljs-number\">3.14</span>;<br>   <span class=\"hljs-type\">float</span> c = <span class=\"hljs-built_in\">cosf</span>(angle);<br>   <span class=\"hljs-type\">float</span> s = <span class=\"hljs-built_in\">sinf</span>(angle);<br>   Eigen::Matrix4f rotation;<br>   rotation &lt;&lt;<br>      c, -s, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      s, c, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br>   model = model * rotation;<br><br><br><span class=\"hljs-comment\">// get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</span><br><br>   <span class=\"hljs-type\">float</span> n, f, t, b, r, l;<br>   t = <span class=\"hljs-built_in\">abs</span>(zNear) * <span class=\"hljs-built_in\">tanf</span>((eye_fov * <span class=\"hljs-number\">3.14</span> / <span class=\"hljs-number\">180.0</span>) / <span class=\"hljs-number\">2</span>);<br>   r = aspect_ratio * t;<br>   b = -t;<br>   l = -r;<br>   n = -zNear;<br>   f = -zFar;<br><br>   Eigen::Matrix4f projection = Eigen::Matrix4f::<span class=\"hljs-built_in\">Identity</span>();<br><br>   Eigen::Matrix4f trans, scale, p2o, prep;<br>   trans &lt;&lt;<br>      <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, -(r + l) / <span class=\"hljs-number\">2</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, -(t + b) / <span class=\"hljs-number\">2</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, -(n + f) / <span class=\"hljs-number\">2</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br>   scale &lt;&lt;<br>      <span class=\"hljs-number\">2</span> / (r - l), <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span> / (t - b), <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span> / (n - f), <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br>   p2o &lt;&lt;<br>      n, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, n, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, n + f, -(n * f),<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>;<br><br>   projection =  trans * scale * p2o * projection;<br></code></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"/article_img/2022-08-11-11-15-21.png\"><br>注意：</p>\n<ol>\n<li>角度要进行转换</li>\n<li>一开始绘制的三角形是倒着的，是因为默认zNear和zFar是正值，但实际上其均为负值，故对其取负值。</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_03.pdf\">GAMES101_Lecture_03.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_04.pdf\">GAMES101_Lecture_04.pdf</a></p>\n","site":{"data":{}},"wordcount":1791,"excerpt":"<p>Games101-2-变换， 对应Games101第三、四节课</p>","more":"<h1 id=\"Games101现代计算机图形学入门-3\"><a href=\"#Games101现代计算机图形学入门-3\" class=\"headerlink\" title=\"Games101现代计算机图形学入门-3\"></a>Games101现代计算机图形学入门-3</h1><p><img src=\"/article_img/2022-10-15-15-38-04.png\"></p>\n<h1 id=\"线性变换\"><a href=\"#线性变换\" class=\"headerlink\" title=\"线性变换\"></a>线性变换</h1><h2 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h2><h2 id=\"切变\"><a href=\"#切变\" class=\"headerlink\" title=\"切变\"></a>切变</h2><p><img src=\"/article_img/2022-08-01-18-08-53.png\"></p>\n<h2 id=\"旋转\"><a href=\"#旋转\" class=\"headerlink\" title=\"旋转\"></a>旋转</h2><p><img src=\"/article_img/2022-08-01-18-15-35.png\"></p>\n<p>旋转-a角度的矩阵就是旋转a角度的转置矩阵，也是逆矩阵</p>\n<h1 id=\"仿射变换（齐次坐标）\"><a href=\"#仿射变换（齐次坐标）\" class=\"headerlink\" title=\"仿射变换（齐次坐标）\"></a>仿射变换（齐次坐标）</h1><p>为了解决平移变换不能简单写成矩阵相乘 <strong>x’&#x3D; Mx</strong></p>\n<p><img src=\"/article_img/2022-08-01-18-23-48.png\"></p>\n<p>向量具有<strong>平移不变性</strong>，因此向量最后是0</p>\n<p><img src=\"/article_img/2022-08-01-18-27-54.png\"></p>\n<p>在齐次坐标下，点+点表示这两点的中点</p>\n<p><img src=\"/article_img/2022-08-01-18-34-08.png\"></p>\n<p><strong>逆变换对应逆矩阵</strong></p>\n<h1 id=\"变换的组合\"><a href=\"#变换的组合\" class=\"headerlink\" title=\"变换的组合\"></a>变换的组合</h1><p><img src=\"/article_img/2022-08-01-18-43-06.png\"></p>\n<h1 id=\"三维变换\"><a href=\"#三维变换\" class=\"headerlink\" title=\"三维变换\"></a>三维变换</h1><p><img src=\"/article_img/2022-08-01-18-50-39.png\"></p>\n<p><img src=\"/article_img/2022-08-01-18-53-06.png\"></p>\n<p><strong>对这种矩阵来说，是先线性变换后仿射变换</strong></p>\n<h2 id=\"三维旋转\"><a href=\"#三维旋转\" class=\"headerlink\" title=\"三维旋转\"></a>三维旋转</h2><p><img src=\"/article_img/2022-08-01-20-43-53.png\"></p>\n<p>基于右手螺旋定则，y由z叉乘x得到，固正好相反</p>\n<p><img src=\"/article_img/2022-08-03-10-12-36.png\"></p>\n<h3 id=\"罗格里德斯旋转公式\"><a href=\"#罗格里德斯旋转公式\" class=\"headerlink\" title=\"罗格里德斯旋转公式\"></a>罗格里德斯旋转公式</h3><p><img src=\"/article_img/2022-08-03-10-22-45.png\"></p>\n<h1 id=\"视图变换\"><a href=\"#视图变换\" class=\"headerlink\" title=\"视图变换\"></a>视图变换</h1><p>确定相机位置</p>\n<p><img src=\"/article_img/2022-08-03-10-31-16.png\"></p>\n<p><img src=\"/article_img/2022-08-03-10-39-27.png\"></p>\n<p>将任意向量旋转到标准轴困难，故做逆操作，将标准轴转到任意向量，之后对旋转矩阵做逆变换，恰好旋转矩阵是<strong>正交矩阵</strong>，其逆矩阵就是转置矩阵。</p>\n<h1 id=\"投影变换\"><a href=\"#投影变换\" class=\"headerlink\" title=\"投影变换\"></a>投影变换</h1><h2 id=\"正交投影\"><a href=\"#正交投影\" class=\"headerlink\" title=\"正交投影\"></a>正交投影</h2><p><img src=\"/article_img/2022-08-10-16-12-45.png\"></p>\n<h2 id=\"透视投影\"><a href=\"#透视投影\" class=\"headerlink\" title=\"透视投影\"></a>透视投影</h2><p><img src=\"/article_img/2022-08-03-17-35-43.png\"></p>\n<p>推导思路：先将Frustum挤压成一个长方体，之后再做一次正交投影</p>\n<p>推导过程：</p>\n<p><img src=\"/article_img/2022-10-27-14-53-37.png\"></p>\n<h2 id=\"视锥\"><a href=\"#视锥\" class=\"headerlink\" title=\"视锥\"></a>视锥</h2><p><img src=\"/article_img/2022-08-03-20-29-06.png\"></p>\n<ol>\n<li>aspect ratio: 宽高比（观测角度）</li>\n<li>Field of View(fovY): 可视角度</li>\n</ol>\n<p><img src=\"/article_img/2022-08-11-08-56-46.png\"></p>\n<h1 id=\"homework0\"><a href=\"#homework0\" class=\"headerlink\" title=\"homework0\"></a>homework0</h1><h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 给定一个点 P=(2,1), 将该点绕原点先逆时针旋转 45◦，再平移 (1,2), 计算出变换后点的坐标（要求用齐次坐标进行计算）。</span><br><span class=\"hljs-comment\">// 定义点P</span><br><span class=\"hljs-function\">Eigen::Vector3f <span class=\"hljs-title\">p</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">1.0f</span>)</span></span>;<br><span class=\"hljs-comment\">// 旋转矩阵</span><br>Eigen::Matrix3f rotation;<br>rotation &lt;&lt;<br>   std::<span class=\"hljs-built_in\">cos</span>(<span class=\"hljs-number\">45.0</span> / <span class=\"hljs-number\">180.0</span> * <span class=\"hljs-built_in\">acos</span>(<span class=\"hljs-number\">-1</span>)), -std::<span class=\"hljs-built_in\">sin</span>(<span class=\"hljs-number\">45.0</span> / <span class=\"hljs-number\">180.0</span> * <span class=\"hljs-built_in\">acos</span>(<span class=\"hljs-number\">-1</span>)), <span class=\"hljs-number\">0</span>,<br>   std::<span class=\"hljs-built_in\">sin</span>(<span class=\"hljs-number\">45.0</span> / <span class=\"hljs-number\">180.0</span> * <span class=\"hljs-built_in\">acos</span>(<span class=\"hljs-number\">-1</span>)), std::<span class=\"hljs-built_in\">cos</span>(<span class=\"hljs-number\">45.0</span> / <span class=\"hljs-number\">180.0</span> * <span class=\"hljs-built_in\">acos</span>(<span class=\"hljs-number\">-1</span>)), <span class=\"hljs-number\">0</span>,<br>   <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-comment\">// 平移矩阵</span><br>Eigen::Matrix3f trans;<br>trans &lt;&lt;<br>   <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>,<br>   <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>,<br>   <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br><span class=\"hljs-comment\">// 变换</span><br>std::cout &lt;&lt; trans * rotation * p;<br></code></pre></td></tr></table></figure>\n<p>重点关注点，向量和矩阵定义的方法</p>\n<h1 id=\"homework1\"><a href=\"#homework1\" class=\"headerlink\" title=\"homework1\"></a>homework1</h1><h2 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// get_model_matrix(float rotation_angle)</span><br><br>   Eigen::Matrix4f model = Eigen::Matrix4f::<span class=\"hljs-built_in\">Identity</span>();<br><br>   <span class=\"hljs-type\">float</span> angle = rotation_angle / <span class=\"hljs-number\">180.0f</span> * <span class=\"hljs-number\">3.14</span>;<br>   <span class=\"hljs-type\">float</span> c = <span class=\"hljs-built_in\">cosf</span>(angle);<br>   <span class=\"hljs-type\">float</span> s = <span class=\"hljs-built_in\">sinf</span>(angle);<br>   Eigen::Matrix4f rotation;<br>   rotation &lt;&lt;<br>      c, -s, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      s, c, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br>   model = model * rotation;<br><br><br><span class=\"hljs-comment\">// get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</span><br><br>   <span class=\"hljs-type\">float</span> n, f, t, b, r, l;<br>   t = <span class=\"hljs-built_in\">abs</span>(zNear) * <span class=\"hljs-built_in\">tanf</span>((eye_fov * <span class=\"hljs-number\">3.14</span> / <span class=\"hljs-number\">180.0</span>) / <span class=\"hljs-number\">2</span>);<br>   r = aspect_ratio * t;<br>   b = -t;<br>   l = -r;<br>   n = -zNear;<br>   f = -zFar;<br><br>   Eigen::Matrix4f projection = Eigen::Matrix4f::<span class=\"hljs-built_in\">Identity</span>();<br><br>   Eigen::Matrix4f trans, scale, p2o, prep;<br>   trans &lt;&lt;<br>      <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, -(r + l) / <span class=\"hljs-number\">2</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, -(t + b) / <span class=\"hljs-number\">2</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, -(n + f) / <span class=\"hljs-number\">2</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br>   scale &lt;&lt;<br>      <span class=\"hljs-number\">2</span> / (r - l), <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span> / (t - b), <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span> / (n - f), <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>;<br>   p2o &lt;&lt;<br>      n, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, n, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>,<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, n + f, -(n * f),<br>      <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>;<br><br>   projection =  trans * scale * p2o * projection;<br></code></pre></td></tr></table></figure>\n<p>运行结果：<br><img src=\"/article_img/2022-08-11-11-15-21.png\"><br>注意：</p>\n<ol>\n<li>角度要进行转换</li>\n<li>一开始绘制的三角形是倒着的，是因为默认zNear和zFar是正值，但实际上其均为负值，故对其取负值。</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_03.pdf\">GAMES101_Lecture_03.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_04.pdf\">GAMES101_Lecture_04.pdf</a></p>"},{"title":"Games101-11-相机与透镜","date":"2022-10-28T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-11-相机与透镜\n<!-- more -->\n![](/article_img/2022-10-29-12-58-05.png)\n\n# 针孔/透镜在传感器上生成图像\n\n![](/article_img/2022-10-29-13-41-49.png)\n\n传感器积累的是曝光时间中的Irradiance\n\n# 视场（Field of View）\n\n![](/article_img/2022-10-29-13-44-18.png)\n\n可以通过改变焦距来改变视场。\n\n![](/article_img/2022-10-29-13-44-32.png)\n\n# 曝光（Exposure）\n\n![](/article_img/2022-10-29-13-46-16.png)\n\n曝光量 = 曝光时间 * Irradiance\n\n其中曝光时间由快门控制，Irradiance（Power per unit area）由透镜的光圈大小和焦距（焦距决定视场，视场越大自然irradiance越大）决定。\n\n光圈大小：由f-stop描述，f-stop值越大光圈越小，照片越暗，也越锐利；\n\nf-stop(f-number)的定义：焦距/光圈直径\n\n![](/article_img/2022-10-29-14-50-09.png)\n\n![](/article_img/2022-10-29-13-50-48.png)\n\n快门时间：快门时间越长，照片越模糊（动态模糊-motion blur）\n\n![](/article_img/2022-10-29-13-50-58.png)\n\n高速摄影和延时摄影：高速摄影利用极短的快门时间，同时要求大光圈以及高ISO（确保照片足够亮）；延时摄影则利用很长的快门时间，同时要求小光圈（确保不会过亮）。\n\n![](/article_img/2022-10-29-13-55-20.png)\n\n![](/article_img/2022-10-29-13-55-07.png)\n\n# 薄透镜方程\n\n真实的相机的镜头都是一个透镜组，经过透镜组的复杂操作实现改变镜头焦距，所以在图形学中，我们定义的虚拟相机中的透镜焦距可以任意改变。\n\n![](/article_img/2022-10-29-13-58-15.png)\n\n这里就不推这个公式了。\n\n# 景深\n\n## Defocus Blur\n\n![](/article_img/2022-10-29-14-44-06.png)\n\n物体本来应该成像在Image点，但是由于感光平面不在Image点，而光线在相交于Image点后会仍然沿直线继续传播，就会形成一个模糊的区域 C（Circle of Confusion）；由相似三角形可以看出 C 与 A 有关，即COC（Circle of Confusion）与光圈大小有关。\n\n![](/article_img/2022-10-29-14-51-40.png)\n\n光圈（A = f/N 即 f-stop越小，A越大）越大，CoC越大，照片越模糊。\n\n## 景深\n\n![](/article_img/2022-10-29-15-01-54.png)\n\n![](/article_img/2022-10-29-15-02-48.png)\n\n认为一段区域内的CoC是足够小的。\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=19&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_19.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_19.pdf)  ","source":"_posts/Games101-11-相机与透镜.md","raw":"---\ntitle: Games101-11-相机与透镜\ndate: 2022-10-29\nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-11-相机与透镜\n<!-- more -->\n![](/article_img/2022-10-29-12-58-05.png)\n\n# 针孔/透镜在传感器上生成图像\n\n![](/article_img/2022-10-29-13-41-49.png)\n\n传感器积累的是曝光时间中的Irradiance\n\n# 视场（Field of View）\n\n![](/article_img/2022-10-29-13-44-18.png)\n\n可以通过改变焦距来改变视场。\n\n![](/article_img/2022-10-29-13-44-32.png)\n\n# 曝光（Exposure）\n\n![](/article_img/2022-10-29-13-46-16.png)\n\n曝光量 = 曝光时间 * Irradiance\n\n其中曝光时间由快门控制，Irradiance（Power per unit area）由透镜的光圈大小和焦距（焦距决定视场，视场越大自然irradiance越大）决定。\n\n光圈大小：由f-stop描述，f-stop值越大光圈越小，照片越暗，也越锐利；\n\nf-stop(f-number)的定义：焦距/光圈直径\n\n![](/article_img/2022-10-29-14-50-09.png)\n\n![](/article_img/2022-10-29-13-50-48.png)\n\n快门时间：快门时间越长，照片越模糊（动态模糊-motion blur）\n\n![](/article_img/2022-10-29-13-50-58.png)\n\n高速摄影和延时摄影：高速摄影利用极短的快门时间，同时要求大光圈以及高ISO（确保照片足够亮）；延时摄影则利用很长的快门时间，同时要求小光圈（确保不会过亮）。\n\n![](/article_img/2022-10-29-13-55-20.png)\n\n![](/article_img/2022-10-29-13-55-07.png)\n\n# 薄透镜方程\n\n真实的相机的镜头都是一个透镜组，经过透镜组的复杂操作实现改变镜头焦距，所以在图形学中，我们定义的虚拟相机中的透镜焦距可以任意改变。\n\n![](/article_img/2022-10-29-13-58-15.png)\n\n这里就不推这个公式了。\n\n# 景深\n\n## Defocus Blur\n\n![](/article_img/2022-10-29-14-44-06.png)\n\n物体本来应该成像在Image点，但是由于感光平面不在Image点，而光线在相交于Image点后会仍然沿直线继续传播，就会形成一个模糊的区域 C（Circle of Confusion）；由相似三角形可以看出 C 与 A 有关，即COC（Circle of Confusion）与光圈大小有关。\n\n![](/article_img/2022-10-29-14-51-40.png)\n\n光圈（A = f/N 即 f-stop越小，A越大）越大，CoC越大，照片越模糊。\n\n## 景深\n\n![](/article_img/2022-10-29-15-01-54.png)\n\n![](/article_img/2022-10-29-15-02-48.png)\n\n认为一段区域内的CoC是足够小的。\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=19&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_19.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_19.pdf)  ","slug":"Games101-11-相机与透镜","published":1,"updated":"2022-10-29T08:10:24.620Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglq000gw0jeejqx53ow","content":"<p>Games101-11-相机与透镜</p>\n<span id=\"more\"></span>\n<p><img src=\"/article_img/2022-10-29-12-58-05.png\"></p>\n<h1 id=\"针孔-x2F-透镜在传感器上生成图像\"><a href=\"#针孔-x2F-透镜在传感器上生成图像\" class=\"headerlink\" title=\"针孔&#x2F;透镜在传感器上生成图像\"></a>针孔&#x2F;透镜在传感器上生成图像</h1><p><img src=\"/article_img/2022-10-29-13-41-49.png\"></p>\n<p>传感器积累的是曝光时间中的Irradiance</p>\n<h1 id=\"视场（Field-of-View）\"><a href=\"#视场（Field-of-View）\" class=\"headerlink\" title=\"视场（Field of View）\"></a>视场（Field of View）</h1><p><img src=\"/article_img/2022-10-29-13-44-18.png\"></p>\n<p>可以通过改变焦距来改变视场。</p>\n<p><img src=\"/article_img/2022-10-29-13-44-32.png\"></p>\n<h1 id=\"曝光（Exposure）\"><a href=\"#曝光（Exposure）\" class=\"headerlink\" title=\"曝光（Exposure）\"></a>曝光（Exposure）</h1><p><img src=\"/article_img/2022-10-29-13-46-16.png\"></p>\n<p>曝光量 &#x3D; 曝光时间 * Irradiance</p>\n<p>其中曝光时间由快门控制，Irradiance（Power per unit area）由透镜的光圈大小和焦距（焦距决定视场，视场越大自然irradiance越大）决定。</p>\n<p>光圈大小：由f-stop描述，f-stop值越大光圈越小，照片越暗，也越锐利；</p>\n<p>f-stop(f-number)的定义：焦距&#x2F;光圈直径</p>\n<p><img src=\"/article_img/2022-10-29-14-50-09.png\"></p>\n<p><img src=\"/article_img/2022-10-29-13-50-48.png\"></p>\n<p>快门时间：快门时间越长，照片越模糊（动态模糊-motion blur）</p>\n<p><img src=\"/article_img/2022-10-29-13-50-58.png\"></p>\n<p>高速摄影和延时摄影：高速摄影利用极短的快门时间，同时要求大光圈以及高ISO（确保照片足够亮）；延时摄影则利用很长的快门时间，同时要求小光圈（确保不会过亮）。</p>\n<p><img src=\"/article_img/2022-10-29-13-55-20.png\"></p>\n<p><img src=\"/article_img/2022-10-29-13-55-07.png\"></p>\n<h1 id=\"薄透镜方程\"><a href=\"#薄透镜方程\" class=\"headerlink\" title=\"薄透镜方程\"></a>薄透镜方程</h1><p>真实的相机的镜头都是一个透镜组，经过透镜组的复杂操作实现改变镜头焦距，所以在图形学中，我们定义的虚拟相机中的透镜焦距可以任意改变。</p>\n<p><img src=\"/article_img/2022-10-29-13-58-15.png\"></p>\n<p>这里就不推这个公式了。</p>\n<h1 id=\"景深\"><a href=\"#景深\" class=\"headerlink\" title=\"景深\"></a>景深</h1><h2 id=\"Defocus-Blur\"><a href=\"#Defocus-Blur\" class=\"headerlink\" title=\"Defocus Blur\"></a>Defocus Blur</h2><p><img src=\"/article_img/2022-10-29-14-44-06.png\"></p>\n<p>物体本来应该成像在Image点，但是由于感光平面不在Image点，而光线在相交于Image点后会仍然沿直线继续传播，就会形成一个模糊的区域 C（Circle of Confusion）；由相似三角形可以看出 C 与 A 有关，即COC（Circle of Confusion）与光圈大小有关。</p>\n<p><img src=\"/article_img/2022-10-29-14-51-40.png\"></p>\n<p>光圈（A &#x3D; f&#x2F;N 即 f-stop越小，A越大）越大，CoC越大，照片越模糊。</p>\n<h2 id=\"景深-1\"><a href=\"#景深-1\" class=\"headerlink\" title=\"景深\"></a>景深</h2><p><img src=\"/article_img/2022-10-29-15-01-54.png\"></p>\n<p><img src=\"/article_img/2022-10-29-15-02-48.png\"></p>\n<p>认为一段区域内的CoC是足够小的。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=19&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_19.pdf\">GAMES101_Lecture_19.pdf</a>  </p>\n","site":{"data":{}},"wordcount":733,"excerpt":"<p>Games101-11-相机与透镜</p>","more":"<p><img src=\"/article_img/2022-10-29-12-58-05.png\"></p>\n<h1 id=\"针孔-x2F-透镜在传感器上生成图像\"><a href=\"#针孔-x2F-透镜在传感器上生成图像\" class=\"headerlink\" title=\"针孔&#x2F;透镜在传感器上生成图像\"></a>针孔&#x2F;透镜在传感器上生成图像</h1><p><img src=\"/article_img/2022-10-29-13-41-49.png\"></p>\n<p>传感器积累的是曝光时间中的Irradiance</p>\n<h1 id=\"视场（Field-of-View）\"><a href=\"#视场（Field-of-View）\" class=\"headerlink\" title=\"视场（Field of View）\"></a>视场（Field of View）</h1><p><img src=\"/article_img/2022-10-29-13-44-18.png\"></p>\n<p>可以通过改变焦距来改变视场。</p>\n<p><img src=\"/article_img/2022-10-29-13-44-32.png\"></p>\n<h1 id=\"曝光（Exposure）\"><a href=\"#曝光（Exposure）\" class=\"headerlink\" title=\"曝光（Exposure）\"></a>曝光（Exposure）</h1><p><img src=\"/article_img/2022-10-29-13-46-16.png\"></p>\n<p>曝光量 &#x3D; 曝光时间 * Irradiance</p>\n<p>其中曝光时间由快门控制，Irradiance（Power per unit area）由透镜的光圈大小和焦距（焦距决定视场，视场越大自然irradiance越大）决定。</p>\n<p>光圈大小：由f-stop描述，f-stop值越大光圈越小，照片越暗，也越锐利；</p>\n<p>f-stop(f-number)的定义：焦距&#x2F;光圈直径</p>\n<p><img src=\"/article_img/2022-10-29-14-50-09.png\"></p>\n<p><img src=\"/article_img/2022-10-29-13-50-48.png\"></p>\n<p>快门时间：快门时间越长，照片越模糊（动态模糊-motion blur）</p>\n<p><img src=\"/article_img/2022-10-29-13-50-58.png\"></p>\n<p>高速摄影和延时摄影：高速摄影利用极短的快门时间，同时要求大光圈以及高ISO（确保照片足够亮）；延时摄影则利用很长的快门时间，同时要求小光圈（确保不会过亮）。</p>\n<p><img src=\"/article_img/2022-10-29-13-55-20.png\"></p>\n<p><img src=\"/article_img/2022-10-29-13-55-07.png\"></p>\n<h1 id=\"薄透镜方程\"><a href=\"#薄透镜方程\" class=\"headerlink\" title=\"薄透镜方程\"></a>薄透镜方程</h1><p>真实的相机的镜头都是一个透镜组，经过透镜组的复杂操作实现改变镜头焦距，所以在图形学中，我们定义的虚拟相机中的透镜焦距可以任意改变。</p>\n<p><img src=\"/article_img/2022-10-29-13-58-15.png\"></p>\n<p>这里就不推这个公式了。</p>\n<h1 id=\"景深\"><a href=\"#景深\" class=\"headerlink\" title=\"景深\"></a>景深</h1><h2 id=\"Defocus-Blur\"><a href=\"#Defocus-Blur\" class=\"headerlink\" title=\"Defocus Blur\"></a>Defocus Blur</h2><p><img src=\"/article_img/2022-10-29-14-44-06.png\"></p>\n<p>物体本来应该成像在Image点，但是由于感光平面不在Image点，而光线在相交于Image点后会仍然沿直线继续传播，就会形成一个模糊的区域 C（Circle of Confusion）；由相似三角形可以看出 C 与 A 有关，即COC（Circle of Confusion）与光圈大小有关。</p>\n<p><img src=\"/article_img/2022-10-29-14-51-40.png\"></p>\n<p>光圈（A &#x3D; f&#x2F;N 即 f-stop越小，A越大）越大，CoC越大，照片越模糊。</p>\n<h2 id=\"景深-1\"><a href=\"#景深-1\" class=\"headerlink\" title=\"景深\"></a>景深</h2><p><img src=\"/article_img/2022-10-29-15-01-54.png\"></p>\n<p><img src=\"/article_img/2022-10-29-15-02-48.png\"></p>\n<p>认为一段区域内的CoC是足够小的。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=19&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_19.pdf\">GAMES101_Lecture_19.pdf</a>  </p>"},{"title":"Games101-3-光栅化","date":"2022-07-31T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-3-光栅化\n<!-- more -->\n\n\n# 基础定义\n\n![](/article_img/2022-08-03-20-33-50.png)\n\n# 反走样（抗锯齿）\n\n走样现象\n\n![](/article_img/2022-08-26-15-10-45.png)\n\n锯齿的出现一般是由于采样率不足导致的。\n\n![](/article_img/2022-08-26-15-16-08.png)\n\n## 采样\n\n![](/article_img/2022-08-26-15-12-11.png)\n\n采样瑕疵的出现是由于信号变化过快而采样频率太慢导致。\n\n## 反走样方法——先模糊后采样\n\n![](/article_img/2022-08-26-15-13-22.png)\n\n注意：先采样后模糊是错误的，不能达到反走样的效果。\n\n![](/article_img/2022-08-27-09-09-18.png)\n\n模糊操作是通过卷积操作实现的，即取平均。\n\n采样可以看作是频率的重复，走样现象是频率重叠导致，故可以先滤掉高频，再进行采样，也就是先模糊后采样。\n\n![](/article_img/2022-08-27-09-10-34.png)\n\n![](/article_img/2022-08-27-09-10-47.png)\n\n# 反走样的具体方法\n\n![](/article_img/2022-08-27-09-14-04.png)\n\n## MSAA\n\nMSAA就是加大采样率，从而达到抗锯齿的效果。\n\n![](/article_img/2022-08-27-09-15-15.png)\n\n实际应用中，MSAA的采样点一般是不规则的，对一些采样点进行了复用，从而提高效率。\n\n## 其他方法\n\n![](/article_img/2022-08-27-09-17-28.png)\n\n# 可见性/遮挡（Z-buffering）\n\n![](/article_img/2022-08-27-09-21-07.png)\n\n![](/article_img/2022-08-27-09-21-26.png)\n\n![](/article_img/2022-08-27-09-21-42.png)\n\nZ-buffering 时间复杂度为O(n)\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_05.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_05.pdf)  \n[GAMES101_Lecture_06.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_06.pdf)  \n[GAMES101_Lecture_07.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf)\n","source":"_posts/Games101-3-光栅化.md","raw":"---\ntitle: Games101-3-光栅化\ndate: 2022-08-01 \nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-3-光栅化\n<!-- more -->\n\n\n# 基础定义\n\n![](/article_img/2022-08-03-20-33-50.png)\n\n# 反走样（抗锯齿）\n\n走样现象\n\n![](/article_img/2022-08-26-15-10-45.png)\n\n锯齿的出现一般是由于采样率不足导致的。\n\n![](/article_img/2022-08-26-15-16-08.png)\n\n## 采样\n\n![](/article_img/2022-08-26-15-12-11.png)\n\n采样瑕疵的出现是由于信号变化过快而采样频率太慢导致。\n\n## 反走样方法——先模糊后采样\n\n![](/article_img/2022-08-26-15-13-22.png)\n\n注意：先采样后模糊是错误的，不能达到反走样的效果。\n\n![](/article_img/2022-08-27-09-09-18.png)\n\n模糊操作是通过卷积操作实现的，即取平均。\n\n采样可以看作是频率的重复，走样现象是频率重叠导致，故可以先滤掉高频，再进行采样，也就是先模糊后采样。\n\n![](/article_img/2022-08-27-09-10-34.png)\n\n![](/article_img/2022-08-27-09-10-47.png)\n\n# 反走样的具体方法\n\n![](/article_img/2022-08-27-09-14-04.png)\n\n## MSAA\n\nMSAA就是加大采样率，从而达到抗锯齿的效果。\n\n![](/article_img/2022-08-27-09-15-15.png)\n\n实际应用中，MSAA的采样点一般是不规则的，对一些采样点进行了复用，从而提高效率。\n\n## 其他方法\n\n![](/article_img/2022-08-27-09-17-28.png)\n\n# 可见性/遮挡（Z-buffering）\n\n![](/article_img/2022-08-27-09-21-07.png)\n\n![](/article_img/2022-08-27-09-21-26.png)\n\n![](/article_img/2022-08-27-09-21-42.png)\n\nZ-buffering 时间复杂度为O(n)\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_05.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_05.pdf)  \n[GAMES101_Lecture_06.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_06.pdf)  \n[GAMES101_Lecture_07.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf)\n","slug":"Games101-3-光栅化","published":1,"updated":"2022-10-14T05:26:10.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglq000iw0je4u2eee3u","content":"<p>Games101-3-光栅化</p>\n<span id=\"more\"></span>\n\n\n<h1 id=\"基础定义\"><a href=\"#基础定义\" class=\"headerlink\" title=\"基础定义\"></a>基础定义</h1><p><img src=\"/article_img/2022-08-03-20-33-50.png\"></p>\n<h1 id=\"反走样（抗锯齿）\"><a href=\"#反走样（抗锯齿）\" class=\"headerlink\" title=\"反走样（抗锯齿）\"></a>反走样（抗锯齿）</h1><p>走样现象</p>\n<p><img src=\"/article_img/2022-08-26-15-10-45.png\"></p>\n<p>锯齿的出现一般是由于采样率不足导致的。</p>\n<p><img src=\"/article_img/2022-08-26-15-16-08.png\"></p>\n<h2 id=\"采样\"><a href=\"#采样\" class=\"headerlink\" title=\"采样\"></a>采样</h2><p><img src=\"/article_img/2022-08-26-15-12-11.png\"></p>\n<p>采样瑕疵的出现是由于信号变化过快而采样频率太慢导致。</p>\n<h2 id=\"反走样方法——先模糊后采样\"><a href=\"#反走样方法——先模糊后采样\" class=\"headerlink\" title=\"反走样方法——先模糊后采样\"></a>反走样方法——先模糊后采样</h2><p><img src=\"/article_img/2022-08-26-15-13-22.png\"></p>\n<p>注意：先采样后模糊是错误的，不能达到反走样的效果。</p>\n<p><img src=\"/article_img/2022-08-27-09-09-18.png\"></p>\n<p>模糊操作是通过卷积操作实现的，即取平均。</p>\n<p>采样可以看作是频率的重复，走样现象是频率重叠导致，故可以先滤掉高频，再进行采样，也就是先模糊后采样。</p>\n<p><img src=\"/article_img/2022-08-27-09-10-34.png\"></p>\n<p><img src=\"/article_img/2022-08-27-09-10-47.png\"></p>\n<h1 id=\"反走样的具体方法\"><a href=\"#反走样的具体方法\" class=\"headerlink\" title=\"反走样的具体方法\"></a>反走样的具体方法</h1><p><img src=\"/article_img/2022-08-27-09-14-04.png\"></p>\n<h2 id=\"MSAA\"><a href=\"#MSAA\" class=\"headerlink\" title=\"MSAA\"></a>MSAA</h2><p>MSAA就是加大采样率，从而达到抗锯齿的效果。</p>\n<p><img src=\"/article_img/2022-08-27-09-15-15.png\"></p>\n<p>实际应用中，MSAA的采样点一般是不规则的，对一些采样点进行了复用，从而提高效率。</p>\n<h2 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h2><p><img src=\"/article_img/2022-08-27-09-17-28.png\"></p>\n<h1 id=\"可见性-x2F-遮挡（Z-buffering）\"><a href=\"#可见性-x2F-遮挡（Z-buffering）\" class=\"headerlink\" title=\"可见性&#x2F;遮挡（Z-buffering）\"></a>可见性&#x2F;遮挡（Z-buffering）</h1><p><img src=\"/article_img/2022-08-27-09-21-07.png\"></p>\n<p><img src=\"/article_img/2022-08-27-09-21-26.png\"></p>\n<p><img src=\"/article_img/2022-08-27-09-21-42.png\"></p>\n<p>Z-buffering 时间复杂度为O(n)</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_05.pdf\">GAMES101_Lecture_05.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_06.pdf\">GAMES101_Lecture_06.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf\">GAMES101_Lecture_07.pdf</a></p>\n","site":{"data":{}},"wordcount":389,"excerpt":"<p>Games101-3-光栅化</p>","more":"<h1 id=\"基础定义\"><a href=\"#基础定义\" class=\"headerlink\" title=\"基础定义\"></a>基础定义</h1><p><img src=\"/article_img/2022-08-03-20-33-50.png\"></p>\n<h1 id=\"反走样（抗锯齿）\"><a href=\"#反走样（抗锯齿）\" class=\"headerlink\" title=\"反走样（抗锯齿）\"></a>反走样（抗锯齿）</h1><p>走样现象</p>\n<p><img src=\"/article_img/2022-08-26-15-10-45.png\"></p>\n<p>锯齿的出现一般是由于采样率不足导致的。</p>\n<p><img src=\"/article_img/2022-08-26-15-16-08.png\"></p>\n<h2 id=\"采样\"><a href=\"#采样\" class=\"headerlink\" title=\"采样\"></a>采样</h2><p><img src=\"/article_img/2022-08-26-15-12-11.png\"></p>\n<p>采样瑕疵的出现是由于信号变化过快而采样频率太慢导致。</p>\n<h2 id=\"反走样方法——先模糊后采样\"><a href=\"#反走样方法——先模糊后采样\" class=\"headerlink\" title=\"反走样方法——先模糊后采样\"></a>反走样方法——先模糊后采样</h2><p><img src=\"/article_img/2022-08-26-15-13-22.png\"></p>\n<p>注意：先采样后模糊是错误的，不能达到反走样的效果。</p>\n<p><img src=\"/article_img/2022-08-27-09-09-18.png\"></p>\n<p>模糊操作是通过卷积操作实现的，即取平均。</p>\n<p>采样可以看作是频率的重复，走样现象是频率重叠导致，故可以先滤掉高频，再进行采样，也就是先模糊后采样。</p>\n<p><img src=\"/article_img/2022-08-27-09-10-34.png\"></p>\n<p><img src=\"/article_img/2022-08-27-09-10-47.png\"></p>\n<h1 id=\"反走样的具体方法\"><a href=\"#反走样的具体方法\" class=\"headerlink\" title=\"反走样的具体方法\"></a>反走样的具体方法</h1><p><img src=\"/article_img/2022-08-27-09-14-04.png\"></p>\n<h2 id=\"MSAA\"><a href=\"#MSAA\" class=\"headerlink\" title=\"MSAA\"></a>MSAA</h2><p>MSAA就是加大采样率，从而达到抗锯齿的效果。</p>\n<p><img src=\"/article_img/2022-08-27-09-15-15.png\"></p>\n<p>实际应用中，MSAA的采样点一般是不规则的，对一些采样点进行了复用，从而提高效率。</p>\n<h2 id=\"其他方法\"><a href=\"#其他方法\" class=\"headerlink\" title=\"其他方法\"></a>其他方法</h2><p><img src=\"/article_img/2022-08-27-09-17-28.png\"></p>\n<h1 id=\"可见性-x2F-遮挡（Z-buffering）\"><a href=\"#可见性-x2F-遮挡（Z-buffering）\" class=\"headerlink\" title=\"可见性&#x2F;遮挡（Z-buffering）\"></a>可见性&#x2F;遮挡（Z-buffering）</h1><p><img src=\"/article_img/2022-08-27-09-21-07.png\"></p>\n<p><img src=\"/article_img/2022-08-27-09-21-26.png\"></p>\n<p><img src=\"/article_img/2022-08-27-09-21-42.png\"></p>\n<p>Z-buffering 时间复杂度为O(n)</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_05.pdf\">GAMES101_Lecture_05.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_06.pdf\">GAMES101_Lecture_06.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf\">GAMES101_Lecture_07.pdf</a></p>"},{"title":"Games101-4-着色","date":"2022-08-24T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-4-着色\n<!-- more -->\n# 着色模型（Blinn-Phong Reflectance Model）\n\n根据感性观察有：  \n1. Specular highlights (镜面反射高光)\n2. Diffuse reflection (漫反射)\n3. Ambient lighting (环境光)\n\n![](/article_img/2022-08-29-15-14-39.png)\n\n## 漫反射\n\n认为漫反射是均匀的向各个方向反射的\n\n![](/article_img/2022-08-29-15-18-27.png)\n\n![](/article_img/2022-08-29-15-18-42.png)\n\n由上图以及地球的季节变化可知，光线直射方向和平面的夹角决定接受光的能量的多少。\n\n![](/article_img/2022-08-29-15-20-23.png)\n\n光的能量也与距离光源的距离有关，与距光源的距离的平方成反比。\n\n![](/article_img/2022-08-29-15-23-14.png)\n\n法线n·入射光l = cos夹角\n\nkd 表示该shading point的颜色（之后texture贴图就是改变kd的值）\n\n**漫反射的着色与观测角度无关** 也就是说无论在哪个方向观测，同一个着色点的颜色总是相同。例如：月球表面\n\n## 镜面反射\n\n![](/article_img/2022-08-29-15-35-09.png)\n\n**镜面反射与观测角度有关** 纯镜面即完全按照镜面反射规律进行反射，若是光滑一些的物体如金属，是在镜面反射出射光线的一个角度范围内可见。\n\n![](/article_img/2022-08-29-15-38-15.png)\n\nh是半程向量，这里的bisector是OpenGL中的函数(平行四边形法则)。指数p就是为了控制出射光线的可见角度范围，一般p为200左右（出射光线的左右5-6度）\n\n![](/article_img/2022-08-29-15-39-32.png)\n\n## 环境光\n\n在Blinn-Phong这个经验模型中，环境光被认为与任何东西都无关，即是一个常量。\n\n将三种光照相加即可得到最终的着色结果。\n\n![](/article_img/2022-08-29-15-42-40.png)\n\n# 着色频率（Shading Frequencies）\n\n![](/article_img/2022-08-29-15-48-55.png)\n\n## flat shading\n\n对每个**三角形**进行着色\n\n每一个三角形有一条法线。\n\n![](/article_img/2022-08-29-15-49-44.png)\n\n## Gouraud shading\n\n对每个**顶点**进行着色\n\n对三角形内部的点，根据三个顶点的颜色进行颜色插值，每一个顶点有一条法线。\n\n![](/article_img/2022-08-29-15-50-45.png)\n\n## Phong shading\n\n对每个**像素**进行着色\n\n对三角形内部的点，根据三个顶点的法线进行法线插值，计算出每一个像素的法线。\n\n![](/article_img/2022-08-29-15-51-54.png)\n\n## 法线定义方法\n\n![](/article_img/2022-08-29-16-17-54.png)\n\n![](/article_img/2022-08-29-16-18-04.png)\n\n利用重心坐标插值\n\n# 重心坐标（Barycentric Coordinates）\n\n![](/article_img/2022-08-29-16-22-31.png)\n\n![](/article_img/2022-08-29-16-23-23.png)\n\n系数均为1/3时，就是三角形的重心。\n\n![](/article_img/2022-08-29-16-24-37.png)\n\n![](/article_img/2022-08-29-16-24-47.png)\n\n插值可以对任何属性进行插值，例如颜色，纹理，法线，深度等等。\n\n重心坐标在投影变换后无法保证依然正确，因此要在投影变换之前进行插值，也就是要用空间中的坐标进行计算。\n\n# 图形（实时渲染）管线\n\n![](/article_img/2022-08-29-16-29-49.png)\n\n# Texture Mapping & 应用纹理\n\n![](/article_img/2022-08-29-16-32-11.png)\n\n![](/article_img/2022-08-29-16-32-22.png)\n\n![](/article_img/2022-08-29-18-30-33.png)\n\n# Texture Magnification (纹理过大过小问题)\n\n## 纹理分辨率过小 \n\n![](/article_img/2022-08-29-18-33-36.png)\n\nBilinear Interpolation (双线性插值)\n\n![](/article_img/2022-08-29-18-33-20.png)\n\n## 纹理分辨率过大\n\n![](/article_img/2022-08-29-18-35-15.png)\n\n![](/article_img/2022-08-29-18-35-24.png)\n\n问题在于一个像素里包含了很大一片纹理，而仅用一个纹理上的采样点代表这一片纹理。**超采样**（Supersampling）当让可以解决这个问题，但是消耗太大。为了解决这种问题就引入了Mipmap。\n\n## Mipmap\n\n![](/article_img/2022-08-29-18-41-41.png)\n\n![](/article_img/2022-08-29-18-41-51.png)\n\nmipmap的思路是避免采样，直接得到一片区域的平均值，提前生成不同分辨率的图像，之后用这些生成的低分辨率图像代表这一片区域的平均，mipmap多消耗的存储空间是原来的三倍。\n\n![](/article_img/2022-08-29-18-44-02.png)\n\n![](/article_img/2022-08-29-18-52-05.png)\n\n之后进行trilinear插值，让mipmap的level可以平滑过渡。得到下图的可视化结果。\n\n![](/article_img/2022-08-29-18-53-37.png)\n\n## Mipmap的局限\n\n![](/article_img/2022-08-29-18-54-29.png)\n\n![](/article_img/2022-08-29-18-54-37.png)\n\n由于Mipmap是用一个正方形区域近似真正被像素覆盖的区域，对上图这种长条形的区域就无法取得比较好的近似效果，就会产生过度模糊。\n\n为了避免过度模糊，引入了各向异性过滤。\n\n![](/article_img/2022-08-29-18-56-35.png)\n\n# 环境贴图\n\n![](/article_img/2022-08-29-19-00-41.png)\n\n![](/article_img/2022-08-29-19-00-52.png)\n\n# 凹凸/法线贴图（Bump/normal mapping）\n\n![](/article_img/2022-08-29-19-04-50.png)\n\n![](/article_img/2022-08-29-19-06-16.png)\n\n先求出p点的切线向量，之后旋转九十度就可得到新的法线向量。\n\n![](/article_img/2022-08-29-19-06-26.png)\n\n3d坐标原理类似。\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=9&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_07.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf)  \n[GAMES101_Lecture_08.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_08.pdf)  \n[GAMES101_Lecture_09.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_09.pdf)  \n[GAMES101_Lecture_10.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_10.pdf)","source":"_posts/Games101-4-着色.md","raw":"---\ntitle: Games101-4-着色\ndate: 2022-08-25\nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-4-着色\n<!-- more -->\n# 着色模型（Blinn-Phong Reflectance Model）\n\n根据感性观察有：  \n1. Specular highlights (镜面反射高光)\n2. Diffuse reflection (漫反射)\n3. Ambient lighting (环境光)\n\n![](/article_img/2022-08-29-15-14-39.png)\n\n## 漫反射\n\n认为漫反射是均匀的向各个方向反射的\n\n![](/article_img/2022-08-29-15-18-27.png)\n\n![](/article_img/2022-08-29-15-18-42.png)\n\n由上图以及地球的季节变化可知，光线直射方向和平面的夹角决定接受光的能量的多少。\n\n![](/article_img/2022-08-29-15-20-23.png)\n\n光的能量也与距离光源的距离有关，与距光源的距离的平方成反比。\n\n![](/article_img/2022-08-29-15-23-14.png)\n\n法线n·入射光l = cos夹角\n\nkd 表示该shading point的颜色（之后texture贴图就是改变kd的值）\n\n**漫反射的着色与观测角度无关** 也就是说无论在哪个方向观测，同一个着色点的颜色总是相同。例如：月球表面\n\n## 镜面反射\n\n![](/article_img/2022-08-29-15-35-09.png)\n\n**镜面反射与观测角度有关** 纯镜面即完全按照镜面反射规律进行反射，若是光滑一些的物体如金属，是在镜面反射出射光线的一个角度范围内可见。\n\n![](/article_img/2022-08-29-15-38-15.png)\n\nh是半程向量，这里的bisector是OpenGL中的函数(平行四边形法则)。指数p就是为了控制出射光线的可见角度范围，一般p为200左右（出射光线的左右5-6度）\n\n![](/article_img/2022-08-29-15-39-32.png)\n\n## 环境光\n\n在Blinn-Phong这个经验模型中，环境光被认为与任何东西都无关，即是一个常量。\n\n将三种光照相加即可得到最终的着色结果。\n\n![](/article_img/2022-08-29-15-42-40.png)\n\n# 着色频率（Shading Frequencies）\n\n![](/article_img/2022-08-29-15-48-55.png)\n\n## flat shading\n\n对每个**三角形**进行着色\n\n每一个三角形有一条法线。\n\n![](/article_img/2022-08-29-15-49-44.png)\n\n## Gouraud shading\n\n对每个**顶点**进行着色\n\n对三角形内部的点，根据三个顶点的颜色进行颜色插值，每一个顶点有一条法线。\n\n![](/article_img/2022-08-29-15-50-45.png)\n\n## Phong shading\n\n对每个**像素**进行着色\n\n对三角形内部的点，根据三个顶点的法线进行法线插值，计算出每一个像素的法线。\n\n![](/article_img/2022-08-29-15-51-54.png)\n\n## 法线定义方法\n\n![](/article_img/2022-08-29-16-17-54.png)\n\n![](/article_img/2022-08-29-16-18-04.png)\n\n利用重心坐标插值\n\n# 重心坐标（Barycentric Coordinates）\n\n![](/article_img/2022-08-29-16-22-31.png)\n\n![](/article_img/2022-08-29-16-23-23.png)\n\n系数均为1/3时，就是三角形的重心。\n\n![](/article_img/2022-08-29-16-24-37.png)\n\n![](/article_img/2022-08-29-16-24-47.png)\n\n插值可以对任何属性进行插值，例如颜色，纹理，法线，深度等等。\n\n重心坐标在投影变换后无法保证依然正确，因此要在投影变换之前进行插值，也就是要用空间中的坐标进行计算。\n\n# 图形（实时渲染）管线\n\n![](/article_img/2022-08-29-16-29-49.png)\n\n# Texture Mapping & 应用纹理\n\n![](/article_img/2022-08-29-16-32-11.png)\n\n![](/article_img/2022-08-29-16-32-22.png)\n\n![](/article_img/2022-08-29-18-30-33.png)\n\n# Texture Magnification (纹理过大过小问题)\n\n## 纹理分辨率过小 \n\n![](/article_img/2022-08-29-18-33-36.png)\n\nBilinear Interpolation (双线性插值)\n\n![](/article_img/2022-08-29-18-33-20.png)\n\n## 纹理分辨率过大\n\n![](/article_img/2022-08-29-18-35-15.png)\n\n![](/article_img/2022-08-29-18-35-24.png)\n\n问题在于一个像素里包含了很大一片纹理，而仅用一个纹理上的采样点代表这一片纹理。**超采样**（Supersampling）当让可以解决这个问题，但是消耗太大。为了解决这种问题就引入了Mipmap。\n\n## Mipmap\n\n![](/article_img/2022-08-29-18-41-41.png)\n\n![](/article_img/2022-08-29-18-41-51.png)\n\nmipmap的思路是避免采样，直接得到一片区域的平均值，提前生成不同分辨率的图像，之后用这些生成的低分辨率图像代表这一片区域的平均，mipmap多消耗的存储空间是原来的三倍。\n\n![](/article_img/2022-08-29-18-44-02.png)\n\n![](/article_img/2022-08-29-18-52-05.png)\n\n之后进行trilinear插值，让mipmap的level可以平滑过渡。得到下图的可视化结果。\n\n![](/article_img/2022-08-29-18-53-37.png)\n\n## Mipmap的局限\n\n![](/article_img/2022-08-29-18-54-29.png)\n\n![](/article_img/2022-08-29-18-54-37.png)\n\n由于Mipmap是用一个正方形区域近似真正被像素覆盖的区域，对上图这种长条形的区域就无法取得比较好的近似效果，就会产生过度模糊。\n\n为了避免过度模糊，引入了各向异性过滤。\n\n![](/article_img/2022-08-29-18-56-35.png)\n\n# 环境贴图\n\n![](/article_img/2022-08-29-19-00-41.png)\n\n![](/article_img/2022-08-29-19-00-52.png)\n\n# 凹凸/法线贴图（Bump/normal mapping）\n\n![](/article_img/2022-08-29-19-04-50.png)\n\n![](/article_img/2022-08-29-19-06-16.png)\n\n先求出p点的切线向量，之后旋转九十度就可得到新的法线向量。\n\n![](/article_img/2022-08-29-19-06-26.png)\n\n3d坐标原理类似。\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=9&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_07.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf)  \n[GAMES101_Lecture_08.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_08.pdf)  \n[GAMES101_Lecture_09.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_09.pdf)  \n[GAMES101_Lecture_10.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_10.pdf)","slug":"Games101-4-着色","published":1,"updated":"2022-10-14T05:25:56.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigls000mw0je5pkv9jrp","content":"<p>Games101-4-着色</p>\n<span id=\"more\"></span>\n<h1 id=\"着色模型（Blinn-Phong-Reflectance-Model）\"><a href=\"#着色模型（Blinn-Phong-Reflectance-Model）\" class=\"headerlink\" title=\"着色模型（Blinn-Phong Reflectance Model）\"></a>着色模型（Blinn-Phong Reflectance Model）</h1><p>根据感性观察有：  </p>\n<ol>\n<li>Specular highlights (镜面反射高光)</li>\n<li>Diffuse reflection (漫反射)</li>\n<li>Ambient lighting (环境光)</li>\n</ol>\n<p><img src=\"/article_img/2022-08-29-15-14-39.png\"></p>\n<h2 id=\"漫反射\"><a href=\"#漫反射\" class=\"headerlink\" title=\"漫反射\"></a>漫反射</h2><p>认为漫反射是均匀的向各个方向反射的</p>\n<p><img src=\"/article_img/2022-08-29-15-18-27.png\"></p>\n<p><img src=\"/article_img/2022-08-29-15-18-42.png\"></p>\n<p>由上图以及地球的季节变化可知，光线直射方向和平面的夹角决定接受光的能量的多少。</p>\n<p><img src=\"/article_img/2022-08-29-15-20-23.png\"></p>\n<p>光的能量也与距离光源的距离有关，与距光源的距离的平方成反比。</p>\n<p><img src=\"/article_img/2022-08-29-15-23-14.png\"></p>\n<p>法线n·入射光l &#x3D; cos夹角</p>\n<p>kd 表示该shading point的颜色（之后texture贴图就是改变kd的值）</p>\n<p><strong>漫反射的着色与观测角度无关</strong> 也就是说无论在哪个方向观测，同一个着色点的颜色总是相同。例如：月球表面</p>\n<h2 id=\"镜面反射\"><a href=\"#镜面反射\" class=\"headerlink\" title=\"镜面反射\"></a>镜面反射</h2><p><img src=\"/article_img/2022-08-29-15-35-09.png\"></p>\n<p><strong>镜面反射与观测角度有关</strong> 纯镜面即完全按照镜面反射规律进行反射，若是光滑一些的物体如金属，是在镜面反射出射光线的一个角度范围内可见。</p>\n<p><img src=\"/article_img/2022-08-29-15-38-15.png\"></p>\n<p>h是半程向量，这里的bisector是OpenGL中的函数(平行四边形法则)。指数p就是为了控制出射光线的可见角度范围，一般p为200左右（出射光线的左右5-6度）</p>\n<p><img src=\"/article_img/2022-08-29-15-39-32.png\"></p>\n<h2 id=\"环境光\"><a href=\"#环境光\" class=\"headerlink\" title=\"环境光\"></a>环境光</h2><p>在Blinn-Phong这个经验模型中，环境光被认为与任何东西都无关，即是一个常量。</p>\n<p>将三种光照相加即可得到最终的着色结果。</p>\n<p><img src=\"/article_img/2022-08-29-15-42-40.png\"></p>\n<h1 id=\"着色频率（Shading-Frequencies）\"><a href=\"#着色频率（Shading-Frequencies）\" class=\"headerlink\" title=\"着色频率（Shading Frequencies）\"></a>着色频率（Shading Frequencies）</h1><p><img src=\"/article_img/2022-08-29-15-48-55.png\"></p>\n<h2 id=\"flat-shading\"><a href=\"#flat-shading\" class=\"headerlink\" title=\"flat shading\"></a>flat shading</h2><p>对每个<strong>三角形</strong>进行着色</p>\n<p>每一个三角形有一条法线。</p>\n<p><img src=\"/article_img/2022-08-29-15-49-44.png\"></p>\n<h2 id=\"Gouraud-shading\"><a href=\"#Gouraud-shading\" class=\"headerlink\" title=\"Gouraud shading\"></a>Gouraud shading</h2><p>对每个<strong>顶点</strong>进行着色</p>\n<p>对三角形内部的点，根据三个顶点的颜色进行颜色插值，每一个顶点有一条法线。</p>\n<p><img src=\"/article_img/2022-08-29-15-50-45.png\"></p>\n<h2 id=\"Phong-shading\"><a href=\"#Phong-shading\" class=\"headerlink\" title=\"Phong shading\"></a>Phong shading</h2><p>对每个<strong>像素</strong>进行着色</p>\n<p>对三角形内部的点，根据三个顶点的法线进行法线插值，计算出每一个像素的法线。</p>\n<p><img src=\"/article_img/2022-08-29-15-51-54.png\"></p>\n<h2 id=\"法线定义方法\"><a href=\"#法线定义方法\" class=\"headerlink\" title=\"法线定义方法\"></a>法线定义方法</h2><p><img src=\"/article_img/2022-08-29-16-17-54.png\"></p>\n<p><img src=\"/article_img/2022-08-29-16-18-04.png\"></p>\n<p>利用重心坐标插值</p>\n<h1 id=\"重心坐标（Barycentric-Coordinates）\"><a href=\"#重心坐标（Barycentric-Coordinates）\" class=\"headerlink\" title=\"重心坐标（Barycentric Coordinates）\"></a>重心坐标（Barycentric Coordinates）</h1><p><img src=\"/article_img/2022-08-29-16-22-31.png\"></p>\n<p><img src=\"/article_img/2022-08-29-16-23-23.png\"></p>\n<p>系数均为1&#x2F;3时，就是三角形的重心。</p>\n<p><img src=\"/article_img/2022-08-29-16-24-37.png\"></p>\n<p><img src=\"/article_img/2022-08-29-16-24-47.png\"></p>\n<p>插值可以对任何属性进行插值，例如颜色，纹理，法线，深度等等。</p>\n<p>重心坐标在投影变换后无法保证依然正确，因此要在投影变换之前进行插值，也就是要用空间中的坐标进行计算。</p>\n<h1 id=\"图形（实时渲染）管线\"><a href=\"#图形（实时渲染）管线\" class=\"headerlink\" title=\"图形（实时渲染）管线\"></a>图形（实时渲染）管线</h1><p><img src=\"/article_img/2022-08-29-16-29-49.png\"></p>\n<h1 id=\"Texture-Mapping-amp-应用纹理\"><a href=\"#Texture-Mapping-amp-应用纹理\" class=\"headerlink\" title=\"Texture Mapping &amp; 应用纹理\"></a>Texture Mapping &amp; 应用纹理</h1><p><img src=\"/article_img/2022-08-29-16-32-11.png\"></p>\n<p><img src=\"/article_img/2022-08-29-16-32-22.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-30-33.png\"></p>\n<h1 id=\"Texture-Magnification-纹理过大过小问题\"><a href=\"#Texture-Magnification-纹理过大过小问题\" class=\"headerlink\" title=\"Texture Magnification (纹理过大过小问题)\"></a>Texture Magnification (纹理过大过小问题)</h1><h2 id=\"纹理分辨率过小\"><a href=\"#纹理分辨率过小\" class=\"headerlink\" title=\"纹理分辨率过小\"></a>纹理分辨率过小</h2><p><img src=\"/article_img/2022-08-29-18-33-36.png\"></p>\n<p>Bilinear Interpolation (双线性插值)</p>\n<p><img src=\"/article_img/2022-08-29-18-33-20.png\"></p>\n<h2 id=\"纹理分辨率过大\"><a href=\"#纹理分辨率过大\" class=\"headerlink\" title=\"纹理分辨率过大\"></a>纹理分辨率过大</h2><p><img src=\"/article_img/2022-08-29-18-35-15.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-35-24.png\"></p>\n<p>问题在于一个像素里包含了很大一片纹理，而仅用一个纹理上的采样点代表这一片纹理。<strong>超采样</strong>（Supersampling）当让可以解决这个问题，但是消耗太大。为了解决这种问题就引入了Mipmap。</p>\n<h2 id=\"Mipmap\"><a href=\"#Mipmap\" class=\"headerlink\" title=\"Mipmap\"></a>Mipmap</h2><p><img src=\"/article_img/2022-08-29-18-41-41.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-41-51.png\"></p>\n<p>mipmap的思路是避免采样，直接得到一片区域的平均值，提前生成不同分辨率的图像，之后用这些生成的低分辨率图像代表这一片区域的平均，mipmap多消耗的存储空间是原来的三倍。</p>\n<p><img src=\"/article_img/2022-08-29-18-44-02.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-52-05.png\"></p>\n<p>之后进行trilinear插值，让mipmap的level可以平滑过渡。得到下图的可视化结果。</p>\n<p><img src=\"/article_img/2022-08-29-18-53-37.png\"></p>\n<h2 id=\"Mipmap的局限\"><a href=\"#Mipmap的局限\" class=\"headerlink\" title=\"Mipmap的局限\"></a>Mipmap的局限</h2><p><img src=\"/article_img/2022-08-29-18-54-29.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-54-37.png\"></p>\n<p>由于Mipmap是用一个正方形区域近似真正被像素覆盖的区域，对上图这种长条形的区域就无法取得比较好的近似效果，就会产生过度模糊。</p>\n<p>为了避免过度模糊，引入了各向异性过滤。</p>\n<p><img src=\"/article_img/2022-08-29-18-56-35.png\"></p>\n<h1 id=\"环境贴图\"><a href=\"#环境贴图\" class=\"headerlink\" title=\"环境贴图\"></a>环境贴图</h1><p><img src=\"/article_img/2022-08-29-19-00-41.png\"></p>\n<p><img src=\"/article_img/2022-08-29-19-00-52.png\"></p>\n<h1 id=\"凹凸-x2F-法线贴图（Bump-x2F-normal-mapping）\"><a href=\"#凹凸-x2F-法线贴图（Bump-x2F-normal-mapping）\" class=\"headerlink\" title=\"凹凸&#x2F;法线贴图（Bump&#x2F;normal mapping）\"></a>凹凸&#x2F;法线贴图（Bump&#x2F;normal mapping）</h1><p><img src=\"/article_img/2022-08-29-19-04-50.png\"></p>\n<p><img src=\"/article_img/2022-08-29-19-06-16.png\"></p>\n<p>先求出p点的切线向量，之后旋转九十度就可得到新的法线向量。</p>\n<p><img src=\"/article_img/2022-08-29-19-06-26.png\"></p>\n<p>3d坐标原理类似。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=9&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf\">GAMES101_Lecture_07.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_08.pdf\">GAMES101_Lecture_08.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_09.pdf\">GAMES101_Lecture_09.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_10.pdf\">GAMES101_Lecture_10.pdf</a></p>\n","site":{"data":{}},"wordcount":1464,"excerpt":"<p>Games101-4-着色</p>","more":"<h1 id=\"着色模型（Blinn-Phong-Reflectance-Model）\"><a href=\"#着色模型（Blinn-Phong-Reflectance-Model）\" class=\"headerlink\" title=\"着色模型（Blinn-Phong Reflectance Model）\"></a>着色模型（Blinn-Phong Reflectance Model）</h1><p>根据感性观察有：  </p>\n<ol>\n<li>Specular highlights (镜面反射高光)</li>\n<li>Diffuse reflection (漫反射)</li>\n<li>Ambient lighting (环境光)</li>\n</ol>\n<p><img src=\"/article_img/2022-08-29-15-14-39.png\"></p>\n<h2 id=\"漫反射\"><a href=\"#漫反射\" class=\"headerlink\" title=\"漫反射\"></a>漫反射</h2><p>认为漫反射是均匀的向各个方向反射的</p>\n<p><img src=\"/article_img/2022-08-29-15-18-27.png\"></p>\n<p><img src=\"/article_img/2022-08-29-15-18-42.png\"></p>\n<p>由上图以及地球的季节变化可知，光线直射方向和平面的夹角决定接受光的能量的多少。</p>\n<p><img src=\"/article_img/2022-08-29-15-20-23.png\"></p>\n<p>光的能量也与距离光源的距离有关，与距光源的距离的平方成反比。</p>\n<p><img src=\"/article_img/2022-08-29-15-23-14.png\"></p>\n<p>法线n·入射光l &#x3D; cos夹角</p>\n<p>kd 表示该shading point的颜色（之后texture贴图就是改变kd的值）</p>\n<p><strong>漫反射的着色与观测角度无关</strong> 也就是说无论在哪个方向观测，同一个着色点的颜色总是相同。例如：月球表面</p>\n<h2 id=\"镜面反射\"><a href=\"#镜面反射\" class=\"headerlink\" title=\"镜面反射\"></a>镜面反射</h2><p><img src=\"/article_img/2022-08-29-15-35-09.png\"></p>\n<p><strong>镜面反射与观测角度有关</strong> 纯镜面即完全按照镜面反射规律进行反射，若是光滑一些的物体如金属，是在镜面反射出射光线的一个角度范围内可见。</p>\n<p><img src=\"/article_img/2022-08-29-15-38-15.png\"></p>\n<p>h是半程向量，这里的bisector是OpenGL中的函数(平行四边形法则)。指数p就是为了控制出射光线的可见角度范围，一般p为200左右（出射光线的左右5-6度）</p>\n<p><img src=\"/article_img/2022-08-29-15-39-32.png\"></p>\n<h2 id=\"环境光\"><a href=\"#环境光\" class=\"headerlink\" title=\"环境光\"></a>环境光</h2><p>在Blinn-Phong这个经验模型中，环境光被认为与任何东西都无关，即是一个常量。</p>\n<p>将三种光照相加即可得到最终的着色结果。</p>\n<p><img src=\"/article_img/2022-08-29-15-42-40.png\"></p>\n<h1 id=\"着色频率（Shading-Frequencies）\"><a href=\"#着色频率（Shading-Frequencies）\" class=\"headerlink\" title=\"着色频率（Shading Frequencies）\"></a>着色频率（Shading Frequencies）</h1><p><img src=\"/article_img/2022-08-29-15-48-55.png\"></p>\n<h2 id=\"flat-shading\"><a href=\"#flat-shading\" class=\"headerlink\" title=\"flat shading\"></a>flat shading</h2><p>对每个<strong>三角形</strong>进行着色</p>\n<p>每一个三角形有一条法线。</p>\n<p><img src=\"/article_img/2022-08-29-15-49-44.png\"></p>\n<h2 id=\"Gouraud-shading\"><a href=\"#Gouraud-shading\" class=\"headerlink\" title=\"Gouraud shading\"></a>Gouraud shading</h2><p>对每个<strong>顶点</strong>进行着色</p>\n<p>对三角形内部的点，根据三个顶点的颜色进行颜色插值，每一个顶点有一条法线。</p>\n<p><img src=\"/article_img/2022-08-29-15-50-45.png\"></p>\n<h2 id=\"Phong-shading\"><a href=\"#Phong-shading\" class=\"headerlink\" title=\"Phong shading\"></a>Phong shading</h2><p>对每个<strong>像素</strong>进行着色</p>\n<p>对三角形内部的点，根据三个顶点的法线进行法线插值，计算出每一个像素的法线。</p>\n<p><img src=\"/article_img/2022-08-29-15-51-54.png\"></p>\n<h2 id=\"法线定义方法\"><a href=\"#法线定义方法\" class=\"headerlink\" title=\"法线定义方法\"></a>法线定义方法</h2><p><img src=\"/article_img/2022-08-29-16-17-54.png\"></p>\n<p><img src=\"/article_img/2022-08-29-16-18-04.png\"></p>\n<p>利用重心坐标插值</p>\n<h1 id=\"重心坐标（Barycentric-Coordinates）\"><a href=\"#重心坐标（Barycentric-Coordinates）\" class=\"headerlink\" title=\"重心坐标（Barycentric Coordinates）\"></a>重心坐标（Barycentric Coordinates）</h1><p><img src=\"/article_img/2022-08-29-16-22-31.png\"></p>\n<p><img src=\"/article_img/2022-08-29-16-23-23.png\"></p>\n<p>系数均为1&#x2F;3时，就是三角形的重心。</p>\n<p><img src=\"/article_img/2022-08-29-16-24-37.png\"></p>\n<p><img src=\"/article_img/2022-08-29-16-24-47.png\"></p>\n<p>插值可以对任何属性进行插值，例如颜色，纹理，法线，深度等等。</p>\n<p>重心坐标在投影变换后无法保证依然正确，因此要在投影变换之前进行插值，也就是要用空间中的坐标进行计算。</p>\n<h1 id=\"图形（实时渲染）管线\"><a href=\"#图形（实时渲染）管线\" class=\"headerlink\" title=\"图形（实时渲染）管线\"></a>图形（实时渲染）管线</h1><p><img src=\"/article_img/2022-08-29-16-29-49.png\"></p>\n<h1 id=\"Texture-Mapping-amp-应用纹理\"><a href=\"#Texture-Mapping-amp-应用纹理\" class=\"headerlink\" title=\"Texture Mapping &amp; 应用纹理\"></a>Texture Mapping &amp; 应用纹理</h1><p><img src=\"/article_img/2022-08-29-16-32-11.png\"></p>\n<p><img src=\"/article_img/2022-08-29-16-32-22.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-30-33.png\"></p>\n<h1 id=\"Texture-Magnification-纹理过大过小问题\"><a href=\"#Texture-Magnification-纹理过大过小问题\" class=\"headerlink\" title=\"Texture Magnification (纹理过大过小问题)\"></a>Texture Magnification (纹理过大过小问题)</h1><h2 id=\"纹理分辨率过小\"><a href=\"#纹理分辨率过小\" class=\"headerlink\" title=\"纹理分辨率过小\"></a>纹理分辨率过小</h2><p><img src=\"/article_img/2022-08-29-18-33-36.png\"></p>\n<p>Bilinear Interpolation (双线性插值)</p>\n<p><img src=\"/article_img/2022-08-29-18-33-20.png\"></p>\n<h2 id=\"纹理分辨率过大\"><a href=\"#纹理分辨率过大\" class=\"headerlink\" title=\"纹理分辨率过大\"></a>纹理分辨率过大</h2><p><img src=\"/article_img/2022-08-29-18-35-15.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-35-24.png\"></p>\n<p>问题在于一个像素里包含了很大一片纹理，而仅用一个纹理上的采样点代表这一片纹理。<strong>超采样</strong>（Supersampling）当让可以解决这个问题，但是消耗太大。为了解决这种问题就引入了Mipmap。</p>\n<h2 id=\"Mipmap\"><a href=\"#Mipmap\" class=\"headerlink\" title=\"Mipmap\"></a>Mipmap</h2><p><img src=\"/article_img/2022-08-29-18-41-41.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-41-51.png\"></p>\n<p>mipmap的思路是避免采样，直接得到一片区域的平均值，提前生成不同分辨率的图像，之后用这些生成的低分辨率图像代表这一片区域的平均，mipmap多消耗的存储空间是原来的三倍。</p>\n<p><img src=\"/article_img/2022-08-29-18-44-02.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-52-05.png\"></p>\n<p>之后进行trilinear插值，让mipmap的level可以平滑过渡。得到下图的可视化结果。</p>\n<p><img src=\"/article_img/2022-08-29-18-53-37.png\"></p>\n<h2 id=\"Mipmap的局限\"><a href=\"#Mipmap的局限\" class=\"headerlink\" title=\"Mipmap的局限\"></a>Mipmap的局限</h2><p><img src=\"/article_img/2022-08-29-18-54-29.png\"></p>\n<p><img src=\"/article_img/2022-08-29-18-54-37.png\"></p>\n<p>由于Mipmap是用一个正方形区域近似真正被像素覆盖的区域，对上图这种长条形的区域就无法取得比较好的近似效果，就会产生过度模糊。</p>\n<p>为了避免过度模糊，引入了各向异性过滤。</p>\n<p><img src=\"/article_img/2022-08-29-18-56-35.png\"></p>\n<h1 id=\"环境贴图\"><a href=\"#环境贴图\" class=\"headerlink\" title=\"环境贴图\"></a>环境贴图</h1><p><img src=\"/article_img/2022-08-29-19-00-41.png\"></p>\n<p><img src=\"/article_img/2022-08-29-19-00-52.png\"></p>\n<h1 id=\"凹凸-x2F-法线贴图（Bump-x2F-normal-mapping）\"><a href=\"#凹凸-x2F-法线贴图（Bump-x2F-normal-mapping）\" class=\"headerlink\" title=\"凹凸&#x2F;法线贴图（Bump&#x2F;normal mapping）\"></a>凹凸&#x2F;法线贴图（Bump&#x2F;normal mapping）</h1><p><img src=\"/article_img/2022-08-29-19-04-50.png\"></p>\n<p><img src=\"/article_img/2022-08-29-19-06-16.png\"></p>\n<p>先求出p点的切线向量，之后旋转九十度就可得到新的法线向量。</p>\n<p><img src=\"/article_img/2022-08-29-19-06-26.png\"></p>\n<p>3d坐标原理类似。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=9&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_07.pdf\">GAMES101_Lecture_07.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_08.pdf\">GAMES101_Lecture_08.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_09.pdf\">GAMES101_Lecture_09.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_10.pdf\">GAMES101_Lecture_10.pdf</a></p>"},{"title":"Games101-7-辐射度量学","date":"2022-10-11T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-7-辐射度量学\n<!-- more -->\n\n# 基础物理概念\n\n![](/article_img/2022-10-12-12-03-15.png)\n\n## Radiant Energy and Flux(Power)\n\n![](/article_img/2022-10-12-11-59-26.png)\n\nFlux（Power） : energy per unit time（单位时间的能量）\n\n可以理解为某一时刻的能量\n\nFlux的单位Lumen（流明）\n\n## Radiant Intensity\n\n某一个方向上的亮度（能量）\n\n![](/article_img/2022-10-12-12-04-58.png)\n\n### 立体角（Solid Angles）\n\n![](/article_img/2022-10-12-12-08-22.png)\n\n![](/article_img/2022-10-12-12-12-57.png)\n\n## Irradiance\n\n![](/article_img/2022-10-12-12-28-37.png)\n\n这个面积是要做投影，就是要计算垂直角度上的能量，类似于Lambert's Cosine law：\n\n![](/article_img/2022-10-12-12-30-45.png)\n\n正确理解Falloff\n\n![](/article_img/2022-10-12-12-34-50.png)\n\n越远球壳面积越大，能量（Flux/Power）总体不变，单位面积上的能量——Irradiance就越小。\n\n## Radiance\n\n![](/article_img/2022-10-12-12-38-07.png)\n\n某一个面积向某一个方向辐射多少能量。\n\n![](/article_img/2022-10-12-12-40-29.png)\n\n就是把Irradiance（单位面积上总共收到多少能量）分解到各个方向（从某一个方向收到了多少能量）。\n\n![](/article_img/2022-10-12-12-46-03.png)\n\n# BRDF\n\n双向反射分布函数 (Bidirectional ReflectanceDistribution Function）\n\n![](/article_img/2022-10-12-12-51-23.png)\n\n从某一方向发射来的radiance会转化为反射点的irradiance，之后这些能量（irradiance）再转化为从另一个方向射出的radiance.\n\n![](/article_img/2022-10-12-12-57-17.png)\n\nBRDF就是定义**向某个方向辐射的能量**（radiance）与**入射点能量**（irradiance）的比例。\n\n# 反射方程\n\n任何一个方向入射的radiance到着色点，经过BRDF会得到向观测方向射出的radiance；将所有的入射radiance积分起来，就能得到最终看到着色点应该是什么样。\n\n![](/article_img/2022-10-12-13-03-11.png)\n\n递归:\n\n![](/article_img/2022-10-12-13-10-52.png)\n\n# 渲染方程\n\n渲染方程 = 自发光 + 反射方程\n\n![](/article_img/2022-10-12-13-12-07.png)\n\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=14&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_14.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf)  \n[GAMES101_Lecture_15.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf)  \n","source":"_posts/Games101-7-辐射度量学.md","raw":"---\ntitle: Games101-7-辐射度量学\ndate: 2022-10-12\nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-7-辐射度量学\n<!-- more -->\n\n# 基础物理概念\n\n![](/article_img/2022-10-12-12-03-15.png)\n\n## Radiant Energy and Flux(Power)\n\n![](/article_img/2022-10-12-11-59-26.png)\n\nFlux（Power） : energy per unit time（单位时间的能量）\n\n可以理解为某一时刻的能量\n\nFlux的单位Lumen（流明）\n\n## Radiant Intensity\n\n某一个方向上的亮度（能量）\n\n![](/article_img/2022-10-12-12-04-58.png)\n\n### 立体角（Solid Angles）\n\n![](/article_img/2022-10-12-12-08-22.png)\n\n![](/article_img/2022-10-12-12-12-57.png)\n\n## Irradiance\n\n![](/article_img/2022-10-12-12-28-37.png)\n\n这个面积是要做投影，就是要计算垂直角度上的能量，类似于Lambert's Cosine law：\n\n![](/article_img/2022-10-12-12-30-45.png)\n\n正确理解Falloff\n\n![](/article_img/2022-10-12-12-34-50.png)\n\n越远球壳面积越大，能量（Flux/Power）总体不变，单位面积上的能量——Irradiance就越小。\n\n## Radiance\n\n![](/article_img/2022-10-12-12-38-07.png)\n\n某一个面积向某一个方向辐射多少能量。\n\n![](/article_img/2022-10-12-12-40-29.png)\n\n就是把Irradiance（单位面积上总共收到多少能量）分解到各个方向（从某一个方向收到了多少能量）。\n\n![](/article_img/2022-10-12-12-46-03.png)\n\n# BRDF\n\n双向反射分布函数 (Bidirectional ReflectanceDistribution Function）\n\n![](/article_img/2022-10-12-12-51-23.png)\n\n从某一方向发射来的radiance会转化为反射点的irradiance，之后这些能量（irradiance）再转化为从另一个方向射出的radiance.\n\n![](/article_img/2022-10-12-12-57-17.png)\n\nBRDF就是定义**向某个方向辐射的能量**（radiance）与**入射点能量**（irradiance）的比例。\n\n# 反射方程\n\n任何一个方向入射的radiance到着色点，经过BRDF会得到向观测方向射出的radiance；将所有的入射radiance积分起来，就能得到最终看到着色点应该是什么样。\n\n![](/article_img/2022-10-12-13-03-11.png)\n\n递归:\n\n![](/article_img/2022-10-12-13-10-52.png)\n\n# 渲染方程\n\n渲染方程 = 自发光 + 反射方程\n\n![](/article_img/2022-10-12-13-12-07.png)\n\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=14&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_14.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf)  \n[GAMES101_Lecture_15.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf)  \n","slug":"Games101-7-辐射度量学","published":1,"updated":"2022-10-14T05:25:45.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglt000ow0jegn3kfo1l","content":"<p>Games101-7-辐射度量学</p>\n<span id=\"more\"></span>\n\n<h1 id=\"基础物理概念\"><a href=\"#基础物理概念\" class=\"headerlink\" title=\"基础物理概念\"></a>基础物理概念</h1><p><img src=\"/article_img/2022-10-12-12-03-15.png\"></p>\n<h2 id=\"Radiant-Energy-and-Flux-Power\"><a href=\"#Radiant-Energy-and-Flux-Power\" class=\"headerlink\" title=\"Radiant Energy and Flux(Power)\"></a>Radiant Energy and Flux(Power)</h2><p><img src=\"/article_img/2022-10-12-11-59-26.png\"></p>\n<p>Flux（Power） : energy per unit time（单位时间的能量）</p>\n<p>可以理解为某一时刻的能量</p>\n<p>Flux的单位Lumen（流明）</p>\n<h2 id=\"Radiant-Intensity\"><a href=\"#Radiant-Intensity\" class=\"headerlink\" title=\"Radiant Intensity\"></a>Radiant Intensity</h2><p>某一个方向上的亮度（能量）</p>\n<p><img src=\"/article_img/2022-10-12-12-04-58.png\"></p>\n<h3 id=\"立体角（Solid-Angles）\"><a href=\"#立体角（Solid-Angles）\" class=\"headerlink\" title=\"立体角（Solid Angles）\"></a>立体角（Solid Angles）</h3><p><img src=\"/article_img/2022-10-12-12-08-22.png\"></p>\n<p><img src=\"/article_img/2022-10-12-12-12-57.png\"></p>\n<h2 id=\"Irradiance\"><a href=\"#Irradiance\" class=\"headerlink\" title=\"Irradiance\"></a>Irradiance</h2><p><img src=\"/article_img/2022-10-12-12-28-37.png\"></p>\n<p>这个面积是要做投影，就是要计算垂直角度上的能量，类似于Lambert’s Cosine law：</p>\n<p><img src=\"/article_img/2022-10-12-12-30-45.png\"></p>\n<p>正确理解Falloff</p>\n<p><img src=\"/article_img/2022-10-12-12-34-50.png\"></p>\n<p>越远球壳面积越大，能量（Flux&#x2F;Power）总体不变，单位面积上的能量——Irradiance就越小。</p>\n<h2 id=\"Radiance\"><a href=\"#Radiance\" class=\"headerlink\" title=\"Radiance\"></a>Radiance</h2><p><img src=\"/article_img/2022-10-12-12-38-07.png\"></p>\n<p>某一个面积向某一个方向辐射多少能量。</p>\n<p><img src=\"/article_img/2022-10-12-12-40-29.png\"></p>\n<p>就是把Irradiance（单位面积上总共收到多少能量）分解到各个方向（从某一个方向收到了多少能量）。</p>\n<p><img src=\"/article_img/2022-10-12-12-46-03.png\"></p>\n<h1 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h1><p>双向反射分布函数 (Bidirectional ReflectanceDistribution Function）</p>\n<p><img src=\"/article_img/2022-10-12-12-51-23.png\"></p>\n<p>从某一方向发射来的radiance会转化为反射点的irradiance，之后这些能量（irradiance）再转化为从另一个方向射出的radiance.</p>\n<p><img src=\"/article_img/2022-10-12-12-57-17.png\"></p>\n<p>BRDF就是定义<strong>向某个方向辐射的能量</strong>（radiance）与<strong>入射点能量</strong>（irradiance）的比例。</p>\n<h1 id=\"反射方程\"><a href=\"#反射方程\" class=\"headerlink\" title=\"反射方程\"></a>反射方程</h1><p>任何一个方向入射的radiance到着色点，经过BRDF会得到向观测方向射出的radiance；将所有的入射radiance积分起来，就能得到最终看到着色点应该是什么样。</p>\n<p><img src=\"/article_img/2022-10-12-13-03-11.png\"></p>\n<p>递归:</p>\n<p><img src=\"/article_img/2022-10-12-13-10-52.png\"></p>\n<h1 id=\"渲染方程\"><a href=\"#渲染方程\" class=\"headerlink\" title=\"渲染方程\"></a>渲染方程</h1><p>渲染方程 &#x3D; 自发光 + 反射方程</p>\n<p><img src=\"/article_img/2022-10-12-13-12-07.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=14&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf\">GAMES101_Lecture_14.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf\">GAMES101_Lecture_15.pdf</a>  </p>\n","site":{"data":{}},"wordcount":730,"excerpt":"<p>Games101-7-辐射度量学</p>","more":"<h1 id=\"基础物理概念\"><a href=\"#基础物理概念\" class=\"headerlink\" title=\"基础物理概念\"></a>基础物理概念</h1><p><img src=\"/article_img/2022-10-12-12-03-15.png\"></p>\n<h2 id=\"Radiant-Energy-and-Flux-Power\"><a href=\"#Radiant-Energy-and-Flux-Power\" class=\"headerlink\" title=\"Radiant Energy and Flux(Power)\"></a>Radiant Energy and Flux(Power)</h2><p><img src=\"/article_img/2022-10-12-11-59-26.png\"></p>\n<p>Flux（Power） : energy per unit time（单位时间的能量）</p>\n<p>可以理解为某一时刻的能量</p>\n<p>Flux的单位Lumen（流明）</p>\n<h2 id=\"Radiant-Intensity\"><a href=\"#Radiant-Intensity\" class=\"headerlink\" title=\"Radiant Intensity\"></a>Radiant Intensity</h2><p>某一个方向上的亮度（能量）</p>\n<p><img src=\"/article_img/2022-10-12-12-04-58.png\"></p>\n<h3 id=\"立体角（Solid-Angles）\"><a href=\"#立体角（Solid-Angles）\" class=\"headerlink\" title=\"立体角（Solid Angles）\"></a>立体角（Solid Angles）</h3><p><img src=\"/article_img/2022-10-12-12-08-22.png\"></p>\n<p><img src=\"/article_img/2022-10-12-12-12-57.png\"></p>\n<h2 id=\"Irradiance\"><a href=\"#Irradiance\" class=\"headerlink\" title=\"Irradiance\"></a>Irradiance</h2><p><img src=\"/article_img/2022-10-12-12-28-37.png\"></p>\n<p>这个面积是要做投影，就是要计算垂直角度上的能量，类似于Lambert’s Cosine law：</p>\n<p><img src=\"/article_img/2022-10-12-12-30-45.png\"></p>\n<p>正确理解Falloff</p>\n<p><img src=\"/article_img/2022-10-12-12-34-50.png\"></p>\n<p>越远球壳面积越大，能量（Flux&#x2F;Power）总体不变，单位面积上的能量——Irradiance就越小。</p>\n<h2 id=\"Radiance\"><a href=\"#Radiance\" class=\"headerlink\" title=\"Radiance\"></a>Radiance</h2><p><img src=\"/article_img/2022-10-12-12-38-07.png\"></p>\n<p>某一个面积向某一个方向辐射多少能量。</p>\n<p><img src=\"/article_img/2022-10-12-12-40-29.png\"></p>\n<p>就是把Irradiance（单位面积上总共收到多少能量）分解到各个方向（从某一个方向收到了多少能量）。</p>\n<p><img src=\"/article_img/2022-10-12-12-46-03.png\"></p>\n<h1 id=\"BRDF\"><a href=\"#BRDF\" class=\"headerlink\" title=\"BRDF\"></a>BRDF</h1><p>双向反射分布函数 (Bidirectional ReflectanceDistribution Function）</p>\n<p><img src=\"/article_img/2022-10-12-12-51-23.png\"></p>\n<p>从某一方向发射来的radiance会转化为反射点的irradiance，之后这些能量（irradiance）再转化为从另一个方向射出的radiance.</p>\n<p><img src=\"/article_img/2022-10-12-12-57-17.png\"></p>\n<p>BRDF就是定义<strong>向某个方向辐射的能量</strong>（radiance）与<strong>入射点能量</strong>（irradiance）的比例。</p>\n<h1 id=\"反射方程\"><a href=\"#反射方程\" class=\"headerlink\" title=\"反射方程\"></a>反射方程</h1><p>任何一个方向入射的radiance到着色点，经过BRDF会得到向观测方向射出的radiance；将所有的入射radiance积分起来，就能得到最终看到着色点应该是什么样。</p>\n<p><img src=\"/article_img/2022-10-12-13-03-11.png\"></p>\n<p>递归:</p>\n<p><img src=\"/article_img/2022-10-12-13-10-52.png\"></p>\n<h1 id=\"渲染方程\"><a href=\"#渲染方程\" class=\"headerlink\" title=\"渲染方程\"></a>渲染方程</h1><p>渲染方程 &#x3D; 自发光 + 反射方程</p>\n<p><img src=\"/article_img/2022-10-12-13-12-07.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=14&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf\">GAMES101_Lecture_14.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf\">GAMES101_Lecture_15.pdf</a>  </p>"},{"title":"Games101-6-光线追踪(Whitted-Style)","date":"2022-10-10T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-6-光线追踪(Whitted-Style)\n<!-- more -->\n\n# 为什么要用光线追踪\n\n光栅化无法生成效果好的环境光，如软阴影。\n\n光栅化效果一般但是渲染速度很快，光线追踪效果很好但是渲染速度慢。\n\n![](/article_img/2022-10-11-17-42-00.png)\n\n# Whitted-Style 的光线追踪\n\n![](/article_img/2022-10-11-17-42-58.png)\n\n# 光线与表面求交\n\n## 光线方程\n\n![](/article_img/2022-10-11-17-45-24.png)\n\n## 光线与球面求交\n\n![](/article_img/2022-10-11-17-46-35.png)\n\n同理可以推广到光线与所有隐式表面的求交，因为隐式表面有定义其的方程，可以将光线方程带入转化为解方程。\n\n## 光线与三角形求交\n\n### 方法一：先与平面求交\n\n三角形处于一个平面中，首先判断光线是否与该平面相交，再判断是否与三角形相交（交点是否在三角形内部：**叉乘的应用**）。\n\n**平面方程**： 由一个点和一个法相向量定义\n\n![](/article_img/2022-10-11-17-50-28.png)\n\n![](/article_img/2022-10-11-17-54-18.png)\n\n### 方法二：直接利用重心坐标求交\n\n![](/article_img/2022-10-11-17-57-15.png)\n\nRecall：重心坐标由三个点定义，可以表示这三个点所在平面的任意点。当系数都为正的时候表示点在三角形内。\n\n![](/article_img/2022-08-29-16-22-31.png)\n\n# 加速结构\n\n## Bounding Volumes(包围盒)\n\n先判断光线是否与包围盒相交，如果不与包围盒相交那就不可能与物体相交。\n\n![](/article_img/2022-10-11-18-08-40.png)\n\n## Axis-Aligned Bounding Box(AABB)\n\n为了简化计算，包围盒都使用轴对齐包围盒。\n\n![](/article_img/2022-10-11-18-10-27.png)\n\n### 与轴对齐包围盒求交\n\n![](/article_img/2022-10-11-18-12-37.png)\n\n将包围盒想象成三对平面围成的，分别用光线与每对平面求交，得到光线进入这对平面的时间 tmin 和射出这对平面的时间 tmax（负值也可以，这里先将光线看作直线）。\n\n**思考**：  \n光线进入包围盒**仅当**光线进入所有三对平面  \n光线射出包围盒**直到**光线离开所有三对平面\n\n因此，就是要求最大的 tmin 和最小的 tmax：\n\n![](/article_img/2022-10-11-18-18-49.png)\n\n![](/article_img/2022-10-11-18-19-43.png)\n\n## 包围盒划分\n\n### Uniform Grids\n![](/article_img/2022-10-11-18-30-32.png)\n\n![](/article_img/2022-10-11-18-30-38.png)\n\n![](/article_img/2022-10-11-18-32-03.png)\n\n仅仅适用于有大量物体且其均匀分布在整个场景中的情况。\n\ne.g. 当一个场景有大量留白只有中间有一个茶壶的情况，这种划分需要光线与大量不包括任何物体的盒子求交，因此效率很低。\n\n### KD-Tree\n\n![](/article_img/2022-10-11-18-35-53.png)\n\n![](/article_img/2022-10-11-18-36-23.png)\n\n但是这种划分有个致命的缺点：难以求得哪些表面与划分出的包围盒相交，因此引出BVH。\n\n## 物体划分（Bounding Volume Hierarchy）\n\n为了避免统计哪些表面与包围盒相交，直接对表面进行划分，再对划分后的表面求新的包围盒。\n\n![](/article_img/2022-10-11-18-40-01.png)\n\n![](/article_img/2022-10-11-18-40-53.png)\n\n![](/article_img/2022-10-11-18-41-58.png)\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=13&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_13.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_13.pdf)  \n[GAMES101_Lecture_14.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf)  \n","source":"_posts/Games101-6-光线追踪(Whitted-Style).md","raw":"---\ntitle: Games101-6-光线追踪(Whitted-Style)\ndate: 2022-10-11\nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-6-光线追踪(Whitted-Style)\n<!-- more -->\n\n# 为什么要用光线追踪\n\n光栅化无法生成效果好的环境光，如软阴影。\n\n光栅化效果一般但是渲染速度很快，光线追踪效果很好但是渲染速度慢。\n\n![](/article_img/2022-10-11-17-42-00.png)\n\n# Whitted-Style 的光线追踪\n\n![](/article_img/2022-10-11-17-42-58.png)\n\n# 光线与表面求交\n\n## 光线方程\n\n![](/article_img/2022-10-11-17-45-24.png)\n\n## 光线与球面求交\n\n![](/article_img/2022-10-11-17-46-35.png)\n\n同理可以推广到光线与所有隐式表面的求交，因为隐式表面有定义其的方程，可以将光线方程带入转化为解方程。\n\n## 光线与三角形求交\n\n### 方法一：先与平面求交\n\n三角形处于一个平面中，首先判断光线是否与该平面相交，再判断是否与三角形相交（交点是否在三角形内部：**叉乘的应用**）。\n\n**平面方程**： 由一个点和一个法相向量定义\n\n![](/article_img/2022-10-11-17-50-28.png)\n\n![](/article_img/2022-10-11-17-54-18.png)\n\n### 方法二：直接利用重心坐标求交\n\n![](/article_img/2022-10-11-17-57-15.png)\n\nRecall：重心坐标由三个点定义，可以表示这三个点所在平面的任意点。当系数都为正的时候表示点在三角形内。\n\n![](/article_img/2022-08-29-16-22-31.png)\n\n# 加速结构\n\n## Bounding Volumes(包围盒)\n\n先判断光线是否与包围盒相交，如果不与包围盒相交那就不可能与物体相交。\n\n![](/article_img/2022-10-11-18-08-40.png)\n\n## Axis-Aligned Bounding Box(AABB)\n\n为了简化计算，包围盒都使用轴对齐包围盒。\n\n![](/article_img/2022-10-11-18-10-27.png)\n\n### 与轴对齐包围盒求交\n\n![](/article_img/2022-10-11-18-12-37.png)\n\n将包围盒想象成三对平面围成的，分别用光线与每对平面求交，得到光线进入这对平面的时间 tmin 和射出这对平面的时间 tmax（负值也可以，这里先将光线看作直线）。\n\n**思考**：  \n光线进入包围盒**仅当**光线进入所有三对平面  \n光线射出包围盒**直到**光线离开所有三对平面\n\n因此，就是要求最大的 tmin 和最小的 tmax：\n\n![](/article_img/2022-10-11-18-18-49.png)\n\n![](/article_img/2022-10-11-18-19-43.png)\n\n## 包围盒划分\n\n### Uniform Grids\n![](/article_img/2022-10-11-18-30-32.png)\n\n![](/article_img/2022-10-11-18-30-38.png)\n\n![](/article_img/2022-10-11-18-32-03.png)\n\n仅仅适用于有大量物体且其均匀分布在整个场景中的情况。\n\ne.g. 当一个场景有大量留白只有中间有一个茶壶的情况，这种划分需要光线与大量不包括任何物体的盒子求交，因此效率很低。\n\n### KD-Tree\n\n![](/article_img/2022-10-11-18-35-53.png)\n\n![](/article_img/2022-10-11-18-36-23.png)\n\n但是这种划分有个致命的缺点：难以求得哪些表面与划分出的包围盒相交，因此引出BVH。\n\n## 物体划分（Bounding Volume Hierarchy）\n\n为了避免统计哪些表面与包围盒相交，直接对表面进行划分，再对划分后的表面求新的包围盒。\n\n![](/article_img/2022-10-11-18-40-01.png)\n\n![](/article_img/2022-10-11-18-40-53.png)\n\n![](/article_img/2022-10-11-18-41-58.png)\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=13&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[课程网址](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_13.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_13.pdf)  \n[GAMES101_Lecture_14.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf)  \n","slug":"Games101-6-光线追踪(Whitted-Style)","published":1,"updated":"2022-10-14T05:25:45.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglv000sw0je6r7ifac3","content":"<p>Games101-6-光线追踪(Whitted-Style)</p>\n<span id=\"more\"></span>\n\n<h1 id=\"为什么要用光线追踪\"><a href=\"#为什么要用光线追踪\" class=\"headerlink\" title=\"为什么要用光线追踪\"></a>为什么要用光线追踪</h1><p>光栅化无法生成效果好的环境光，如软阴影。</p>\n<p>光栅化效果一般但是渲染速度很快，光线追踪效果很好但是渲染速度慢。</p>\n<p><img src=\"/article_img/2022-10-11-17-42-00.png\"></p>\n<h1 id=\"Whitted-Style-的光线追踪\"><a href=\"#Whitted-Style-的光线追踪\" class=\"headerlink\" title=\"Whitted-Style 的光线追踪\"></a>Whitted-Style 的光线追踪</h1><p><img src=\"/article_img/2022-10-11-17-42-58.png\"></p>\n<h1 id=\"光线与表面求交\"><a href=\"#光线与表面求交\" class=\"headerlink\" title=\"光线与表面求交\"></a>光线与表面求交</h1><h2 id=\"光线方程\"><a href=\"#光线方程\" class=\"headerlink\" title=\"光线方程\"></a>光线方程</h2><p><img src=\"/article_img/2022-10-11-17-45-24.png\"></p>\n<h2 id=\"光线与球面求交\"><a href=\"#光线与球面求交\" class=\"headerlink\" title=\"光线与球面求交\"></a>光线与球面求交</h2><p><img src=\"/article_img/2022-10-11-17-46-35.png\"></p>\n<p>同理可以推广到光线与所有隐式表面的求交，因为隐式表面有定义其的方程，可以将光线方程带入转化为解方程。</p>\n<h2 id=\"光线与三角形求交\"><a href=\"#光线与三角形求交\" class=\"headerlink\" title=\"光线与三角形求交\"></a>光线与三角形求交</h2><h3 id=\"方法一：先与平面求交\"><a href=\"#方法一：先与平面求交\" class=\"headerlink\" title=\"方法一：先与平面求交\"></a>方法一：先与平面求交</h3><p>三角形处于一个平面中，首先判断光线是否与该平面相交，再判断是否与三角形相交（交点是否在三角形内部：<strong>叉乘的应用</strong>）。</p>\n<p><strong>平面方程</strong>： 由一个点和一个法相向量定义</p>\n<p><img src=\"/article_img/2022-10-11-17-50-28.png\"></p>\n<p><img src=\"/article_img/2022-10-11-17-54-18.png\"></p>\n<h3 id=\"方法二：直接利用重心坐标求交\"><a href=\"#方法二：直接利用重心坐标求交\" class=\"headerlink\" title=\"方法二：直接利用重心坐标求交\"></a>方法二：直接利用重心坐标求交</h3><p><img src=\"/article_img/2022-10-11-17-57-15.png\"></p>\n<p>Recall：重心坐标由三个点定义，可以表示这三个点所在平面的任意点。当系数都为正的时候表示点在三角形内。</p>\n<p><img src=\"/article_img/2022-08-29-16-22-31.png\"></p>\n<h1 id=\"加速结构\"><a href=\"#加速结构\" class=\"headerlink\" title=\"加速结构\"></a>加速结构</h1><h2 id=\"Bounding-Volumes-包围盒\"><a href=\"#Bounding-Volumes-包围盒\" class=\"headerlink\" title=\"Bounding Volumes(包围盒)\"></a>Bounding Volumes(包围盒)</h2><p>先判断光线是否与包围盒相交，如果不与包围盒相交那就不可能与物体相交。</p>\n<p><img src=\"/article_img/2022-10-11-18-08-40.png\"></p>\n<h2 id=\"Axis-Aligned-Bounding-Box-AABB\"><a href=\"#Axis-Aligned-Bounding-Box-AABB\" class=\"headerlink\" title=\"Axis-Aligned Bounding Box(AABB)\"></a>Axis-Aligned Bounding Box(AABB)</h2><p>为了简化计算，包围盒都使用轴对齐包围盒。</p>\n<p><img src=\"/article_img/2022-10-11-18-10-27.png\"></p>\n<h3 id=\"与轴对齐包围盒求交\"><a href=\"#与轴对齐包围盒求交\" class=\"headerlink\" title=\"与轴对齐包围盒求交\"></a>与轴对齐包围盒求交</h3><p><img src=\"/article_img/2022-10-11-18-12-37.png\"></p>\n<p>将包围盒想象成三对平面围成的，分别用光线与每对平面求交，得到光线进入这对平面的时间 tmin 和射出这对平面的时间 tmax（负值也可以，这里先将光线看作直线）。</p>\n<p><strong>思考</strong>：<br>光线进入包围盒<strong>仅当</strong>光线进入所有三对平面<br>光线射出包围盒<strong>直到</strong>光线离开所有三对平面</p>\n<p>因此，就是要求最大的 tmin 和最小的 tmax：</p>\n<p><img src=\"/article_img/2022-10-11-18-18-49.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-19-43.png\"></p>\n<h2 id=\"包围盒划分\"><a href=\"#包围盒划分\" class=\"headerlink\" title=\"包围盒划分\"></a>包围盒划分</h2><h3 id=\"Uniform-Grids\"><a href=\"#Uniform-Grids\" class=\"headerlink\" title=\"Uniform Grids\"></a>Uniform Grids</h3><p><img src=\"/article_img/2022-10-11-18-30-32.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-30-38.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-32-03.png\"></p>\n<p>仅仅适用于有大量物体且其均匀分布在整个场景中的情况。</p>\n<p>e.g. 当一个场景有大量留白只有中间有一个茶壶的情况，这种划分需要光线与大量不包括任何物体的盒子求交，因此效率很低。</p>\n<h3 id=\"KD-Tree\"><a href=\"#KD-Tree\" class=\"headerlink\" title=\"KD-Tree\"></a>KD-Tree</h3><p><img src=\"/article_img/2022-10-11-18-35-53.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-36-23.png\"></p>\n<p>但是这种划分有个致命的缺点：难以求得哪些表面与划分出的包围盒相交，因此引出BVH。</p>\n<h2 id=\"物体划分（Bounding-Volume-Hierarchy）\"><a href=\"#物体划分（Bounding-Volume-Hierarchy）\" class=\"headerlink\" title=\"物体划分（Bounding Volume Hierarchy）\"></a>物体划分（Bounding Volume Hierarchy）</h2><p>为了避免统计哪些表面与包围盒相交，直接对表面进行划分，再对划分后的表面求新的包围盒。</p>\n<p><img src=\"/article_img/2022-10-11-18-40-01.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-40-53.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-41-58.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=13&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_13.pdf\">GAMES101_Lecture_13.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf\">GAMES101_Lecture_14.pdf</a>  </p>\n","site":{"data":{}},"wordcount":870,"excerpt":"<p>Games101-6-光线追踪(Whitted-Style)</p>","more":"<h1 id=\"为什么要用光线追踪\"><a href=\"#为什么要用光线追踪\" class=\"headerlink\" title=\"为什么要用光线追踪\"></a>为什么要用光线追踪</h1><p>光栅化无法生成效果好的环境光，如软阴影。</p>\n<p>光栅化效果一般但是渲染速度很快，光线追踪效果很好但是渲染速度慢。</p>\n<p><img src=\"/article_img/2022-10-11-17-42-00.png\"></p>\n<h1 id=\"Whitted-Style-的光线追踪\"><a href=\"#Whitted-Style-的光线追踪\" class=\"headerlink\" title=\"Whitted-Style 的光线追踪\"></a>Whitted-Style 的光线追踪</h1><p><img src=\"/article_img/2022-10-11-17-42-58.png\"></p>\n<h1 id=\"光线与表面求交\"><a href=\"#光线与表面求交\" class=\"headerlink\" title=\"光线与表面求交\"></a>光线与表面求交</h1><h2 id=\"光线方程\"><a href=\"#光线方程\" class=\"headerlink\" title=\"光线方程\"></a>光线方程</h2><p><img src=\"/article_img/2022-10-11-17-45-24.png\"></p>\n<h2 id=\"光线与球面求交\"><a href=\"#光线与球面求交\" class=\"headerlink\" title=\"光线与球面求交\"></a>光线与球面求交</h2><p><img src=\"/article_img/2022-10-11-17-46-35.png\"></p>\n<p>同理可以推广到光线与所有隐式表面的求交，因为隐式表面有定义其的方程，可以将光线方程带入转化为解方程。</p>\n<h2 id=\"光线与三角形求交\"><a href=\"#光线与三角形求交\" class=\"headerlink\" title=\"光线与三角形求交\"></a>光线与三角形求交</h2><h3 id=\"方法一：先与平面求交\"><a href=\"#方法一：先与平面求交\" class=\"headerlink\" title=\"方法一：先与平面求交\"></a>方法一：先与平面求交</h3><p>三角形处于一个平面中，首先判断光线是否与该平面相交，再判断是否与三角形相交（交点是否在三角形内部：<strong>叉乘的应用</strong>）。</p>\n<p><strong>平面方程</strong>： 由一个点和一个法相向量定义</p>\n<p><img src=\"/article_img/2022-10-11-17-50-28.png\"></p>\n<p><img src=\"/article_img/2022-10-11-17-54-18.png\"></p>\n<h3 id=\"方法二：直接利用重心坐标求交\"><a href=\"#方法二：直接利用重心坐标求交\" class=\"headerlink\" title=\"方法二：直接利用重心坐标求交\"></a>方法二：直接利用重心坐标求交</h3><p><img src=\"/article_img/2022-10-11-17-57-15.png\"></p>\n<p>Recall：重心坐标由三个点定义，可以表示这三个点所在平面的任意点。当系数都为正的时候表示点在三角形内。</p>\n<p><img src=\"/article_img/2022-08-29-16-22-31.png\"></p>\n<h1 id=\"加速结构\"><a href=\"#加速结构\" class=\"headerlink\" title=\"加速结构\"></a>加速结构</h1><h2 id=\"Bounding-Volumes-包围盒\"><a href=\"#Bounding-Volumes-包围盒\" class=\"headerlink\" title=\"Bounding Volumes(包围盒)\"></a>Bounding Volumes(包围盒)</h2><p>先判断光线是否与包围盒相交，如果不与包围盒相交那就不可能与物体相交。</p>\n<p><img src=\"/article_img/2022-10-11-18-08-40.png\"></p>\n<h2 id=\"Axis-Aligned-Bounding-Box-AABB\"><a href=\"#Axis-Aligned-Bounding-Box-AABB\" class=\"headerlink\" title=\"Axis-Aligned Bounding Box(AABB)\"></a>Axis-Aligned Bounding Box(AABB)</h2><p>为了简化计算，包围盒都使用轴对齐包围盒。</p>\n<p><img src=\"/article_img/2022-10-11-18-10-27.png\"></p>\n<h3 id=\"与轴对齐包围盒求交\"><a href=\"#与轴对齐包围盒求交\" class=\"headerlink\" title=\"与轴对齐包围盒求交\"></a>与轴对齐包围盒求交</h3><p><img src=\"/article_img/2022-10-11-18-12-37.png\"></p>\n<p>将包围盒想象成三对平面围成的，分别用光线与每对平面求交，得到光线进入这对平面的时间 tmin 和射出这对平面的时间 tmax（负值也可以，这里先将光线看作直线）。</p>\n<p><strong>思考</strong>：<br>光线进入包围盒<strong>仅当</strong>光线进入所有三对平面<br>光线射出包围盒<strong>直到</strong>光线离开所有三对平面</p>\n<p>因此，就是要求最大的 tmin 和最小的 tmax：</p>\n<p><img src=\"/article_img/2022-10-11-18-18-49.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-19-43.png\"></p>\n<h2 id=\"包围盒划分\"><a href=\"#包围盒划分\" class=\"headerlink\" title=\"包围盒划分\"></a>包围盒划分</h2><h3 id=\"Uniform-Grids\"><a href=\"#Uniform-Grids\" class=\"headerlink\" title=\"Uniform Grids\"></a>Uniform Grids</h3><p><img src=\"/article_img/2022-10-11-18-30-32.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-30-38.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-32-03.png\"></p>\n<p>仅仅适用于有大量物体且其均匀分布在整个场景中的情况。</p>\n<p>e.g. 当一个场景有大量留白只有中间有一个茶壶的情况，这种划分需要光线与大量不包括任何物体的盒子求交，因此效率很低。</p>\n<h3 id=\"KD-Tree\"><a href=\"#KD-Tree\" class=\"headerlink\" title=\"KD-Tree\"></a>KD-Tree</h3><p><img src=\"/article_img/2022-10-11-18-35-53.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-36-23.png\"></p>\n<p>但是这种划分有个致命的缺点：难以求得哪些表面与划分出的包围盒相交，因此引出BVH。</p>\n<h2 id=\"物体划分（Bounding-Volume-Hierarchy）\"><a href=\"#物体划分（Bounding-Volume-Hierarchy）\" class=\"headerlink\" title=\"物体划分（Bounding Volume Hierarchy）\"></a>物体划分（Bounding Volume Hierarchy）</h2><p>为了避免统计哪些表面与包围盒相交，直接对表面进行划分，再对划分后的表面求新的包围盒。</p>\n<p><img src=\"/article_img/2022-10-11-18-40-01.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-40-53.png\"></p>\n<p><img src=\"/article_img/2022-10-11-18-41-58.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=13&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">课程网址</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_13.pdf\">GAMES101_Lecture_13.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_14.pdf\">GAMES101_Lecture_14.pdf</a>  </p>"},{"title":"Games101-8-路径追踪","date":"2022-10-12T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-8-路径追踪\n<!-- more -->\n\n![](/article_img/2022-10-12-19-16-44.png)\n\n# 概率论知识\n\n![](/article_img/2022-10-12-19-17-41.png)\n\n# Monte Carlo Integration\n\n一种数值方法计算定积分的值，不需要算出原函数。\n\n![](/article_img/2022-10-12-19-20-11.png)\n\n![](/article_img/2022-10-12-19-20-41.png)\n\n![](/article_img/2022-10-12-19-18-35.png)\n\n# 仅考虑直接光照\n\n![](/article_img/2022-10-13-14-37-13.png)\n\n这里的wi是随机在半球上采样\n\n# 引入间接光照\n\n![](/article_img/2022-10-13-14-40-09.png)\n\n直接光照就按照光源来计算，间接光照递归计算\n\n但是还没完：\n\n1. 光线会爆炸\n   ![](/article_img/2022-10-13-14-41-58.png)\n   \n   因此随机选择一条路径进行采样\n\n   ![](/article_img/2022-10-13-14-42-30.png)\n\n   在一个像素中增加采样点，最后平均，来降低噪声\n\n   ![](/article_img/2022-10-13-14-42-38.png)\n\n2. 没有递归出口\n\n   **俄罗斯轮盘赌**\n\n   这里就是利用了**期望**的概念：  \n   事先假定一个概率p，有p的概率发生反射，并且计算的结果除以p，有（1-p）的概率不发生反射，得到0；这种方法得到的结果的期望仍然是Lo，即能量没有损失。\n\n   ![](/article_img/2022-10-13-14-45-56.png)\n\n   ![](/article_img/2022-10-13-14-50-16.png)\n\n# 提高路径追踪效率\n\n![](/article_img/2022-10-13-14-51-20.png)\n\nSPP（samples per pixel）\n\n![](/article_img/2022-10-13-15-58-06.png)\n\n思考为什么low SPP效果不好会出现噪点？\n\n因为我们的采样时在整个半球上随机采样的，而俄罗斯轮盘赌会终结一些光线，导致路径还没有打到光源就被终止，这条路径返回了空值，相当于这次路径追踪白做了（光线被浪费掉了），本质就是采样不足导致的。\n\n因此我们要么加大采样量（增大路径到达光源的概率），要么尽量不要浪费光线，也就是进行重要性采样，对光源采样，就是先计算对该点颜色贡献最大的直接光照。\n\n在对光源采样时，要把光源平面投影到半球面上，也可以理解为求**有效光源**(dA*costheta)的立体角。\n\n![](/article_img/2022-10-14-12-42-03.png)\n\n之后就可以计算Lo\n\n![](/article_img/2022-10-14-12-45-56.png)\n\n现在我们的策略是先计算直接光照（不使用俄罗斯轮盘赌），再计算间接光照（随机在半球中采样，使用俄罗斯轮盘赌）\n\n![](/article_img/2022-10-14-12-49-41.png)\n\n再加上判断直接光照是否被遮挡\n\n伪代码：\n```\nshade(p,wo)\n   # 来自光源的贡献（直接光照）\n   均匀对光源采样 x' (pdf_light = 1/A)\n   Shoot a ray from p to x'\n   if the ray is not blocked in the middle\n      L_dir = L_i * f_r * cos theta' / |x'-p|^2 / pdf_light\n\n   # 来自反射的贡献（间接光照）\n   L_indir = 0.0\n   判断俄罗斯轮盘赌是否终止\n   在半球上均匀采样 wi （pdf_hemi = 1/2pi）\n   Trace a ray r(p, wi)\n   if ray r hit a non-emitting object at q\n      L_indir = shade(q, -wi) * f_r * cos theta / pdf_hemi / P_RR\n   \n   Return L_dir + L_indir\n\n```\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=16&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_15.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf)  \n[GAMES101_Lecture_16.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_16.pdf)  \n","source":"_posts/Games101-8-路径追踪.md","raw":"---\ntitle: Games101-8-路径追踪\ndate: 2022-10-13\nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-8-路径追踪\n<!-- more -->\n\n![](/article_img/2022-10-12-19-16-44.png)\n\n# 概率论知识\n\n![](/article_img/2022-10-12-19-17-41.png)\n\n# Monte Carlo Integration\n\n一种数值方法计算定积分的值，不需要算出原函数。\n\n![](/article_img/2022-10-12-19-20-11.png)\n\n![](/article_img/2022-10-12-19-20-41.png)\n\n![](/article_img/2022-10-12-19-18-35.png)\n\n# 仅考虑直接光照\n\n![](/article_img/2022-10-13-14-37-13.png)\n\n这里的wi是随机在半球上采样\n\n# 引入间接光照\n\n![](/article_img/2022-10-13-14-40-09.png)\n\n直接光照就按照光源来计算，间接光照递归计算\n\n但是还没完：\n\n1. 光线会爆炸\n   ![](/article_img/2022-10-13-14-41-58.png)\n   \n   因此随机选择一条路径进行采样\n\n   ![](/article_img/2022-10-13-14-42-30.png)\n\n   在一个像素中增加采样点，最后平均，来降低噪声\n\n   ![](/article_img/2022-10-13-14-42-38.png)\n\n2. 没有递归出口\n\n   **俄罗斯轮盘赌**\n\n   这里就是利用了**期望**的概念：  \n   事先假定一个概率p，有p的概率发生反射，并且计算的结果除以p，有（1-p）的概率不发生反射，得到0；这种方法得到的结果的期望仍然是Lo，即能量没有损失。\n\n   ![](/article_img/2022-10-13-14-45-56.png)\n\n   ![](/article_img/2022-10-13-14-50-16.png)\n\n# 提高路径追踪效率\n\n![](/article_img/2022-10-13-14-51-20.png)\n\nSPP（samples per pixel）\n\n![](/article_img/2022-10-13-15-58-06.png)\n\n思考为什么low SPP效果不好会出现噪点？\n\n因为我们的采样时在整个半球上随机采样的，而俄罗斯轮盘赌会终结一些光线，导致路径还没有打到光源就被终止，这条路径返回了空值，相当于这次路径追踪白做了（光线被浪费掉了），本质就是采样不足导致的。\n\n因此我们要么加大采样量（增大路径到达光源的概率），要么尽量不要浪费光线，也就是进行重要性采样，对光源采样，就是先计算对该点颜色贡献最大的直接光照。\n\n在对光源采样时，要把光源平面投影到半球面上，也可以理解为求**有效光源**(dA*costheta)的立体角。\n\n![](/article_img/2022-10-14-12-42-03.png)\n\n之后就可以计算Lo\n\n![](/article_img/2022-10-14-12-45-56.png)\n\n现在我们的策略是先计算直接光照（不使用俄罗斯轮盘赌），再计算间接光照（随机在半球中采样，使用俄罗斯轮盘赌）\n\n![](/article_img/2022-10-14-12-49-41.png)\n\n再加上判断直接光照是否被遮挡\n\n伪代码：\n```\nshade(p,wo)\n   # 来自光源的贡献（直接光照）\n   均匀对光源采样 x' (pdf_light = 1/A)\n   Shoot a ray from p to x'\n   if the ray is not blocked in the middle\n      L_dir = L_i * f_r * cos theta' / |x'-p|^2 / pdf_light\n\n   # 来自反射的贡献（间接光照）\n   L_indir = 0.0\n   判断俄罗斯轮盘赌是否终止\n   在半球上均匀采样 wi （pdf_hemi = 1/2pi）\n   Trace a ray r(p, wi)\n   if ray r hit a non-emitting object at q\n      L_indir = shade(q, -wi) * f_r * cos theta / pdf_hemi / P_RR\n   \n   Return L_dir + L_indir\n\n```\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=16&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_15.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf)  \n[GAMES101_Lecture_16.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_16.pdf)  \n","slug":"Games101-8-路径追踪","published":1,"updated":"2022-10-14T05:25:45.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglw000uw0je9f1qbtd1","content":"<p>Games101-8-路径追踪</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/article_img/2022-10-12-19-16-44.png\"></p>\n<h1 id=\"概率论知识\"><a href=\"#概率论知识\" class=\"headerlink\" title=\"概率论知识\"></a>概率论知识</h1><p><img src=\"/article_img/2022-10-12-19-17-41.png\"></p>\n<h1 id=\"Monte-Carlo-Integration\"><a href=\"#Monte-Carlo-Integration\" class=\"headerlink\" title=\"Monte Carlo Integration\"></a>Monte Carlo Integration</h1><p>一种数值方法计算定积分的值，不需要算出原函数。</p>\n<p><img src=\"/article_img/2022-10-12-19-20-11.png\"></p>\n<p><img src=\"/article_img/2022-10-12-19-20-41.png\"></p>\n<p><img src=\"/article_img/2022-10-12-19-18-35.png\"></p>\n<h1 id=\"仅考虑直接光照\"><a href=\"#仅考虑直接光照\" class=\"headerlink\" title=\"仅考虑直接光照\"></a>仅考虑直接光照</h1><p><img src=\"/article_img/2022-10-13-14-37-13.png\"></p>\n<p>这里的wi是随机在半球上采样</p>\n<h1 id=\"引入间接光照\"><a href=\"#引入间接光照\" class=\"headerlink\" title=\"引入间接光照\"></a>引入间接光照</h1><p><img src=\"/article_img/2022-10-13-14-40-09.png\"></p>\n<p>直接光照就按照光源来计算，间接光照递归计算</p>\n<p>但是还没完：</p>\n<ol>\n<li><p>光线会爆炸<br><img src=\"/article_img/2022-10-13-14-41-58.png\"></p>\n<p>因此随机选择一条路径进行采样</p>\n<p><img src=\"/article_img/2022-10-13-14-42-30.png\"></p>\n<p>在一个像素中增加采样点，最后平均，来降低噪声</p>\n<p><img src=\"/article_img/2022-10-13-14-42-38.png\"></p>\n</li>\n<li><p>没有递归出口</p>\n<p><strong>俄罗斯轮盘赌</strong></p>\n<p>这里就是利用了<strong>期望</strong>的概念：<br>事先假定一个概率p，有p的概率发生反射，并且计算的结果除以p，有（1-p）的概率不发生反射，得到0；这种方法得到的结果的期望仍然是Lo，即能量没有损失。</p>\n<p><img src=\"/article_img/2022-10-13-14-45-56.png\"></p>\n<p><img src=\"/article_img/2022-10-13-14-50-16.png\"></p>\n</li>\n</ol>\n<h1 id=\"提高路径追踪效率\"><a href=\"#提高路径追踪效率\" class=\"headerlink\" title=\"提高路径追踪效率\"></a>提高路径追踪效率</h1><p><img src=\"/article_img/2022-10-13-14-51-20.png\"></p>\n<p>SPP（samples per pixel）</p>\n<p><img src=\"/article_img/2022-10-13-15-58-06.png\"></p>\n<p>思考为什么low SPP效果不好会出现噪点？</p>\n<p>因为我们的采样时在整个半球上随机采样的，而俄罗斯轮盘赌会终结一些光线，导致路径还没有打到光源就被终止，这条路径返回了空值，相当于这次路径追踪白做了（光线被浪费掉了），本质就是采样不足导致的。</p>\n<p>因此我们要么加大采样量（增大路径到达光源的概率），要么尽量不要浪费光线，也就是进行重要性采样，对光源采样，就是先计算对该点颜色贡献最大的直接光照。</p>\n<p>在对光源采样时，要把光源平面投影到半球面上，也可以理解为求<strong>有效光源</strong>(dA*costheta)的立体角。</p>\n<p><img src=\"/article_img/2022-10-14-12-42-03.png\"></p>\n<p>之后就可以计算Lo</p>\n<p><img src=\"/article_img/2022-10-14-12-45-56.png\"></p>\n<p>现在我们的策略是先计算直接光照（不使用俄罗斯轮盘赌），再计算间接光照（随机在半球中采样，使用俄罗斯轮盘赌）</p>\n<p><img src=\"/article_img/2022-10-14-12-49-41.png\"></p>\n<p>再加上判断直接光照是否被遮挡</p>\n<p>伪代码：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">shade(p,wo)<br>   <span class=\"hljs-comment\"># 来自光源的贡献（直接光照）</span><br>   均匀对光源采样 x&#x27; (pdf_light = <span class=\"hljs-number\">1</span>/A)<br>   Shoot a ray <span class=\"hljs-keyword\">from</span> p <span class=\"hljs-keyword\">to</span> x&#x27;<br>   <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">the</span> ray <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> blocked <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">middle</span><br>      L_dir = L_i * f_r * cos theta&#x27; / |x&#x27;-p|^<span class=\"hljs-number\">2</span> / pdf_light<br><br>   <span class=\"hljs-comment\"># 来自反射的贡献（间接光照）</span><br>   L_indir = <span class=\"hljs-number\">0.0</span><br>   判断俄罗斯轮盘赌是否终止<br>   在半球上均匀采样 wi （pdf_hemi = <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">2</span><span class=\"hljs-literal\">pi</span>）<br>   Trace a ray r(p, wi)<br>   <span class=\"hljs-keyword\">if</span> ray r hit a non-emitting object <span class=\"hljs-keyword\">at</span> q<br>      L_indir = shade(q, -wi) * f_r * cos theta / pdf_hemi / P_RR<br>   <br>   Return L_dir + L_indir<br><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=16&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf\">GAMES101_Lecture_15.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_16.pdf\">GAMES101_Lecture_16.pdf</a>  </p>\n","site":{"data":{}},"wordcount":1040,"excerpt":"<p>Games101-8-路径追踪</p>","more":"<p><img src=\"/article_img/2022-10-12-19-16-44.png\"></p>\n<h1 id=\"概率论知识\"><a href=\"#概率论知识\" class=\"headerlink\" title=\"概率论知识\"></a>概率论知识</h1><p><img src=\"/article_img/2022-10-12-19-17-41.png\"></p>\n<h1 id=\"Monte-Carlo-Integration\"><a href=\"#Monte-Carlo-Integration\" class=\"headerlink\" title=\"Monte Carlo Integration\"></a>Monte Carlo Integration</h1><p>一种数值方法计算定积分的值，不需要算出原函数。</p>\n<p><img src=\"/article_img/2022-10-12-19-20-11.png\"></p>\n<p><img src=\"/article_img/2022-10-12-19-20-41.png\"></p>\n<p><img src=\"/article_img/2022-10-12-19-18-35.png\"></p>\n<h1 id=\"仅考虑直接光照\"><a href=\"#仅考虑直接光照\" class=\"headerlink\" title=\"仅考虑直接光照\"></a>仅考虑直接光照</h1><p><img src=\"/article_img/2022-10-13-14-37-13.png\"></p>\n<p>这里的wi是随机在半球上采样</p>\n<h1 id=\"引入间接光照\"><a href=\"#引入间接光照\" class=\"headerlink\" title=\"引入间接光照\"></a>引入间接光照</h1><p><img src=\"/article_img/2022-10-13-14-40-09.png\"></p>\n<p>直接光照就按照光源来计算，间接光照递归计算</p>\n<p>但是还没完：</p>\n<ol>\n<li><p>光线会爆炸<br><img src=\"/article_img/2022-10-13-14-41-58.png\"></p>\n<p>因此随机选择一条路径进行采样</p>\n<p><img src=\"/article_img/2022-10-13-14-42-30.png\"></p>\n<p>在一个像素中增加采样点，最后平均，来降低噪声</p>\n<p><img src=\"/article_img/2022-10-13-14-42-38.png\"></p>\n</li>\n<li><p>没有递归出口</p>\n<p><strong>俄罗斯轮盘赌</strong></p>\n<p>这里就是利用了<strong>期望</strong>的概念：<br>事先假定一个概率p，有p的概率发生反射，并且计算的结果除以p，有（1-p）的概率不发生反射，得到0；这种方法得到的结果的期望仍然是Lo，即能量没有损失。</p>\n<p><img src=\"/article_img/2022-10-13-14-45-56.png\"></p>\n<p><img src=\"/article_img/2022-10-13-14-50-16.png\"></p>\n</li>\n</ol>\n<h1 id=\"提高路径追踪效率\"><a href=\"#提高路径追踪效率\" class=\"headerlink\" title=\"提高路径追踪效率\"></a>提高路径追踪效率</h1><p><img src=\"/article_img/2022-10-13-14-51-20.png\"></p>\n<p>SPP（samples per pixel）</p>\n<p><img src=\"/article_img/2022-10-13-15-58-06.png\"></p>\n<p>思考为什么low SPP效果不好会出现噪点？</p>\n<p>因为我们的采样时在整个半球上随机采样的，而俄罗斯轮盘赌会终结一些光线，导致路径还没有打到光源就被终止，这条路径返回了空值，相当于这次路径追踪白做了（光线被浪费掉了），本质就是采样不足导致的。</p>\n<p>因此我们要么加大采样量（增大路径到达光源的概率），要么尽量不要浪费光线，也就是进行重要性采样，对光源采样，就是先计算对该点颜色贡献最大的直接光照。</p>\n<p>在对光源采样时，要把光源平面投影到半球面上，也可以理解为求<strong>有效光源</strong>(dA*costheta)的立体角。</p>\n<p><img src=\"/article_img/2022-10-14-12-42-03.png\"></p>\n<p>之后就可以计算Lo</p>\n<p><img src=\"/article_img/2022-10-14-12-45-56.png\"></p>\n<p>现在我们的策略是先计算直接光照（不使用俄罗斯轮盘赌），再计算间接光照（随机在半球中采样，使用俄罗斯轮盘赌）</p>\n<p><img src=\"/article_img/2022-10-14-12-49-41.png\"></p>\n<p>再加上判断直接光照是否被遮挡</p>\n<p>伪代码：</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">shade(p,wo)<br>   <span class=\"hljs-comment\"># 来自光源的贡献（直接光照）</span><br>   均匀对光源采样 x&#x27; (pdf_light = <span class=\"hljs-number\">1</span>/A)<br>   Shoot a ray <span class=\"hljs-keyword\">from</span> p <span class=\"hljs-keyword\">to</span> x&#x27;<br>   <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">the</span> ray <span class=\"hljs-keyword\">is</span> <span class=\"hljs-keyword\">not</span> blocked <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">the</span> <span class=\"hljs-keyword\">middle</span><br>      L_dir = L_i * f_r * cos theta&#x27; / |x&#x27;-p|^<span class=\"hljs-number\">2</span> / pdf_light<br><br>   <span class=\"hljs-comment\"># 来自反射的贡献（间接光照）</span><br>   L_indir = <span class=\"hljs-number\">0.0</span><br>   判断俄罗斯轮盘赌是否终止<br>   在半球上均匀采样 wi （pdf_hemi = <span class=\"hljs-number\">1</span>/<span class=\"hljs-number\">2</span><span class=\"hljs-literal\">pi</span>）<br>   Trace a ray r(p, wi)<br>   <span class=\"hljs-keyword\">if</span> ray r hit a non-emitting object <span class=\"hljs-keyword\">at</span> q<br>      L_indir = shade(q, -wi) * f_r * cos theta / pdf_hemi / P_RR<br>   <br>   Return L_dir + L_indir<br><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=16&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_15.pdf\">GAMES101_Lecture_15.pdf</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_16.pdf\">GAMES101_Lecture_16.pdf</a>  </p>"},{"title":"Games101-9-外观和材质","date":"2022-10-17T16:00:00.000Z","index_img":"/img/bg/cg_bg.png","_content":"\nGames101-9-外观和材质\n<!-- more -->\n\n![](/article_img/2022-10-19-14-13-14.png)\n\n# 什么是材质\n\n**材质==BRDF**\n\n## 漫反射材质\n\n![](/article_img/2022-10-19-14-26-47.png)\n\n![](/article_img/2022-10-19-14-21-28.png)\n\n漫反射认为是能量均匀的向四面发射，根据能量守恒：**Lo == Li**，因此漫反射的BRDF为 1/pi，考虑到能量吸收，则乘以ρ（albedo颜色衰减率），就会反射出不同的颜色。\n\n## Glossy材质\n\n![](/article_img/2022-10-19-14-27-00.png)\n\n## 理想反射/折射材质\n\n![](/article_img/2022-10-19-14-27-57.png)\n\n**完美镜面反射**\n\n![](/article_img/2022-10-19-14-31-26.png)\n\n# Snell's Law\n\n![](/article_img/2022-10-19-14-33-18.png)\n\n![](/article_img/2022-10-19-14-33-45.png)\n\n# Fresnel Reflection/Term 菲涅尔项\n\n![](/article_img/2022-10-19-14-36-13.png)\n\n绝缘体的菲涅尔项（玻璃）\n\n![](/article_img/2022-10-19-14-36-58.png)\n\n导体的菲涅尔项（金属）\n\n![](/article_img/2022-10-19-14-37-36.png)\n\n由此可以看出金属会大量反射光线，这也就是为什么古代人用铜镜而不用玻璃照镜子。\n\n![](/article_img/2022-10-19-14-38-56.png)\n\n菲涅尔项的计算十分复杂，所以使用Schlick近似。\n\n# 微表面材质\n\n![](/article_img/2022-10-19-14-48-13.png)\n\n![](/article_img/2022-10-19-14-49-56.png)\n\n![](/article_img/2022-10-19-14-50-38.png)\n\n![](/article_img/2022-10-19-14-51-16.png)\n\nD(h)表示法线分布  \nF(i,h)表示菲涅尔项  \nG(i,o,h)表示自遮挡\n\n# 各向同性/各向异性材质\n\n![](/article_img/2022-10-20-11-13-23.png)\n\n区分方法：表面是否有方向性\n\n![](/article_img/2022-10-20-11-13-35.png)\n\n## 各向异性材质\n\n![](/article_img/2022-10-20-11-16-05.png)\n\n反射取决于观测的方位角\n\n# BRDF的性质\n\n1. 非负性  \n   ![](/article_img/2022-10-20-11-18-34.png)\n2. 线性  \n   可以线性相加，结果不变\n   ![](/article_img/2022-10-20-11-18-53.png)\n3. 满足反射定律\n   ![](/article_img/2022-10-20-11-19-22.png)\n4. 能量守恒  \n   该式子表示能量不会增加，只会被反射点吸收或者完全反射\n   ![](/article_img/2022-10-20-11-20-06.png)\n5. 如果是各向同性材质，BRDF参数可以简化为3个  \n   ![](/article_img/2022-10-20-11-23-56.png)\n\n# BRDF的测量\n\n真实材质的BRDF和理论上的有较大差异\n\n![](/article_img/2022-10-20-11-25-41.png)\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=17&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_17.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_17.pdf)  \n  \n\n","source":"_posts/Games101-9-外观和材质.md","raw":"---\ntitle: Games101-9-外观和材质\ndate: 2022-10-18\nindex_img: \"/img/bg/cg_bg.png\"\ntags: [Games101]\ncategories: \n   -[Games101笔记]\n---\n\nGames101-9-外观和材质\n<!-- more -->\n\n![](/article_img/2022-10-19-14-13-14.png)\n\n# 什么是材质\n\n**材质==BRDF**\n\n## 漫反射材质\n\n![](/article_img/2022-10-19-14-26-47.png)\n\n![](/article_img/2022-10-19-14-21-28.png)\n\n漫反射认为是能量均匀的向四面发射，根据能量守恒：**Lo == Li**，因此漫反射的BRDF为 1/pi，考虑到能量吸收，则乘以ρ（albedo颜色衰减率），就会反射出不同的颜色。\n\n## Glossy材质\n\n![](/article_img/2022-10-19-14-27-00.png)\n\n## 理想反射/折射材质\n\n![](/article_img/2022-10-19-14-27-57.png)\n\n**完美镜面反射**\n\n![](/article_img/2022-10-19-14-31-26.png)\n\n# Snell's Law\n\n![](/article_img/2022-10-19-14-33-18.png)\n\n![](/article_img/2022-10-19-14-33-45.png)\n\n# Fresnel Reflection/Term 菲涅尔项\n\n![](/article_img/2022-10-19-14-36-13.png)\n\n绝缘体的菲涅尔项（玻璃）\n\n![](/article_img/2022-10-19-14-36-58.png)\n\n导体的菲涅尔项（金属）\n\n![](/article_img/2022-10-19-14-37-36.png)\n\n由此可以看出金属会大量反射光线，这也就是为什么古代人用铜镜而不用玻璃照镜子。\n\n![](/article_img/2022-10-19-14-38-56.png)\n\n菲涅尔项的计算十分复杂，所以使用Schlick近似。\n\n# 微表面材质\n\n![](/article_img/2022-10-19-14-48-13.png)\n\n![](/article_img/2022-10-19-14-49-56.png)\n\n![](/article_img/2022-10-19-14-50-38.png)\n\n![](/article_img/2022-10-19-14-51-16.png)\n\nD(h)表示法线分布  \nF(i,h)表示菲涅尔项  \nG(i,o,h)表示自遮挡\n\n# 各向同性/各向异性材质\n\n![](/article_img/2022-10-20-11-13-23.png)\n\n区分方法：表面是否有方向性\n\n![](/article_img/2022-10-20-11-13-35.png)\n\n## 各向异性材质\n\n![](/article_img/2022-10-20-11-16-05.png)\n\n反射取决于观测的方位角\n\n# BRDF的性质\n\n1. 非负性  \n   ![](/article_img/2022-10-20-11-18-34.png)\n2. 线性  \n   可以线性相加，结果不变\n   ![](/article_img/2022-10-20-11-18-53.png)\n3. 满足反射定律\n   ![](/article_img/2022-10-20-11-19-22.png)\n4. 能量守恒  \n   该式子表示能量不会增加，只会被反射点吸收或者完全反射\n   ![](/article_img/2022-10-20-11-20-06.png)\n5. 如果是各向同性材质，BRDF参数可以简化为3个  \n   ![](/article_img/2022-10-20-11-23-56.png)\n\n# BRDF的测量\n\n真实材质的BRDF和理论上的有较大差异\n\n![](/article_img/2022-10-20-11-25-41.png)\n\n# 参考\n\n[课程视频](https://www.bilibili.com/video/BV1X7411F744?p=17&vd_source=93b215eab72b2548f75d0772e28f8b20)  \n[GAMES101: 现代计算机图形学入门](https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html)  \n[GAMES101_Lecture_17.pdf](https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_17.pdf)  \n  \n\n","slug":"Games101-9-外观和材质","published":1,"updated":"2022-10-22T07:36:17.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglx000zw0jegf9xgauy","content":"<p>Games101-9-外观和材质</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/article_img/2022-10-19-14-13-14.png\"></p>\n<h1 id=\"什么是材质\"><a href=\"#什么是材质\" class=\"headerlink\" title=\"什么是材质\"></a>什么是材质</h1><p><strong>材质&#x3D;&#x3D;BRDF</strong></p>\n<h2 id=\"漫反射材质\"><a href=\"#漫反射材质\" class=\"headerlink\" title=\"漫反射材质\"></a>漫反射材质</h2><p><img src=\"/article_img/2022-10-19-14-26-47.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-21-28.png\"></p>\n<p>漫反射认为是能量均匀的向四面发射，根据能量守恒：<strong>Lo &#x3D;&#x3D; Li</strong>，因此漫反射的BRDF为 1&#x2F;pi，考虑到能量吸收，则乘以ρ（albedo颜色衰减率），就会反射出不同的颜色。</p>\n<h2 id=\"Glossy材质\"><a href=\"#Glossy材质\" class=\"headerlink\" title=\"Glossy材质\"></a>Glossy材质</h2><p><img src=\"/article_img/2022-10-19-14-27-00.png\"></p>\n<h2 id=\"理想反射-x2F-折射材质\"><a href=\"#理想反射-x2F-折射材质\" class=\"headerlink\" title=\"理想反射&#x2F;折射材质\"></a>理想反射&#x2F;折射材质</h2><p><img src=\"/article_img/2022-10-19-14-27-57.png\"></p>\n<p><strong>完美镜面反射</strong></p>\n<p><img src=\"/article_img/2022-10-19-14-31-26.png\"></p>\n<h1 id=\"Snell’s-Law\"><a href=\"#Snell’s-Law\" class=\"headerlink\" title=\"Snell’s Law\"></a>Snell’s Law</h1><p><img src=\"/article_img/2022-10-19-14-33-18.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-33-45.png\"></p>\n<h1 id=\"Fresnel-Reflection-x2F-Term-菲涅尔项\"><a href=\"#Fresnel-Reflection-x2F-Term-菲涅尔项\" class=\"headerlink\" title=\"Fresnel Reflection&#x2F;Term 菲涅尔项\"></a>Fresnel Reflection&#x2F;Term 菲涅尔项</h1><p><img src=\"/article_img/2022-10-19-14-36-13.png\"></p>\n<p>绝缘体的菲涅尔项（玻璃）</p>\n<p><img src=\"/article_img/2022-10-19-14-36-58.png\"></p>\n<p>导体的菲涅尔项（金属）</p>\n<p><img src=\"/article_img/2022-10-19-14-37-36.png\"></p>\n<p>由此可以看出金属会大量反射光线，这也就是为什么古代人用铜镜而不用玻璃照镜子。</p>\n<p><img src=\"/article_img/2022-10-19-14-38-56.png\"></p>\n<p>菲涅尔项的计算十分复杂，所以使用Schlick近似。</p>\n<h1 id=\"微表面材质\"><a href=\"#微表面材质\" class=\"headerlink\" title=\"微表面材质\"></a>微表面材质</h1><p><img src=\"/article_img/2022-10-19-14-48-13.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-49-56.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-50-38.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-51-16.png\"></p>\n<p>D(h)表示法线分布<br>F(i,h)表示菲涅尔项<br>G(i,o,h)表示自遮挡</p>\n<h1 id=\"各向同性-x2F-各向异性材质\"><a href=\"#各向同性-x2F-各向异性材质\" class=\"headerlink\" title=\"各向同性&#x2F;各向异性材质\"></a>各向同性&#x2F;各向异性材质</h1><p><img src=\"/article_img/2022-10-20-11-13-23.png\"></p>\n<p>区分方法：表面是否有方向性</p>\n<p><img src=\"/article_img/2022-10-20-11-13-35.png\"></p>\n<h2 id=\"各向异性材质\"><a href=\"#各向异性材质\" class=\"headerlink\" title=\"各向异性材质\"></a>各向异性材质</h2><p><img src=\"/article_img/2022-10-20-11-16-05.png\"></p>\n<p>反射取决于观测的方位角</p>\n<h1 id=\"BRDF的性质\"><a href=\"#BRDF的性质\" class=\"headerlink\" title=\"BRDF的性质\"></a>BRDF的性质</h1><ol>\n<li>非负性<br><img src=\"/article_img/2022-10-20-11-18-34.png\"></li>\n<li>线性<br>可以线性相加，结果不变<br><img src=\"/article_img/2022-10-20-11-18-53.png\"></li>\n<li>满足反射定律<br><img src=\"/article_img/2022-10-20-11-19-22.png\"></li>\n<li>能量守恒<br>该式子表示能量不会增加，只会被反射点吸收或者完全反射<br><img src=\"/article_img/2022-10-20-11-20-06.png\"></li>\n<li>如果是各向同性材质，BRDF参数可以简化为3个<br><img src=\"/article_img/2022-10-20-11-23-56.png\"></li>\n</ol>\n<h1 id=\"BRDF的测量\"><a href=\"#BRDF的测量\" class=\"headerlink\" title=\"BRDF的测量\"></a>BRDF的测量</h1><p>真实材质的BRDF和理论上的有较大差异</p>\n<p><img src=\"/article_img/2022-10-20-11-25-41.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=17&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_17.pdf\">GAMES101_Lecture_17.pdf</a>  </p>\n","site":{"data":{}},"wordcount":541,"excerpt":"<p>Games101-9-外观和材质</p>","more":"<p><img src=\"/article_img/2022-10-19-14-13-14.png\"></p>\n<h1 id=\"什么是材质\"><a href=\"#什么是材质\" class=\"headerlink\" title=\"什么是材质\"></a>什么是材质</h1><p><strong>材质&#x3D;&#x3D;BRDF</strong></p>\n<h2 id=\"漫反射材质\"><a href=\"#漫反射材质\" class=\"headerlink\" title=\"漫反射材质\"></a>漫反射材质</h2><p><img src=\"/article_img/2022-10-19-14-26-47.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-21-28.png\"></p>\n<p>漫反射认为是能量均匀的向四面发射，根据能量守恒：<strong>Lo &#x3D;&#x3D; Li</strong>，因此漫反射的BRDF为 1&#x2F;pi，考虑到能量吸收，则乘以ρ（albedo颜色衰减率），就会反射出不同的颜色。</p>\n<h2 id=\"Glossy材质\"><a href=\"#Glossy材质\" class=\"headerlink\" title=\"Glossy材质\"></a>Glossy材质</h2><p><img src=\"/article_img/2022-10-19-14-27-00.png\"></p>\n<h2 id=\"理想反射-x2F-折射材质\"><a href=\"#理想反射-x2F-折射材质\" class=\"headerlink\" title=\"理想反射&#x2F;折射材质\"></a>理想反射&#x2F;折射材质</h2><p><img src=\"/article_img/2022-10-19-14-27-57.png\"></p>\n<p><strong>完美镜面反射</strong></p>\n<p><img src=\"/article_img/2022-10-19-14-31-26.png\"></p>\n<h1 id=\"Snell’s-Law\"><a href=\"#Snell’s-Law\" class=\"headerlink\" title=\"Snell’s Law\"></a>Snell’s Law</h1><p><img src=\"/article_img/2022-10-19-14-33-18.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-33-45.png\"></p>\n<h1 id=\"Fresnel-Reflection-x2F-Term-菲涅尔项\"><a href=\"#Fresnel-Reflection-x2F-Term-菲涅尔项\" class=\"headerlink\" title=\"Fresnel Reflection&#x2F;Term 菲涅尔项\"></a>Fresnel Reflection&#x2F;Term 菲涅尔项</h1><p><img src=\"/article_img/2022-10-19-14-36-13.png\"></p>\n<p>绝缘体的菲涅尔项（玻璃）</p>\n<p><img src=\"/article_img/2022-10-19-14-36-58.png\"></p>\n<p>导体的菲涅尔项（金属）</p>\n<p><img src=\"/article_img/2022-10-19-14-37-36.png\"></p>\n<p>由此可以看出金属会大量反射光线，这也就是为什么古代人用铜镜而不用玻璃照镜子。</p>\n<p><img src=\"/article_img/2022-10-19-14-38-56.png\"></p>\n<p>菲涅尔项的计算十分复杂，所以使用Schlick近似。</p>\n<h1 id=\"微表面材质\"><a href=\"#微表面材质\" class=\"headerlink\" title=\"微表面材质\"></a>微表面材质</h1><p><img src=\"/article_img/2022-10-19-14-48-13.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-49-56.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-50-38.png\"></p>\n<p><img src=\"/article_img/2022-10-19-14-51-16.png\"></p>\n<p>D(h)表示法线分布<br>F(i,h)表示菲涅尔项<br>G(i,o,h)表示自遮挡</p>\n<h1 id=\"各向同性-x2F-各向异性材质\"><a href=\"#各向同性-x2F-各向异性材质\" class=\"headerlink\" title=\"各向同性&#x2F;各向异性材质\"></a>各向同性&#x2F;各向异性材质</h1><p><img src=\"/article_img/2022-10-20-11-13-23.png\"></p>\n<p>区分方法：表面是否有方向性</p>\n<p><img src=\"/article_img/2022-10-20-11-13-35.png\"></p>\n<h2 id=\"各向异性材质\"><a href=\"#各向异性材质\" class=\"headerlink\" title=\"各向异性材质\"></a>各向异性材质</h2><p><img src=\"/article_img/2022-10-20-11-16-05.png\"></p>\n<p>反射取决于观测的方位角</p>\n<h1 id=\"BRDF的性质\"><a href=\"#BRDF的性质\" class=\"headerlink\" title=\"BRDF的性质\"></a>BRDF的性质</h1><ol>\n<li>非负性<br><img src=\"/article_img/2022-10-20-11-18-34.png\"></li>\n<li>线性<br>可以线性相加，结果不变<br><img src=\"/article_img/2022-10-20-11-18-53.png\"></li>\n<li>满足反射定律<br><img src=\"/article_img/2022-10-20-11-19-22.png\"></li>\n<li>能量守恒<br>该式子表示能量不会增加，只会被反射点吸收或者完全反射<br><img src=\"/article_img/2022-10-20-11-20-06.png\"></li>\n<li>如果是各向同性材质，BRDF参数可以简化为3个<br><img src=\"/article_img/2022-10-20-11-23-56.png\"></li>\n</ol>\n<h1 id=\"BRDF的测量\"><a href=\"#BRDF的测量\" class=\"headerlink\" title=\"BRDF的测量\"></a>BRDF的测量</h1><p>真实材质的BRDF和理论上的有较大差异</p>\n<p><img src=\"/article_img/2022-10-20-11-25-41.png\"></p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.bilibili.com/video/BV1X7411F744?p=17&vd_source=93b215eab72b2548f75d0772e28f8b20\">课程视频</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html\">GAMES101: 现代计算机图形学入门</a><br><a href=\"https://sites.cs.ucsb.edu/~lingqi/teaching/resources/GAMES101_Lecture_17.pdf\">GAMES101_Lecture_17.pdf</a>  </p>"},{"title":"Games105-1-数学基础","date":"2023-03-17T16:00:00.000Z","index_img":"/img/bg/games105.jpg","_content":"\nGames105-1-数学基础\n<!-- more -->\n\n# 线代基础\n\n## 点乘\n\n点乘（Dot Product）的结果是点积，又称数量积或标量积（Scalar Product）\n\n![](/article_img/2023-03-18-18-56-04.png)\n\n### 点乘的几何意义\n点乘表示了a向量在b向量方向上的投影与b向量模的乘积，**反映了两个向量在方向上的相似度**。\n\n![](/article_img/2022-07-21-14-00-29.png)\n\n### 用来求向量夹角\n\n![](/article_img/2023-03-18-19-00-23.png)\n\n## 叉乘\n\n叉乘（Cross Product）又称向量积（Vector Product）\n\n![](/article_img/2023-03-18-18-56-36.png)\n\n### 叉乘的几何意义\n\n![](/article_img/2023-03-18-19-01-01.png)\n\n叉乘的结果是一个垂直于a向量和b向量的向量，叉乘结果的模等于a向量和b向量围成的平行四边形的面积。\n\n### 叉乘的应用\n\n1. 得到最小旋转，通过叉乘得到旋转轴，通过点乘得到旋转角度\n    ![](/article_img/2023-03-18-19-05-21.png)\n2. 罗德里格斯旋转公式\n    **将a向量绕着某个轴u旋转θ得到b向量，求b向量**\n    ![](/article_img/2023-03-18-19-08-12.png)\n\n    公式推导：\n    ![](/article_img/2023-03-18-19-24-34.png)\n    ![](/article_img/2023-03-29-13-26-38.png)\n    \n\n\n","source":"_posts/Games105-1-数学基础.md","raw":"---\ntitle: Games105-1-数学基础\ndate: 2023-03-18\nindex_img: \"/img/bg/games105.jpg\"\ntags: [Games105]\ncategories: \n   -[Games105笔记]\n---\n\nGames105-1-数学基础\n<!-- more -->\n\n# 线代基础\n\n## 点乘\n\n点乘（Dot Product）的结果是点积，又称数量积或标量积（Scalar Product）\n\n![](/article_img/2023-03-18-18-56-04.png)\n\n### 点乘的几何意义\n点乘表示了a向量在b向量方向上的投影与b向量模的乘积，**反映了两个向量在方向上的相似度**。\n\n![](/article_img/2022-07-21-14-00-29.png)\n\n### 用来求向量夹角\n\n![](/article_img/2023-03-18-19-00-23.png)\n\n## 叉乘\n\n叉乘（Cross Product）又称向量积（Vector Product）\n\n![](/article_img/2023-03-18-18-56-36.png)\n\n### 叉乘的几何意义\n\n![](/article_img/2023-03-18-19-01-01.png)\n\n叉乘的结果是一个垂直于a向量和b向量的向量，叉乘结果的模等于a向量和b向量围成的平行四边形的面积。\n\n### 叉乘的应用\n\n1. 得到最小旋转，通过叉乘得到旋转轴，通过点乘得到旋转角度\n    ![](/article_img/2023-03-18-19-05-21.png)\n2. 罗德里格斯旋转公式\n    **将a向量绕着某个轴u旋转θ得到b向量，求b向量**\n    ![](/article_img/2023-03-18-19-08-12.png)\n\n    公式推导：\n    ![](/article_img/2023-03-18-19-24-34.png)\n    ![](/article_img/2023-03-29-13-26-38.png)\n    \n\n\n","slug":"Games105-1-数学基础","published":1,"updated":"2023-03-29T05:27:12.125Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglx0011w0jeahvt9q2c","content":"<p>Games105-1-数学基础</p>\n<span id=\"more\"></span>\n\n<h1 id=\"线代基础\"><a href=\"#线代基础\" class=\"headerlink\" title=\"线代基础\"></a>线代基础</h1><h2 id=\"点乘\"><a href=\"#点乘\" class=\"headerlink\" title=\"点乘\"></a>点乘</h2><p>点乘（Dot Product）的结果是点积，又称数量积或标量积（Scalar Product）</p>\n<p><img src=\"/article_img/2023-03-18-18-56-04.png\"></p>\n<h3 id=\"点乘的几何意义\"><a href=\"#点乘的几何意义\" class=\"headerlink\" title=\"点乘的几何意义\"></a>点乘的几何意义</h3><p>点乘表示了a向量在b向量方向上的投影与b向量模的乘积，<strong>反映了两个向量在方向上的相似度</strong>。</p>\n<p><img src=\"/article_img/2022-07-21-14-00-29.png\"></p>\n<h3 id=\"用来求向量夹角\"><a href=\"#用来求向量夹角\" class=\"headerlink\" title=\"用来求向量夹角\"></a>用来求向量夹角</h3><p><img src=\"/article_img/2023-03-18-19-00-23.png\"></p>\n<h2 id=\"叉乘\"><a href=\"#叉乘\" class=\"headerlink\" title=\"叉乘\"></a>叉乘</h2><p>叉乘（Cross Product）又称向量积（Vector Product）</p>\n<p><img src=\"/article_img/2023-03-18-18-56-36.png\"></p>\n<h3 id=\"叉乘的几何意义\"><a href=\"#叉乘的几何意义\" class=\"headerlink\" title=\"叉乘的几何意义\"></a>叉乘的几何意义</h3><p><img src=\"/article_img/2023-03-18-19-01-01.png\"></p>\n<p>叉乘的结果是一个垂直于a向量和b向量的向量，叉乘结果的模等于a向量和b向量围成的平行四边形的面积。</p>\n<h3 id=\"叉乘的应用\"><a href=\"#叉乘的应用\" class=\"headerlink\" title=\"叉乘的应用\"></a>叉乘的应用</h3><ol>\n<li><p>得到最小旋转，通过叉乘得到旋转轴，通过点乘得到旋转角度<br> <img src=\"/article_img/2023-03-18-19-05-21.png\"></p>\n</li>\n<li><p>罗德里格斯旋转公式<br> <strong>将a向量绕着某个轴u旋转θ得到b向量，求b向量</strong><br> <img src=\"/article_img/2023-03-18-19-08-12.png\"></p>\n<p> 公式推导：<br> <img src=\"/article_img/2023-03-18-19-24-34.png\"><br> <img src=\"/article_img/2023-03-29-13-26-38.png\"></p>\n</li>\n</ol>\n","site":{"data":{}},"wordcount":286,"excerpt":"<p>Games105-1-数学基础</p>","more":"<h1 id=\"线代基础\"><a href=\"#线代基础\" class=\"headerlink\" title=\"线代基础\"></a>线代基础</h1><h2 id=\"点乘\"><a href=\"#点乘\" class=\"headerlink\" title=\"点乘\"></a>点乘</h2><p>点乘（Dot Product）的结果是点积，又称数量积或标量积（Scalar Product）</p>\n<p><img src=\"/article_img/2023-03-18-18-56-04.png\"></p>\n<h3 id=\"点乘的几何意义\"><a href=\"#点乘的几何意义\" class=\"headerlink\" title=\"点乘的几何意义\"></a>点乘的几何意义</h3><p>点乘表示了a向量在b向量方向上的投影与b向量模的乘积，<strong>反映了两个向量在方向上的相似度</strong>。</p>\n<p><img src=\"/article_img/2022-07-21-14-00-29.png\"></p>\n<h3 id=\"用来求向量夹角\"><a href=\"#用来求向量夹角\" class=\"headerlink\" title=\"用来求向量夹角\"></a>用来求向量夹角</h3><p><img src=\"/article_img/2023-03-18-19-00-23.png\"></p>\n<h2 id=\"叉乘\"><a href=\"#叉乘\" class=\"headerlink\" title=\"叉乘\"></a>叉乘</h2><p>叉乘（Cross Product）又称向量积（Vector Product）</p>\n<p><img src=\"/article_img/2023-03-18-18-56-36.png\"></p>\n<h3 id=\"叉乘的几何意义\"><a href=\"#叉乘的几何意义\" class=\"headerlink\" title=\"叉乘的几何意义\"></a>叉乘的几何意义</h3><p><img src=\"/article_img/2023-03-18-19-01-01.png\"></p>\n<p>叉乘的结果是一个垂直于a向量和b向量的向量，叉乘结果的模等于a向量和b向量围成的平行四边形的面积。</p>\n<h3 id=\"叉乘的应用\"><a href=\"#叉乘的应用\" class=\"headerlink\" title=\"叉乘的应用\"></a>叉乘的应用</h3><ol>\n<li><p>得到最小旋转，通过叉乘得到旋转轴，通过点乘得到旋转角度<br> <img src=\"/article_img/2023-03-18-19-05-21.png\"></p>\n</li>\n<li><p>罗德里格斯旋转公式<br> <strong>将a向量绕着某个轴u旋转θ得到b向量，求b向量</strong><br> <img src=\"/article_img/2023-03-18-19-08-12.png\"></p>\n<p> 公式推导：<br> <img src=\"/article_img/2023-03-18-19-24-34.png\"><br> <img src=\"/article_img/2023-03-29-13-26-38.png\"></p>\n</li>\n</ol>"},{"title":"LearnedMotionMactching复现","date":"2023-03-24T16:00:00.000Z","index_img":"/img/bg/LearnedMM.png","_content":"\nLearnedMotionMactching复现\n<!-- more -->\n\n在尝试跑LearnedMotionMatching代码的时候出现了很多问题，也是自己平时对编译源码不熟悉导致的，折腾了几天终于把代码跑起来了，记录一下遇到的问题和解决方法。\n![](/article_img/2023-03-25-14-47-55.png)\n\n# 相关链接\n\n[github: Learned Motion-Matching](https://github.com/orangeduck/Motion-Matching)\n[article: Code vs Data Driven Displacement](https://theorangeduck.com/page/code-vs-data-driven-displacement)\n[paper(siggraph2020): Learned Motion Matching](https://theorangeduck.com/page/learned-motion-matching)\n\n\n# 前置依赖\n\n这个演示Demo是基于raylib和raygui的（在国内很小众，是两个C++库用来开发一些小游戏），需要提前安装这两个库，建议都用github最新源码自行编译，否则会出现一些版本问题。\n\n[raylib](https://github.com/raysan5/raylib)\n[raygui](https://github.com/raysan5/raygui)\n\n## raylib安装\n\n下载好源码之后，创建一个raylib_build文件夹存放用CMake构建出的结果，之后在raylib_build中找到raylib.sln（vs项目文件），点击打开，生成解决方案，生成完毕之后会在/raylib_build/raylib/路径下生成一个Debug文件夹，其中存放raylib.lib文件。这时raylib就已经安装完成了，但是我们还需要在vs2022中配置raylib库。\n\n![](/article_img/2023-03-25-15-11-00.png)\n\n可以新建两个文件夹用来管理第三方库，Include文件夹存放.h文件，Libs文件夹存放.lib文件，这样之后就不需要去费力的寻找这些库文件了。\n\n## raygui安装\n\nraygui就简单多了，只需要从github下载源码即可，不需要自己编译，可以在src文件夹中找到raygui.h文件，将其放入上面我们建好的Include文件夹中即可。\n\n## vs2022配置第三方库\n\n![](/article_img/2023-03-25-15-16-38.png)\n\n这里的包含目录直接填我们新建的Include文件夹，库目录填Libs文件夹即可。\n\n感谢ChatGPT！\n\n# 编译源码\n\n\n## 作者提供的方式\n\n按照github上的[Issue](https://github.com/orangeduck/Motion-Matching/issues/2)，其实这种方法理论上不需要编译raylib源码，直接去raylib官网下载Installer即可一键安装：\n\n![](/article_img/2023-03-25-15-20-53.png)\n\n但是我在实际运行时出现了下图这样的错误，提示说UpdateCamera()缺少一个参数。\n\n![](/article_img/2023-03-25-15-24-46.png)\n\n![](/article_img/2023-03-25-15-26-06.png)\n\n按照ChatGPT的回答，可以确定应该还是依赖库的版本问题，我这里就直接改了源码，将第二个参数设置为了CAMERA_CUSTOM，即可正常编译，生成controller.exe文件。\n\n## VS2022编译方式\n\n考虑到之后可能会对源码进行修改，就尝试在VS里编译源码，我首先在VS中配置好了raylib和raygui，之后将源码中的文件全部添加到VS项目中，这是发现我的编译器似乎并不能识别部分源码的写法，如下：\n\n![](/article_img/2023-03-25-15-32-24.png)\n\n这里将括号去掉就正常了。\n\n![](/article_img/2023-03-25-15-33-19.png)\n\n这里写成下面的__restrict就可以识别了。\n\n![](/article_img/2023-03-25-15-36-39.png)\n\n这里和上述一样随便加了一个参数。\n\n这些写法问题解决之后，还不要忘了把源码中的resouce文件夹放到VS项目文件夹里，这样才能加载模型和数据库等等资源。\n","source":"_posts/LearnedMotionMatching复现.md","raw":"---\ntitle: LearnedMotionMactching复现\ndate: 2023-03-25\nindex_img: \"/img/bg/LearnedMM.png\"\ntags: [计算机角色动画]\ncategories: \n   -[笔记]\n---\n\nLearnedMotionMactching复现\n<!-- more -->\n\n在尝试跑LearnedMotionMatching代码的时候出现了很多问题，也是自己平时对编译源码不熟悉导致的，折腾了几天终于把代码跑起来了，记录一下遇到的问题和解决方法。\n![](/article_img/2023-03-25-14-47-55.png)\n\n# 相关链接\n\n[github: Learned Motion-Matching](https://github.com/orangeduck/Motion-Matching)\n[article: Code vs Data Driven Displacement](https://theorangeduck.com/page/code-vs-data-driven-displacement)\n[paper(siggraph2020): Learned Motion Matching](https://theorangeduck.com/page/learned-motion-matching)\n\n\n# 前置依赖\n\n这个演示Demo是基于raylib和raygui的（在国内很小众，是两个C++库用来开发一些小游戏），需要提前安装这两个库，建议都用github最新源码自行编译，否则会出现一些版本问题。\n\n[raylib](https://github.com/raysan5/raylib)\n[raygui](https://github.com/raysan5/raygui)\n\n## raylib安装\n\n下载好源码之后，创建一个raylib_build文件夹存放用CMake构建出的结果，之后在raylib_build中找到raylib.sln（vs项目文件），点击打开，生成解决方案，生成完毕之后会在/raylib_build/raylib/路径下生成一个Debug文件夹，其中存放raylib.lib文件。这时raylib就已经安装完成了，但是我们还需要在vs2022中配置raylib库。\n\n![](/article_img/2023-03-25-15-11-00.png)\n\n可以新建两个文件夹用来管理第三方库，Include文件夹存放.h文件，Libs文件夹存放.lib文件，这样之后就不需要去费力的寻找这些库文件了。\n\n## raygui安装\n\nraygui就简单多了，只需要从github下载源码即可，不需要自己编译，可以在src文件夹中找到raygui.h文件，将其放入上面我们建好的Include文件夹中即可。\n\n## vs2022配置第三方库\n\n![](/article_img/2023-03-25-15-16-38.png)\n\n这里的包含目录直接填我们新建的Include文件夹，库目录填Libs文件夹即可。\n\n感谢ChatGPT！\n\n# 编译源码\n\n\n## 作者提供的方式\n\n按照github上的[Issue](https://github.com/orangeduck/Motion-Matching/issues/2)，其实这种方法理论上不需要编译raylib源码，直接去raylib官网下载Installer即可一键安装：\n\n![](/article_img/2023-03-25-15-20-53.png)\n\n但是我在实际运行时出现了下图这样的错误，提示说UpdateCamera()缺少一个参数。\n\n![](/article_img/2023-03-25-15-24-46.png)\n\n![](/article_img/2023-03-25-15-26-06.png)\n\n按照ChatGPT的回答，可以确定应该还是依赖库的版本问题，我这里就直接改了源码，将第二个参数设置为了CAMERA_CUSTOM，即可正常编译，生成controller.exe文件。\n\n## VS2022编译方式\n\n考虑到之后可能会对源码进行修改，就尝试在VS里编译源码，我首先在VS中配置好了raylib和raygui，之后将源码中的文件全部添加到VS项目中，这是发现我的编译器似乎并不能识别部分源码的写法，如下：\n\n![](/article_img/2023-03-25-15-32-24.png)\n\n这里将括号去掉就正常了。\n\n![](/article_img/2023-03-25-15-33-19.png)\n\n这里写成下面的__restrict就可以识别了。\n\n![](/article_img/2023-03-25-15-36-39.png)\n\n这里和上述一样随便加了一个参数。\n\n这些写法问题解决之后，还不要忘了把源码中的resouce文件夹放到VS项目文件夹里，这样才能加载模型和数据库等等资源。\n","slug":"LearnedMotionMatching复现","published":1,"updated":"2023-03-25T07:40:37.552Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigly0016w0je9upeflia","content":"<p>LearnedMotionMactching复现</p>\n<span id=\"more\"></span>\n\n<p>在尝试跑LearnedMotionMatching代码的时候出现了很多问题，也是自己平时对编译源码不熟悉导致的，折腾了几天终于把代码跑起来了，记录一下遇到的问题和解决方法。<br><img src=\"/article_img/2023-03-25-14-47-55.png\"></p>\n<h1 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h1><p><a href=\"https://github.com/orangeduck/Motion-Matching\">github: Learned Motion-Matching</a><br><a href=\"https://theorangeduck.com/page/code-vs-data-driven-displacement\">article: Code vs Data Driven Displacement</a><br><a href=\"https://theorangeduck.com/page/learned-motion-matching\">paper(siggraph2020): Learned Motion Matching</a></p>\n<h1 id=\"前置依赖\"><a href=\"#前置依赖\" class=\"headerlink\" title=\"前置依赖\"></a>前置依赖</h1><p>这个演示Demo是基于raylib和raygui的（在国内很小众，是两个C++库用来开发一些小游戏），需要提前安装这两个库，建议都用github最新源码自行编译，否则会出现一些版本问题。</p>\n<p><a href=\"https://github.com/raysan5/raylib\">raylib</a><br><a href=\"https://github.com/raysan5/raygui\">raygui</a></p>\n<h2 id=\"raylib安装\"><a href=\"#raylib安装\" class=\"headerlink\" title=\"raylib安装\"></a>raylib安装</h2><p>下载好源码之后，创建一个raylib_build文件夹存放用CMake构建出的结果，之后在raylib_build中找到raylib.sln（vs项目文件），点击打开，生成解决方案，生成完毕之后会在&#x2F;raylib_build&#x2F;raylib&#x2F;路径下生成一个Debug文件夹，其中存放raylib.lib文件。这时raylib就已经安装完成了，但是我们还需要在vs2022中配置raylib库。</p>\n<p><img src=\"/article_img/2023-03-25-15-11-00.png\"></p>\n<p>可以新建两个文件夹用来管理第三方库，Include文件夹存放.h文件，Libs文件夹存放.lib文件，这样之后就不需要去费力的寻找这些库文件了。</p>\n<h2 id=\"raygui安装\"><a href=\"#raygui安装\" class=\"headerlink\" title=\"raygui安装\"></a>raygui安装</h2><p>raygui就简单多了，只需要从github下载源码即可，不需要自己编译，可以在src文件夹中找到raygui.h文件，将其放入上面我们建好的Include文件夹中即可。</p>\n<h2 id=\"vs2022配置第三方库\"><a href=\"#vs2022配置第三方库\" class=\"headerlink\" title=\"vs2022配置第三方库\"></a>vs2022配置第三方库</h2><p><img src=\"/article_img/2023-03-25-15-16-38.png\"></p>\n<p>这里的包含目录直接填我们新建的Include文件夹，库目录填Libs文件夹即可。</p>\n<p>感谢ChatGPT！</p>\n<h1 id=\"编译源码\"><a href=\"#编译源码\" class=\"headerlink\" title=\"编译源码\"></a>编译源码</h1><h2 id=\"作者提供的方式\"><a href=\"#作者提供的方式\" class=\"headerlink\" title=\"作者提供的方式\"></a>作者提供的方式</h2><p>按照github上的<a href=\"https://github.com/orangeduck/Motion-Matching/issues/2\">Issue</a>，其实这种方法理论上不需要编译raylib源码，直接去raylib官网下载Installer即可一键安装：</p>\n<p><img src=\"/article_img/2023-03-25-15-20-53.png\"></p>\n<p>但是我在实际运行时出现了下图这样的错误，提示说UpdateCamera()缺少一个参数。</p>\n<p><img src=\"/article_img/2023-03-25-15-24-46.png\"></p>\n<p><img src=\"/article_img/2023-03-25-15-26-06.png\"></p>\n<p>按照ChatGPT的回答，可以确定应该还是依赖库的版本问题，我这里就直接改了源码，将第二个参数设置为了CAMERA_CUSTOM，即可正常编译，生成controller.exe文件。</p>\n<h2 id=\"VS2022编译方式\"><a href=\"#VS2022编译方式\" class=\"headerlink\" title=\"VS2022编译方式\"></a>VS2022编译方式</h2><p>考虑到之后可能会对源码进行修改，就尝试在VS里编译源码，我首先在VS中配置好了raylib和raygui，之后将源码中的文件全部添加到VS项目中，这是发现我的编译器似乎并不能识别部分源码的写法，如下：</p>\n<p><img src=\"/article_img/2023-03-25-15-32-24.png\"></p>\n<p>这里将括号去掉就正常了。</p>\n<p><img src=\"/article_img/2023-03-25-15-33-19.png\"></p>\n<p>这里写成下面的__restrict就可以识别了。</p>\n<p><img src=\"/article_img/2023-03-25-15-36-39.png\"></p>\n<p>这里和上述一样随便加了一个参数。</p>\n<p>这些写法问题解决之后，还不要忘了把源码中的resouce文件夹放到VS项目文件夹里，这样才能加载模型和数据库等等资源。</p>\n","site":{"data":{}},"wordcount":1209,"excerpt":"<p>LearnedMotionMactching复现</p>","more":"<p>在尝试跑LearnedMotionMatching代码的时候出现了很多问题，也是自己平时对编译源码不熟悉导致的，折腾了几天终于把代码跑起来了，记录一下遇到的问题和解决方法。<br><img src=\"/article_img/2023-03-25-14-47-55.png\"></p>\n<h1 id=\"相关链接\"><a href=\"#相关链接\" class=\"headerlink\" title=\"相关链接\"></a>相关链接</h1><p><a href=\"https://github.com/orangeduck/Motion-Matching\">github: Learned Motion-Matching</a><br><a href=\"https://theorangeduck.com/page/code-vs-data-driven-displacement\">article: Code vs Data Driven Displacement</a><br><a href=\"https://theorangeduck.com/page/learned-motion-matching\">paper(siggraph2020): Learned Motion Matching</a></p>\n<h1 id=\"前置依赖\"><a href=\"#前置依赖\" class=\"headerlink\" title=\"前置依赖\"></a>前置依赖</h1><p>这个演示Demo是基于raylib和raygui的（在国内很小众，是两个C++库用来开发一些小游戏），需要提前安装这两个库，建议都用github最新源码自行编译，否则会出现一些版本问题。</p>\n<p><a href=\"https://github.com/raysan5/raylib\">raylib</a><br><a href=\"https://github.com/raysan5/raygui\">raygui</a></p>\n<h2 id=\"raylib安装\"><a href=\"#raylib安装\" class=\"headerlink\" title=\"raylib安装\"></a>raylib安装</h2><p>下载好源码之后，创建一个raylib_build文件夹存放用CMake构建出的结果，之后在raylib_build中找到raylib.sln（vs项目文件），点击打开，生成解决方案，生成完毕之后会在&#x2F;raylib_build&#x2F;raylib&#x2F;路径下生成一个Debug文件夹，其中存放raylib.lib文件。这时raylib就已经安装完成了，但是我们还需要在vs2022中配置raylib库。</p>\n<p><img src=\"/article_img/2023-03-25-15-11-00.png\"></p>\n<p>可以新建两个文件夹用来管理第三方库，Include文件夹存放.h文件，Libs文件夹存放.lib文件，这样之后就不需要去费力的寻找这些库文件了。</p>\n<h2 id=\"raygui安装\"><a href=\"#raygui安装\" class=\"headerlink\" title=\"raygui安装\"></a>raygui安装</h2><p>raygui就简单多了，只需要从github下载源码即可，不需要自己编译，可以在src文件夹中找到raygui.h文件，将其放入上面我们建好的Include文件夹中即可。</p>\n<h2 id=\"vs2022配置第三方库\"><a href=\"#vs2022配置第三方库\" class=\"headerlink\" title=\"vs2022配置第三方库\"></a>vs2022配置第三方库</h2><p><img src=\"/article_img/2023-03-25-15-16-38.png\"></p>\n<p>这里的包含目录直接填我们新建的Include文件夹，库目录填Libs文件夹即可。</p>\n<p>感谢ChatGPT！</p>\n<h1 id=\"编译源码\"><a href=\"#编译源码\" class=\"headerlink\" title=\"编译源码\"></a>编译源码</h1><h2 id=\"作者提供的方式\"><a href=\"#作者提供的方式\" class=\"headerlink\" title=\"作者提供的方式\"></a>作者提供的方式</h2><p>按照github上的<a href=\"https://github.com/orangeduck/Motion-Matching/issues/2\">Issue</a>，其实这种方法理论上不需要编译raylib源码，直接去raylib官网下载Installer即可一键安装：</p>\n<p><img src=\"/article_img/2023-03-25-15-20-53.png\"></p>\n<p>但是我在实际运行时出现了下图这样的错误，提示说UpdateCamera()缺少一个参数。</p>\n<p><img src=\"/article_img/2023-03-25-15-24-46.png\"></p>\n<p><img src=\"/article_img/2023-03-25-15-26-06.png\"></p>\n<p>按照ChatGPT的回答，可以确定应该还是依赖库的版本问题，我这里就直接改了源码，将第二个参数设置为了CAMERA_CUSTOM，即可正常编译，生成controller.exe文件。</p>\n<h2 id=\"VS2022编译方式\"><a href=\"#VS2022编译方式\" class=\"headerlink\" title=\"VS2022编译方式\"></a>VS2022编译方式</h2><p>考虑到之后可能会对源码进行修改，就尝试在VS里编译源码，我首先在VS中配置好了raylib和raygui，之后将源码中的文件全部添加到VS项目中，这是发现我的编译器似乎并不能识别部分源码的写法，如下：</p>\n<p><img src=\"/article_img/2023-03-25-15-32-24.png\"></p>\n<p>这里将括号去掉就正常了。</p>\n<p><img src=\"/article_img/2023-03-25-15-33-19.png\"></p>\n<p>这里写成下面的__restrict就可以识别了。</p>\n<p><img src=\"/article_img/2023-03-25-15-36-39.png\"></p>\n<p>这里和上述一样随便加了一个参数。</p>\n<p>这些写法问题解决之后，还不要忘了把源码中的resouce文件夹放到VS项目文件夹里，这样才能加载模型和数据库等等资源。</p>"},{"title":"Markdown用法简介","date":"2022-04-06T10:28:43.000Z","index_img":"https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png","_content":"\n本文章用来练习hexo写博客，顺便练习Markdown语法。\n\n<!-- more -->\n\ntaskkill /F /IM node.exe\nhexo创建新博客文章：hexo new \"第一篇文章\"\n# Markdown简介\nMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。旨在令人们可以专注于编辑内容，而不会因为编辑格式而分心。\n\n# 使用的编辑工具和插件\n因为不想多下一个软件，所以用vscode来编辑Markdown。\n\n使用的vscode扩展：\n\n1. **Markdown ALL in One**（包含几乎所有Markdown相关功能）\n2. **Markdown Preview Enhanced**（提供Markdown渲染后的预览，以及可以方便的导出pdf）\n3. **Paste Image**（直接从剪切板粘贴图片）\n4. **Code Spell Checker**（检查拼写错误）\n   \n# 基本的语法练习\n## 二级标题\n### 三级标题\n正文\n\n空一行换行表示另起一段，  \n打两个空格再换行表示换行但不另起一段\n\n## 强调\n两个*加粗 **加粗**\n\n一个*斜体 *斜体*\n\n## 列表\n1. 一\n2. 二\n   1. 二级列表\n\n## 图片\n\n![](/img/bg/asoul.jpg)  \n*图片的说明文字（caption）原作者：未确认_Sora*\n\n图片并排显示\n![](/article_img/2023-01-30-20-10-34.png) | ![](/article_img/2023-01-30-20-12-26.png) | ![](/article_img/2023-01-30-20-14-01.png) | ![](/article_img/2023-01-30-20-18-46.png)\n---|---|---|---\n\n## 公式（支持latex公式书写）\n\n\n$$\n\\lim_{x\\to\\ 0} \\frac{sin(x)}{x}=1\n$$\n\n\n## 表格\n\n| 向晚  | 贝拉  | 乃琳  |\n| :---: | :---: | :---: |\n|   1   |   2   |   3   |\n|   4   |   5   |   6   |\n\n**shift+alt+f** 可以格式化,让markdown编辑页面的表格同样美观\n\n## 链接\n\n这是一个[链接](https://www.bilibili.com/video/BV19Z4y1k7P7?spm_id_from=333.999.0.0)\n## 代码\n```python\ndef hello(){\n   print(\"hello world!\")\n}\n```\n# vscode插件及设置\n\n## 1. paste image\n\n\"pasteImage.BasePath\": \"${projectRoot}\"\n\n\"pasteImage.path\": \"${projectRoot}/article_img\"\n\n\"prefix\": \"/\"\n\n截图快捷键（windows自带）：**win+shift+s**\n\n粘贴快捷键：**alt+ctrl+v**\n\n## 2. Preview Markdown\n\n# 参考资料\n[Fluid主题文档](https://hexo.fluid-dev.com/docs/start/)\n\n[Hexo官方文档](https://hexo.io/zh-cn/docs/)\n\nb站视频：\n1. [教你Markdown+VSCODE实现最完美流畅写作体验](https://www.bilibili.com/video/BV1si4y1472o?spm_id_from=333.337.search-card.all.click)\n2. [【2021最新版】保姆级Hexo+github搭建个人博客](https://www.bilibili.com/video/BV1mU4y1j72n?spm_id_from=333.999.0.0)\n3. [手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo](https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.999.0.0)\n\n文章：\n1. Markdown: https://www.limfx.pro/ReadArticle/57/yi-zhong-xie-zuo-de-xin-fang-fa\n2. latex书写数学公式：https://blog.csdn.net/weixin_42373330/article/details/89785443","source":"_posts/Markdown用法简介.md","raw":"---\ntitle: Markdown用法简介\ndate: 2022-04-06 18:28:43\nindex_img: https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png\ntags: [Hexo, Fluid]\ncategories: \n   -[练习]\n---\n\n本文章用来练习hexo写博客，顺便练习Markdown语法。\n\n<!-- more -->\n\ntaskkill /F /IM node.exe\nhexo创建新博客文章：hexo new \"第一篇文章\"\n# Markdown简介\nMarkdown是一种轻量级标记语言，创始人为约翰·格鲁伯。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。旨在令人们可以专注于编辑内容，而不会因为编辑格式而分心。\n\n# 使用的编辑工具和插件\n因为不想多下一个软件，所以用vscode来编辑Markdown。\n\n使用的vscode扩展：\n\n1. **Markdown ALL in One**（包含几乎所有Markdown相关功能）\n2. **Markdown Preview Enhanced**（提供Markdown渲染后的预览，以及可以方便的导出pdf）\n3. **Paste Image**（直接从剪切板粘贴图片）\n4. **Code Spell Checker**（检查拼写错误）\n   \n# 基本的语法练习\n## 二级标题\n### 三级标题\n正文\n\n空一行换行表示另起一段，  \n打两个空格再换行表示换行但不另起一段\n\n## 强调\n两个*加粗 **加粗**\n\n一个*斜体 *斜体*\n\n## 列表\n1. 一\n2. 二\n   1. 二级列表\n\n## 图片\n\n![](/img/bg/asoul.jpg)  \n*图片的说明文字（caption）原作者：未确认_Sora*\n\n图片并排显示\n![](/article_img/2023-01-30-20-10-34.png) | ![](/article_img/2023-01-30-20-12-26.png) | ![](/article_img/2023-01-30-20-14-01.png) | ![](/article_img/2023-01-30-20-18-46.png)\n---|---|---|---\n\n## 公式（支持latex公式书写）\n\n\n$$\n\\lim_{x\\to\\ 0} \\frac{sin(x)}{x}=1\n$$\n\n\n## 表格\n\n| 向晚  | 贝拉  | 乃琳  |\n| :---: | :---: | :---: |\n|   1   |   2   |   3   |\n|   4   |   5   |   6   |\n\n**shift+alt+f** 可以格式化,让markdown编辑页面的表格同样美观\n\n## 链接\n\n这是一个[链接](https://www.bilibili.com/video/BV19Z4y1k7P7?spm_id_from=333.999.0.0)\n## 代码\n```python\ndef hello(){\n   print(\"hello world!\")\n}\n```\n# vscode插件及设置\n\n## 1. paste image\n\n\"pasteImage.BasePath\": \"${projectRoot}\"\n\n\"pasteImage.path\": \"${projectRoot}/article_img\"\n\n\"prefix\": \"/\"\n\n截图快捷键（windows自带）：**win+shift+s**\n\n粘贴快捷键：**alt+ctrl+v**\n\n## 2. Preview Markdown\n\n# 参考资料\n[Fluid主题文档](https://hexo.fluid-dev.com/docs/start/)\n\n[Hexo官方文档](https://hexo.io/zh-cn/docs/)\n\nb站视频：\n1. [教你Markdown+VSCODE实现最完美流畅写作体验](https://www.bilibili.com/video/BV1si4y1472o?spm_id_from=333.337.search-card.all.click)\n2. [【2021最新版】保姆级Hexo+github搭建个人博客](https://www.bilibili.com/video/BV1mU4y1j72n?spm_id_from=333.999.0.0)\n3. [手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo](https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.999.0.0)\n\n文章：\n1. Markdown: https://www.limfx.pro/ReadArticle/57/yi-zhong-xie-zuo-de-xin-fang-fa\n2. latex书写数学公式：https://blog.csdn.net/weixin_42373330/article/details/89785443","slug":"Markdown用法简介","published":1,"updated":"2023-02-24T06:40:08.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjiglz0019w0jeeeobc1yp","content":"<p>本文章用来练习hexo写博客，顺便练习Markdown语法。</p>\n<span id=\"more\"></span>\n\n<p>taskkill &#x2F;F &#x2F;IM node.exe<br>hexo创建新博客文章：hexo new “第一篇文章”</p>\n<h1 id=\"Markdown简介\"><a href=\"#Markdown简介\" class=\"headerlink\" title=\"Markdown简介\"></a>Markdown简介</h1><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。旨在令人们可以专注于编辑内容，而不会因为编辑格式而分心。</p>\n<h1 id=\"使用的编辑工具和插件\"><a href=\"#使用的编辑工具和插件\" class=\"headerlink\" title=\"使用的编辑工具和插件\"></a>使用的编辑工具和插件</h1><p>因为不想多下一个软件，所以用vscode来编辑Markdown。</p>\n<p>使用的vscode扩展：</p>\n<ol>\n<li><strong>Markdown ALL in One</strong>（包含几乎所有Markdown相关功能）</li>\n<li><strong>Markdown Preview Enhanced</strong>（提供Markdown渲染后的预览，以及可以方便的导出pdf）</li>\n<li><strong>Paste Image</strong>（直接从剪切板粘贴图片）</li>\n<li><strong>Code Spell Checker</strong>（检查拼写错误）</li>\n</ol>\n<h1 id=\"基本的语法练习\"><a href=\"#基本的语法练习\" class=\"headerlink\" title=\"基本的语法练习\"></a>基本的语法练习</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><p>正文</p>\n<p>空一行换行表示另起一段，<br>打两个空格再换行表示换行但不另起一段</p>\n<h2 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h2><p>两个*加粗 <strong>加粗</strong></p>\n<p>一个*斜体 <em>斜体</em></p>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>一</li>\n<li>二<ol>\n<li>二级列表</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p><img src=\"/img/bg/asoul.jpg\"><br><em>图片的说明文字（caption）原作者：未确认_Sora</em></p>\n<p>图片并排显示</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-01-30-20-10-34.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-12-26.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-14-01.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-18-46.png\"></th>\n</tr>\n</thead>\n</table>\n<h2 id=\"公式（支持latex公式书写）\"><a href=\"#公式（支持latex公式书写）\" class=\"headerlink\" title=\"公式（支持latex公式书写）\"></a>公式（支持latex公式书写）</h2><p>$$<br>\\lim_{x\\to\\ 0} \\frac{sin(x)}{x}&#x3D;1<br>$$</p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th align=\"center\">向晚</th>\n<th align=\"center\">贝拉</th>\n<th align=\"center\">乃琳</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n</tr>\n</tbody></table>\n<p><strong>shift+alt+f</strong> 可以格式化,让markdown编辑页面的表格同样美观</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>这是一个<a href=\"https://www.bilibili.com/video/BV19Z4y1k7P7?spm_id_from=333.999.0.0\">链接</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hello</span>()&#123;<br>   <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;hello world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"vscode插件及设置\"><a href=\"#vscode插件及设置\" class=\"headerlink\" title=\"vscode插件及设置\"></a>vscode插件及设置</h1><h2 id=\"1-paste-image\"><a href=\"#1-paste-image\" class=\"headerlink\" title=\"1. paste image\"></a>1. paste image</h2><p>“pasteImage.BasePath”: “${projectRoot}”</p>\n<p>“pasteImage.path”: “${projectRoot}&#x2F;article_img”</p>\n<p>“prefix”: “&#x2F;“</p>\n<p>截图快捷键（windows自带）：<strong>win+shift+s</strong></p>\n<p>粘贴快捷键：<strong>alt+ctrl+v</strong></p>\n<h2 id=\"2-Preview-Markdown\"><a href=\"#2-Preview-Markdown\" class=\"headerlink\" title=\"2. Preview Markdown\"></a>2. Preview Markdown</h2><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://hexo.fluid-dev.com/docs/start/\">Fluid主题文档</a></p>\n<p><a href=\"https://hexo.io/zh-cn/docs/\">Hexo官方文档</a></p>\n<p>b站视频：</p>\n<ol>\n<li><a href=\"https://www.bilibili.com/video/BV1si4y1472o?spm_id_from=333.337.search-card.all.click\">教你Markdown+VSCODE实现最完美流畅写作体验</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1mU4y1j72n?spm_id_from=333.999.0.0\">【2021最新版】保姆级Hexo+github搭建个人博客</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.999.0.0\">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></li>\n</ol>\n<p>文章：</p>\n<ol>\n<li>Markdown: <a href=\"https://www.limfx.pro/ReadArticle/57/yi-zhong-xie-zuo-de-xin-fang-fa\">https://www.limfx.pro/ReadArticle/57/yi-zhong-xie-zuo-de-xin-fang-fa</a></li>\n<li>latex书写数学公式：<a href=\"https://blog.csdn.net/weixin_42373330/article/details/89785443\">https://blog.csdn.net/weixin_42373330/article/details/89785443</a></li>\n</ol>\n","site":{"data":{}},"wordcount":1154,"excerpt":"<p>本文章用来练习hexo写博客，顺便练习Markdown语法。</p>","more":"<p>taskkill &#x2F;F &#x2F;IM node.exe<br>hexo创建新博客文章：hexo new “第一篇文章”</p>\n<h1 id=\"Markdown简介\"><a href=\"#Markdown简介\" class=\"headerlink\" title=\"Markdown简介\"></a>Markdown简介</h1><p>Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。旨在令人们可以专注于编辑内容，而不会因为编辑格式而分心。</p>\n<h1 id=\"使用的编辑工具和插件\"><a href=\"#使用的编辑工具和插件\" class=\"headerlink\" title=\"使用的编辑工具和插件\"></a>使用的编辑工具和插件</h1><p>因为不想多下一个软件，所以用vscode来编辑Markdown。</p>\n<p>使用的vscode扩展：</p>\n<ol>\n<li><strong>Markdown ALL in One</strong>（包含几乎所有Markdown相关功能）</li>\n<li><strong>Markdown Preview Enhanced</strong>（提供Markdown渲染后的预览，以及可以方便的导出pdf）</li>\n<li><strong>Paste Image</strong>（直接从剪切板粘贴图片）</li>\n<li><strong>Code Spell Checker</strong>（检查拼写错误）</li>\n</ol>\n<h1 id=\"基本的语法练习\"><a href=\"#基本的语法练习\" class=\"headerlink\" title=\"基本的语法练习\"></a>基本的语法练习</h1><h2 id=\"二级标题\"><a href=\"#二级标题\" class=\"headerlink\" title=\"二级标题\"></a>二级标题</h2><h3 id=\"三级标题\"><a href=\"#三级标题\" class=\"headerlink\" title=\"三级标题\"></a>三级标题</h3><p>正文</p>\n<p>空一行换行表示另起一段，<br>打两个空格再换行表示换行但不另起一段</p>\n<h2 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h2><p>两个*加粗 <strong>加粗</strong></p>\n<p>一个*斜体 <em>斜体</em></p>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><ol>\n<li>一</li>\n<li>二<ol>\n<li>二级列表</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p><img src=\"/img/bg/asoul.jpg\"><br><em>图片的说明文字（caption）原作者：未确认_Sora</em></p>\n<p>图片并排显示</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-01-30-20-10-34.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-12-26.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-14-01.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-18-46.png\"></th>\n</tr>\n</thead>\n</table>\n<h2 id=\"公式（支持latex公式书写）\"><a href=\"#公式（支持latex公式书写）\" class=\"headerlink\" title=\"公式（支持latex公式书写）\"></a>公式（支持latex公式书写）</h2><p>$$<br>\\lim_{x\\to\\ 0} \\frac{sin(x)}{x}&#x3D;1<br>$$</p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><table>\n<thead>\n<tr>\n<th align=\"center\">向晚</th>\n<th align=\"center\">贝拉</th>\n<th align=\"center\">乃琳</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">1</td>\n<td align=\"center\">2</td>\n<td align=\"center\">3</td>\n</tr>\n<tr>\n<td align=\"center\">4</td>\n<td align=\"center\">5</td>\n<td align=\"center\">6</td>\n</tr>\n</tbody></table>\n<p><strong>shift+alt+f</strong> 可以格式化,让markdown编辑页面的表格同样美观</p>\n<h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>这是一个<a href=\"https://www.bilibili.com/video/BV19Z4y1k7P7?spm_id_from=333.999.0.0\">链接</a></p>\n<h2 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">hello</span>()&#123;<br>   <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;hello world!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<h1 id=\"vscode插件及设置\"><a href=\"#vscode插件及设置\" class=\"headerlink\" title=\"vscode插件及设置\"></a>vscode插件及设置</h1><h2 id=\"1-paste-image\"><a href=\"#1-paste-image\" class=\"headerlink\" title=\"1. paste image\"></a>1. paste image</h2><p>“pasteImage.BasePath”: “${projectRoot}”</p>\n<p>“pasteImage.path”: “${projectRoot}&#x2F;article_img”</p>\n<p>“prefix”: “&#x2F;“</p>\n<p>截图快捷键（windows自带）：<strong>win+shift+s</strong></p>\n<p>粘贴快捷键：<strong>alt+ctrl+v</strong></p>\n<h2 id=\"2-Preview-Markdown\"><a href=\"#2-Preview-Markdown\" class=\"headerlink\" title=\"2. Preview Markdown\"></a>2. Preview Markdown</h2><h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://hexo.fluid-dev.com/docs/start/\">Fluid主题文档</a></p>\n<p><a href=\"https://hexo.io/zh-cn/docs/\">Hexo官方文档</a></p>\n<p>b站视频：</p>\n<ol>\n<li><a href=\"https://www.bilibili.com/video/BV1si4y1472o?spm_id_from=333.337.search-card.all.click\">教你Markdown+VSCODE实现最完美流畅写作体验</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1mU4y1j72n?spm_id_from=333.999.0.0\">【2021最新版】保姆级Hexo+github搭建个人博客</a></li>\n<li><a href=\"https://www.bilibili.com/video/BV1Yb411a7ty?spm_id_from=333.999.0.0\">手把手教你从0开始搭建自己的个人博客 |无坑版视频教程| hexo</a></li>\n</ol>\n<p>文章：</p>\n<ol>\n<li>Markdown: <a href=\"https://www.limfx.pro/ReadArticle/57/yi-zhong-xie-zuo-de-xin-fang-fa\">https://www.limfx.pro/ReadArticle/57/yi-zhong-xie-zuo-de-xin-fang-fa</a></li>\n<li>latex书写数学公式：<a href=\"https://blog.csdn.net/weixin_42373330/article/details/89785443\">https://blog.csdn.net/weixin_42373330/article/details/89785443</a></li>\n</ol>"},{"title":"MotionMactching基础","date":"2023-03-25T16:00:00.000Z","index_img":"/img/bg/Motion_Matching.png","_content":"\nMotionMactching基础\n<!-- more -->\n\n![](/article_img/mm_1.gif) | ![](/article_img/LMM_M.gif) | ![](/article_img/LMM_L.gif)\n---|---|---\n\n# Motion Matching简介\n\nMotion Matching是由育碧在GDC2016上提出的一项技术，可以使角色动作更加流畅和真实。与其他方法相比，它不需要在动作图中构造动画片段的结构，不需要仔细地切分或同步它们，也不需要在状态之间显式地创建新的转换。现如今已经被广泛应用在3A游戏中，如《荣耀战魂》，《刺客信条：奥德赛》以及最近的《黑神话：悟空》团队也表明他们也会使用Motion Matching技术。\n\n# 为什么要用Motion Matching \n\n如果把游戏的动画系统想象成一个黑盒，我们希望用户输入指令，动画系统这个黑盒输出相应的动画。\n动画状态机就是目前动画系统这个黑盒最常用的实现方式。\n![](/article_img/2023-03-26-13-35-34.png)\n\n动画状态机需要设置不同的状态（例如走路，跑步），这些不同的状态分别对应不同的动画片段（Animation Clip），除了这些状态外还需要设置状态之间的切换条件，当满足这个条件时进行状态的切换也就是切换播放的动画片段。\n\n动画状态机虽然很直观，但是其也有很多问题：\n1. 复杂度高：动画状态机需要设计和编写，对于复杂的游戏角色，需要设计更多的状态和转换，使得状态机的复杂度变得很高，需要耗费更多的时间和精力。\n   ![](/article_img/2023-03-26-13-34-47.png)\n2. 难以处理动画过渡：动画状态机中的动画过渡需要手动设置，需要设计人员具有一定的动画技能和经验，否则可能会导致角色动画的不自然和不流畅。\n   **Is there a way to deal with loops and transitions in a uniform way?**——[Simon Clavet - \"Motion Matching and The Road to Next-Gen Animation\"](https://archive.org/details/GDC2016Clavet/page/n23/mode/2up)\n3. 难以适应变化：如果游戏需要进行修改或扩展，动画状态机可能需要进行重构或重写，这需要耗费更多的时间和精力。\n4. 有一些动作难以写入状态机\n   ![](/article_img/2023-03-26-15-28-33.png)\n\n\n为了解决这些问题，育碧提出了Motion Matching。\n\n# Motion Matching的发展史\n\n## Motion Graphs\n\n![](/article_img/2023-03-26-14-43-26.png)\n\nMotion Graphs是2002年的工作，他主要是对动画片段中的每一帧进行对比，得到最相似的两帧（可以是速度，位置，pose等等），就设置这两帧为可过渡点。\n\n![](/article_img/2023-03-26-15-03-35.png)\n\n但是这篇工作中的过渡点是预先设定好的，导致动作反馈的及时性比较差，但是找到相似的动画作为下一帧动画的这个思想留给了后人。\n\n## Motion Fields\n\n![](/article_img/2023-03-26-14-42-38.png)\n\n这个技术也是一个划时代的技术，其实现效果已经很接近motion matching了，但是其实现方式过于复杂。\n\n![](/article_img/2023-03-26-15-17-25.png)\n\n具体就不讲了，可以参考[games105-lecture06](https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20)，这篇工作虽然实现方式很复杂，但是其提供了一个重要的思想：我们可以转换到任何一个我们想要的动画帧。\n\nmotion matching就是在motion fields的基础上进行简化得来的。\n\n# Motion Matching的实现\n\n![](/article_img/2023-03-26-15-19-55.png)\n\n可以看出Motion Matching中最重要的就是**如何找到动画数据库中满足用户输入的条件下与当前帧最相近的动画数据。** 用其创始人Simon的话说，这是一个十分暴力的动画搜索方法。\n\n![](/article_img/2023-03-26-15-36-18.png)\n\n## 动画数据库（实现Motion Matching的第一步）\n\n![](/article_img/2023-03-26-15-38-16.png)\n\n![](/article_img/2023-03-26-15-38-26.png) | ![](/article_img/2023-03-26-15-38-35.png) | ![](/article_img/2023-03-26-15-38-40.png)\n---|---|---\n\nMotion Matching使用的动画数据大多来自动作捕捉，为了尽量高效的得到足够多的动作数据，育碧研究人员提出了一个概念叫Dance Card，动捕演员只需要按照Dance Card上的路径进行完成指定动作即可。\n\n## 代码实现\n\n![](/article_img/2023-03-26-15-42-58.png)\n![](/article_img/2023-03-26-15-43-07.png)\n![](/article_img/2023-03-26-15-48-40.png)\n\n这就是育碧在GDC上给出的代码实现，也是Motion Matching的思路，十分简洁明了。可以看出关键点就是我们上文提出的如何选择下一个要过渡的动画帧，即**ComputeCost**这个函数。\n\n源码把Cost分为了两部分（situation和trajectory）,我们把计算Cost更直观的分为三部分：\n1. 姿态的Cost，表示候选动画帧姿态和当前姿态的匹配程度；\n2. 速度的Cost，表示候选动画帧的速度，加速度，角速度等信息与当前动画帧的匹配程度；\n3. 轨迹的Cost，表示候选动画帧轨迹和当前用户输入轨迹的匹配程度；\n\n当然各个Cost要加权平均得到最终的Cost！\n\n### 姿态Cost\n\n角色动画数据本质就是定义了每个关节的旋转和位置，以及一些运动速度等信息。\n\n在姿势匹配阶段，我们不需要匹配每一个关节的旋转和位置，只需要选取几个重要的关节即可，因为这些关节已经可以很好的代表一个姿势了，一般是左右脚和尾椎骨，也可以根据需要添加，如荣耀战魂中还添加了武器的骨骼。\n\n![](/article_img/2023-03-26-16-07-46.png)\n![](/article_img/2023-03-26-16-08-09.png)\n\n### 速度Cost\n\n和姿态Cost计算基本一样，直接对比动画数据即可。\n\n### 轨迹Cost\n\n![](/article_img/2023-03-26-16-10-17.png)\n\n轨迹计算部分，育碧的源码考虑了未来几帧和过去几帧的位置和朝向，考虑未来的轨迹很好理解，为什么还要考虑过去的轨迹呢？如下图，有可能两个动作片段未来的行为一样，但是其过去不同，这时为了能更好的分辨出哪个动作片段更好，就需要引入过去的行为。\n\n![](/article_img/2023-03-26-16-13-26.png) | ![](/article_img/2023-03-26-16-13-32.png)\n---|---\n\n我们将计算的这些位置和朝向信息的Cost相加就是最终的Cost\n\n![](/article_img/2023-03-26-16-15-31.png) | ![](/article_img/2023-03-26-16-15-40.png)\n---|---\n\n## Motion Matching的优化问题\n\n1. 提前计算特征\n2. 惯性化过渡\n3. 镜像数据表\n4. LOD\n5. KD-Tree\n6. 无需每帧都去寻找最优动画\n   因为如果用户没有改变输入，角色一直向前走，只需要从当前动画帧继续向后播放即可。\n\n可以发现，由于Motion Matching算法本身就是一个搜索算法，不论如何加速，都需要将数据库中的数据放入内存，而Motion Matching实现动画过渡真实自然的基础就是很大的动作数据库，因此Motion Matching对内存的占用很大，这也是限制其在移动端大量应用的原因。\n\n# Learned Motion Matching\n\n![](/article_img/2023-03-26-18-32-27.png)\n\n为了减小内存占用就要在Motion Matching实现过程中去除对动画数据库的依赖。Learned Motion Matching基于传统Motion Matching，用神经网络代替动画数据库，在实现了很好的动作效果的同时，大大降低了内存占用。\n\n![](/article_img/LMM_M.gif) | ![](/article_img/LMM_L.gif)\n---|---\n\n## 传统Motion Matching\n首先我们先回顾一下Motion Matching：\n\n![](/article_img/2023-03-26-18-08-33.png)\n\n动画片段是由一系列的姿势（full poses）组成的，每个姿势有一个帧序号（frame index）指出这个姿势在动画数据库中的位置，向后播放动画意味着每帧增加frame index并且从动画数据库中找到对应的姿势，每隔几帧做一次利用特征序列（当前姿态信息和由输入估计的轨迹）和特征数据库（提前计算好的动作特征）做对比实现的动作匹配搜索（Motion Matching Search），得到的最匹配的动画帧替换当前帧，作为下一帧继续播放。\n\n## 代替动作数据库\n\n![](/article_img/2023-03-26-18-26-36.png)\n\n首先尝试去除对每帧进行的访问动作数据库的依赖，将直接去动作数据库中寻找动作替换成去特征数据库中寻找特征，找到的特征作为一个叫做Decompressor（可以理解为将动作特征解压成完整的动作）的神经网络的输入，由这个神经网络得到完整的姿势（这里是可行的，作者Daniel Holden的另一些工作PFNN就是尝试生成动作）\n\n![](/article_img/CompDecomp.gif)\n\n图中灰色的是直接访问动作数据库生成的，橙色的是Decompressor生成的，可以看到动画效果几乎没有区别，但是仔细观察骨骼的手部，发现还是有差异，这是由于特征不足引起的，我们可以添加更多的特征，但是我们可以用另一个神经网络自动找到这些额外的特征：\n\n![](/article_img/2023-03-26-18-48-25.png)\n\n添加了这个网络之后，动作质量更高了。\n\n![](/article_img/CompDecompWithExtraFeatures.gif)\n\n当去掉了对动作数据库的依赖之后，内存减少了很多：\n![](/article_img/2023-03-26-18-50-00.png)\n\n经过以上优化之后，整个过程如下图，但这时这两个特征数据库实际上还是随动作数据库的增大而增大，如果我们的动作数据库足够大，这两个特征数据库也会占用很大的内存。\n\n![](/article_img/2023-03-26-18-56-23.png)\n\n下一步尝试在每一帧摆脱对特征数据库（Combined Features Database）的依赖。\n\n## 代替特征数据库\n\n首先代替每一帧中的Feature Lookup，如果可以将每一帧的输入换成特征数据（当前动作的特征），可以训练一个神经网络叫做Stepper输出下一帧的动作特征，由于我们每隔几帧就会进行Motion Matching Search，因此这个Stepper网络只需要预测出之后很短一段时间动作特征的变化。此时整个逻辑如下：\n\n![](/article_img/2023-03-26-19-14-54.png)\n![](/article_img/2023-03-26-19-14-59.png)\n\n最后我们再训练一个神经网络Projector，用来直接预测与当前输入特征最匹配的特征：\n\n![](/article_img/2023-03-26-19-17-06.png)\n\n最终的整个Learned Motion Matching过程如下：\n![](/article_img/2023-03-26-19-17-26.png)\n\n现在的内存比较：\n![](/article_img/2023-03-26-19-18-48.png)\n![](/article_img/2023-03-26-19-22-16.png)\n\n# 参考资料\n\n[GDC2016-Motion Matching](https://archive.org/details/GDC2016Clavet/mode/2up)\n[introducing-learned-motion-matching](https://montreal.ubisoft.com/en/introducing-learned-motion-matching/) 中文翻译：[Motion Matching的发展回顾](https://zhuanlan.zhihu.com/p/611573006)\n[简单聊聊Motion Matching](https://zhuanlan.zhihu.com/p/378189446)\n[Games105-计算机角色动画-06](https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n\n","source":"_posts/MotionMactching基础.md","raw":"---\ntitle: MotionMactching基础\ndate: 2023-03-26\nindex_img: \"/img/bg/Motion_Matching.png\"\ntags: [计算机角色动画]\ncategories: \n   -[笔记]\n---\n\nMotionMactching基础\n<!-- more -->\n\n![](/article_img/mm_1.gif) | ![](/article_img/LMM_M.gif) | ![](/article_img/LMM_L.gif)\n---|---|---\n\n# Motion Matching简介\n\nMotion Matching是由育碧在GDC2016上提出的一项技术，可以使角色动作更加流畅和真实。与其他方法相比，它不需要在动作图中构造动画片段的结构，不需要仔细地切分或同步它们，也不需要在状态之间显式地创建新的转换。现如今已经被广泛应用在3A游戏中，如《荣耀战魂》，《刺客信条：奥德赛》以及最近的《黑神话：悟空》团队也表明他们也会使用Motion Matching技术。\n\n# 为什么要用Motion Matching \n\n如果把游戏的动画系统想象成一个黑盒，我们希望用户输入指令，动画系统这个黑盒输出相应的动画。\n动画状态机就是目前动画系统这个黑盒最常用的实现方式。\n![](/article_img/2023-03-26-13-35-34.png)\n\n动画状态机需要设置不同的状态（例如走路，跑步），这些不同的状态分别对应不同的动画片段（Animation Clip），除了这些状态外还需要设置状态之间的切换条件，当满足这个条件时进行状态的切换也就是切换播放的动画片段。\n\n动画状态机虽然很直观，但是其也有很多问题：\n1. 复杂度高：动画状态机需要设计和编写，对于复杂的游戏角色，需要设计更多的状态和转换，使得状态机的复杂度变得很高，需要耗费更多的时间和精力。\n   ![](/article_img/2023-03-26-13-34-47.png)\n2. 难以处理动画过渡：动画状态机中的动画过渡需要手动设置，需要设计人员具有一定的动画技能和经验，否则可能会导致角色动画的不自然和不流畅。\n   **Is there a way to deal with loops and transitions in a uniform way?**——[Simon Clavet - \"Motion Matching and The Road to Next-Gen Animation\"](https://archive.org/details/GDC2016Clavet/page/n23/mode/2up)\n3. 难以适应变化：如果游戏需要进行修改或扩展，动画状态机可能需要进行重构或重写，这需要耗费更多的时间和精力。\n4. 有一些动作难以写入状态机\n   ![](/article_img/2023-03-26-15-28-33.png)\n\n\n为了解决这些问题，育碧提出了Motion Matching。\n\n# Motion Matching的发展史\n\n## Motion Graphs\n\n![](/article_img/2023-03-26-14-43-26.png)\n\nMotion Graphs是2002年的工作，他主要是对动画片段中的每一帧进行对比，得到最相似的两帧（可以是速度，位置，pose等等），就设置这两帧为可过渡点。\n\n![](/article_img/2023-03-26-15-03-35.png)\n\n但是这篇工作中的过渡点是预先设定好的，导致动作反馈的及时性比较差，但是找到相似的动画作为下一帧动画的这个思想留给了后人。\n\n## Motion Fields\n\n![](/article_img/2023-03-26-14-42-38.png)\n\n这个技术也是一个划时代的技术，其实现效果已经很接近motion matching了，但是其实现方式过于复杂。\n\n![](/article_img/2023-03-26-15-17-25.png)\n\n具体就不讲了，可以参考[games105-lecture06](https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20)，这篇工作虽然实现方式很复杂，但是其提供了一个重要的思想：我们可以转换到任何一个我们想要的动画帧。\n\nmotion matching就是在motion fields的基础上进行简化得来的。\n\n# Motion Matching的实现\n\n![](/article_img/2023-03-26-15-19-55.png)\n\n可以看出Motion Matching中最重要的就是**如何找到动画数据库中满足用户输入的条件下与当前帧最相近的动画数据。** 用其创始人Simon的话说，这是一个十分暴力的动画搜索方法。\n\n![](/article_img/2023-03-26-15-36-18.png)\n\n## 动画数据库（实现Motion Matching的第一步）\n\n![](/article_img/2023-03-26-15-38-16.png)\n\n![](/article_img/2023-03-26-15-38-26.png) | ![](/article_img/2023-03-26-15-38-35.png) | ![](/article_img/2023-03-26-15-38-40.png)\n---|---|---\n\nMotion Matching使用的动画数据大多来自动作捕捉，为了尽量高效的得到足够多的动作数据，育碧研究人员提出了一个概念叫Dance Card，动捕演员只需要按照Dance Card上的路径进行完成指定动作即可。\n\n## 代码实现\n\n![](/article_img/2023-03-26-15-42-58.png)\n![](/article_img/2023-03-26-15-43-07.png)\n![](/article_img/2023-03-26-15-48-40.png)\n\n这就是育碧在GDC上给出的代码实现，也是Motion Matching的思路，十分简洁明了。可以看出关键点就是我们上文提出的如何选择下一个要过渡的动画帧，即**ComputeCost**这个函数。\n\n源码把Cost分为了两部分（situation和trajectory）,我们把计算Cost更直观的分为三部分：\n1. 姿态的Cost，表示候选动画帧姿态和当前姿态的匹配程度；\n2. 速度的Cost，表示候选动画帧的速度，加速度，角速度等信息与当前动画帧的匹配程度；\n3. 轨迹的Cost，表示候选动画帧轨迹和当前用户输入轨迹的匹配程度；\n\n当然各个Cost要加权平均得到最终的Cost！\n\n### 姿态Cost\n\n角色动画数据本质就是定义了每个关节的旋转和位置，以及一些运动速度等信息。\n\n在姿势匹配阶段，我们不需要匹配每一个关节的旋转和位置，只需要选取几个重要的关节即可，因为这些关节已经可以很好的代表一个姿势了，一般是左右脚和尾椎骨，也可以根据需要添加，如荣耀战魂中还添加了武器的骨骼。\n\n![](/article_img/2023-03-26-16-07-46.png)\n![](/article_img/2023-03-26-16-08-09.png)\n\n### 速度Cost\n\n和姿态Cost计算基本一样，直接对比动画数据即可。\n\n### 轨迹Cost\n\n![](/article_img/2023-03-26-16-10-17.png)\n\n轨迹计算部分，育碧的源码考虑了未来几帧和过去几帧的位置和朝向，考虑未来的轨迹很好理解，为什么还要考虑过去的轨迹呢？如下图，有可能两个动作片段未来的行为一样，但是其过去不同，这时为了能更好的分辨出哪个动作片段更好，就需要引入过去的行为。\n\n![](/article_img/2023-03-26-16-13-26.png) | ![](/article_img/2023-03-26-16-13-32.png)\n---|---\n\n我们将计算的这些位置和朝向信息的Cost相加就是最终的Cost\n\n![](/article_img/2023-03-26-16-15-31.png) | ![](/article_img/2023-03-26-16-15-40.png)\n---|---\n\n## Motion Matching的优化问题\n\n1. 提前计算特征\n2. 惯性化过渡\n3. 镜像数据表\n4. LOD\n5. KD-Tree\n6. 无需每帧都去寻找最优动画\n   因为如果用户没有改变输入，角色一直向前走，只需要从当前动画帧继续向后播放即可。\n\n可以发现，由于Motion Matching算法本身就是一个搜索算法，不论如何加速，都需要将数据库中的数据放入内存，而Motion Matching实现动画过渡真实自然的基础就是很大的动作数据库，因此Motion Matching对内存的占用很大，这也是限制其在移动端大量应用的原因。\n\n# Learned Motion Matching\n\n![](/article_img/2023-03-26-18-32-27.png)\n\n为了减小内存占用就要在Motion Matching实现过程中去除对动画数据库的依赖。Learned Motion Matching基于传统Motion Matching，用神经网络代替动画数据库，在实现了很好的动作效果的同时，大大降低了内存占用。\n\n![](/article_img/LMM_M.gif) | ![](/article_img/LMM_L.gif)\n---|---\n\n## 传统Motion Matching\n首先我们先回顾一下Motion Matching：\n\n![](/article_img/2023-03-26-18-08-33.png)\n\n动画片段是由一系列的姿势（full poses）组成的，每个姿势有一个帧序号（frame index）指出这个姿势在动画数据库中的位置，向后播放动画意味着每帧增加frame index并且从动画数据库中找到对应的姿势，每隔几帧做一次利用特征序列（当前姿态信息和由输入估计的轨迹）和特征数据库（提前计算好的动作特征）做对比实现的动作匹配搜索（Motion Matching Search），得到的最匹配的动画帧替换当前帧，作为下一帧继续播放。\n\n## 代替动作数据库\n\n![](/article_img/2023-03-26-18-26-36.png)\n\n首先尝试去除对每帧进行的访问动作数据库的依赖，将直接去动作数据库中寻找动作替换成去特征数据库中寻找特征，找到的特征作为一个叫做Decompressor（可以理解为将动作特征解压成完整的动作）的神经网络的输入，由这个神经网络得到完整的姿势（这里是可行的，作者Daniel Holden的另一些工作PFNN就是尝试生成动作）\n\n![](/article_img/CompDecomp.gif)\n\n图中灰色的是直接访问动作数据库生成的，橙色的是Decompressor生成的，可以看到动画效果几乎没有区别，但是仔细观察骨骼的手部，发现还是有差异，这是由于特征不足引起的，我们可以添加更多的特征，但是我们可以用另一个神经网络自动找到这些额外的特征：\n\n![](/article_img/2023-03-26-18-48-25.png)\n\n添加了这个网络之后，动作质量更高了。\n\n![](/article_img/CompDecompWithExtraFeatures.gif)\n\n当去掉了对动作数据库的依赖之后，内存减少了很多：\n![](/article_img/2023-03-26-18-50-00.png)\n\n经过以上优化之后，整个过程如下图，但这时这两个特征数据库实际上还是随动作数据库的增大而增大，如果我们的动作数据库足够大，这两个特征数据库也会占用很大的内存。\n\n![](/article_img/2023-03-26-18-56-23.png)\n\n下一步尝试在每一帧摆脱对特征数据库（Combined Features Database）的依赖。\n\n## 代替特征数据库\n\n首先代替每一帧中的Feature Lookup，如果可以将每一帧的输入换成特征数据（当前动作的特征），可以训练一个神经网络叫做Stepper输出下一帧的动作特征，由于我们每隔几帧就会进行Motion Matching Search，因此这个Stepper网络只需要预测出之后很短一段时间动作特征的变化。此时整个逻辑如下：\n\n![](/article_img/2023-03-26-19-14-54.png)\n![](/article_img/2023-03-26-19-14-59.png)\n\n最后我们再训练一个神经网络Projector，用来直接预测与当前输入特征最匹配的特征：\n\n![](/article_img/2023-03-26-19-17-06.png)\n\n最终的整个Learned Motion Matching过程如下：\n![](/article_img/2023-03-26-19-17-26.png)\n\n现在的内存比较：\n![](/article_img/2023-03-26-19-18-48.png)\n![](/article_img/2023-03-26-19-22-16.png)\n\n# 参考资料\n\n[GDC2016-Motion Matching](https://archive.org/details/GDC2016Clavet/mode/2up)\n[introducing-learned-motion-matching](https://montreal.ubisoft.com/en/introducing-learned-motion-matching/) 中文翻译：[Motion Matching的发展回顾](https://zhuanlan.zhihu.com/p/611573006)\n[简单聊聊Motion Matching](https://zhuanlan.zhihu.com/p/378189446)\n[Games105-计算机角色动画-06](https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n\n","slug":"MotionMactching基础","published":1,"updated":"2023-03-26T11:30:49.361Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigm0001ew0je93hbaule","content":"<p>MotionMactching基础</p>\n<span id=\"more\"></span>\n\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/mm_1.gif\"></th>\n<th><img src=\"/article_img/LMM_M.gif\"></th>\n<th><img src=\"/article_img/LMM_L.gif\"></th>\n</tr>\n</thead>\n</table>\n<h1 id=\"Motion-Matching简介\"><a href=\"#Motion-Matching简介\" class=\"headerlink\" title=\"Motion Matching简介\"></a>Motion Matching简介</h1><p>Motion Matching是由育碧在GDC2016上提出的一项技术，可以使角色动作更加流畅和真实。与其他方法相比，它不需要在动作图中构造动画片段的结构，不需要仔细地切分或同步它们，也不需要在状态之间显式地创建新的转换。现如今已经被广泛应用在3A游戏中，如《荣耀战魂》，《刺客信条：奥德赛》以及最近的《黑神话：悟空》团队也表明他们也会使用Motion Matching技术。</p>\n<h1 id=\"为什么要用Motion-Matching\"><a href=\"#为什么要用Motion-Matching\" class=\"headerlink\" title=\"为什么要用Motion Matching\"></a>为什么要用Motion Matching</h1><p>如果把游戏的动画系统想象成一个黑盒，我们希望用户输入指令，动画系统这个黑盒输出相应的动画。<br>动画状态机就是目前动画系统这个黑盒最常用的实现方式。<br><img src=\"/article_img/2023-03-26-13-35-34.png\"></p>\n<p>动画状态机需要设置不同的状态（例如走路，跑步），这些不同的状态分别对应不同的动画片段（Animation Clip），除了这些状态外还需要设置状态之间的切换条件，当满足这个条件时进行状态的切换也就是切换播放的动画片段。</p>\n<p>动画状态机虽然很直观，但是其也有很多问题：</p>\n<ol>\n<li>复杂度高：动画状态机需要设计和编写，对于复杂的游戏角色，需要设计更多的状态和转换，使得状态机的复杂度变得很高，需要耗费更多的时间和精力。<br><img src=\"/article_img/2023-03-26-13-34-47.png\"></li>\n<li>难以处理动画过渡：动画状态机中的动画过渡需要手动设置，需要设计人员具有一定的动画技能和经验，否则可能会导致角色动画的不自然和不流畅。<br>**Is there a way to deal with loops and transitions in a uniform way?**——<a href=\"https://archive.org/details/GDC2016Clavet/page/n23/mode/2up\">Simon Clavet - “Motion Matching and The Road to Next-Gen Animation”</a></li>\n<li>难以适应变化：如果游戏需要进行修改或扩展，动画状态机可能需要进行重构或重写，这需要耗费更多的时间和精力。</li>\n<li>有一些动作难以写入状态机<br><img src=\"/article_img/2023-03-26-15-28-33.png\"></li>\n</ol>\n<p>为了解决这些问题，育碧提出了Motion Matching。</p>\n<h1 id=\"Motion-Matching的发展史\"><a href=\"#Motion-Matching的发展史\" class=\"headerlink\" title=\"Motion Matching的发展史\"></a>Motion Matching的发展史</h1><h2 id=\"Motion-Graphs\"><a href=\"#Motion-Graphs\" class=\"headerlink\" title=\"Motion Graphs\"></a>Motion Graphs</h2><p><img src=\"/article_img/2023-03-26-14-43-26.png\"></p>\n<p>Motion Graphs是2002年的工作，他主要是对动画片段中的每一帧进行对比，得到最相似的两帧（可以是速度，位置，pose等等），就设置这两帧为可过渡点。</p>\n<p><img src=\"/article_img/2023-03-26-15-03-35.png\"></p>\n<p>但是这篇工作中的过渡点是预先设定好的，导致动作反馈的及时性比较差，但是找到相似的动画作为下一帧动画的这个思想留给了后人。</p>\n<h2 id=\"Motion-Fields\"><a href=\"#Motion-Fields\" class=\"headerlink\" title=\"Motion Fields\"></a>Motion Fields</h2><p><img src=\"/article_img/2023-03-26-14-42-38.png\"></p>\n<p>这个技术也是一个划时代的技术，其实现效果已经很接近motion matching了，但是其实现方式过于复杂。</p>\n<p><img src=\"/article_img/2023-03-26-15-17-25.png\"></p>\n<p>具体就不讲了，可以参考<a href=\"https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20\">games105-lecture06</a>，这篇工作虽然实现方式很复杂，但是其提供了一个重要的思想：我们可以转换到任何一个我们想要的动画帧。</p>\n<p>motion matching就是在motion fields的基础上进行简化得来的。</p>\n<h1 id=\"Motion-Matching的实现\"><a href=\"#Motion-Matching的实现\" class=\"headerlink\" title=\"Motion Matching的实现\"></a>Motion Matching的实现</h1><p><img src=\"/article_img/2023-03-26-15-19-55.png\"></p>\n<p>可以看出Motion Matching中最重要的就是<strong>如何找到动画数据库中满足用户输入的条件下与当前帧最相近的动画数据。</strong> 用其创始人Simon的话说，这是一个十分暴力的动画搜索方法。</p>\n<p><img src=\"/article_img/2023-03-26-15-36-18.png\"></p>\n<h2 id=\"动画数据库（实现Motion-Matching的第一步）\"><a href=\"#动画数据库（实现Motion-Matching的第一步）\" class=\"headerlink\" title=\"动画数据库（实现Motion Matching的第一步）\"></a>动画数据库（实现Motion Matching的第一步）</h2><p><img src=\"/article_img/2023-03-26-15-38-16.png\"></p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-03-26-15-38-26.png\"></th>\n<th><img src=\"/article_img/2023-03-26-15-38-35.png\"></th>\n<th><img src=\"/article_img/2023-03-26-15-38-40.png\"></th>\n</tr>\n</thead>\n</table>\n<p>Motion Matching使用的动画数据大多来自动作捕捉，为了尽量高效的得到足够多的动作数据，育碧研究人员提出了一个概念叫Dance Card，动捕演员只需要按照Dance Card上的路径进行完成指定动作即可。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p><img src=\"/article_img/2023-03-26-15-42-58.png\"><br><img src=\"/article_img/2023-03-26-15-43-07.png\"><br><img src=\"/article_img/2023-03-26-15-48-40.png\"></p>\n<p>这就是育碧在GDC上给出的代码实现，也是Motion Matching的思路，十分简洁明了。可以看出关键点就是我们上文提出的如何选择下一个要过渡的动画帧，即<strong>ComputeCost</strong>这个函数。</p>\n<p>源码把Cost分为了两部分（situation和trajectory）,我们把计算Cost更直观的分为三部分：</p>\n<ol>\n<li>姿态的Cost，表示候选动画帧姿态和当前姿态的匹配程度；</li>\n<li>速度的Cost，表示候选动画帧的速度，加速度，角速度等信息与当前动画帧的匹配程度；</li>\n<li>轨迹的Cost，表示候选动画帧轨迹和当前用户输入轨迹的匹配程度；</li>\n</ol>\n<p>当然各个Cost要加权平均得到最终的Cost！</p>\n<h3 id=\"姿态Cost\"><a href=\"#姿态Cost\" class=\"headerlink\" title=\"姿态Cost\"></a>姿态Cost</h3><p>角色动画数据本质就是定义了每个关节的旋转和位置，以及一些运动速度等信息。</p>\n<p>在姿势匹配阶段，我们不需要匹配每一个关节的旋转和位置，只需要选取几个重要的关节即可，因为这些关节已经可以很好的代表一个姿势了，一般是左右脚和尾椎骨，也可以根据需要添加，如荣耀战魂中还添加了武器的骨骼。</p>\n<p><img src=\"/article_img/2023-03-26-16-07-46.png\"><br><img src=\"/article_img/2023-03-26-16-08-09.png\"></p>\n<h3 id=\"速度Cost\"><a href=\"#速度Cost\" class=\"headerlink\" title=\"速度Cost\"></a>速度Cost</h3><p>和姿态Cost计算基本一样，直接对比动画数据即可。</p>\n<h3 id=\"轨迹Cost\"><a href=\"#轨迹Cost\" class=\"headerlink\" title=\"轨迹Cost\"></a>轨迹Cost</h3><p><img src=\"/article_img/2023-03-26-16-10-17.png\"></p>\n<p>轨迹计算部分，育碧的源码考虑了未来几帧和过去几帧的位置和朝向，考虑未来的轨迹很好理解，为什么还要考虑过去的轨迹呢？如下图，有可能两个动作片段未来的行为一样，但是其过去不同，这时为了能更好的分辨出哪个动作片段更好，就需要引入过去的行为。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-03-26-16-13-26.png\"></th>\n<th><img src=\"/article_img/2023-03-26-16-13-32.png\"></th>\n</tr>\n</thead>\n</table>\n<p>我们将计算的这些位置和朝向信息的Cost相加就是最终的Cost</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-03-26-16-15-31.png\"></th>\n<th><img src=\"/article_img/2023-03-26-16-15-40.png\"></th>\n</tr>\n</thead>\n</table>\n<h2 id=\"Motion-Matching的优化问题\"><a href=\"#Motion-Matching的优化问题\" class=\"headerlink\" title=\"Motion Matching的优化问题\"></a>Motion Matching的优化问题</h2><ol>\n<li>提前计算特征</li>\n<li>惯性化过渡</li>\n<li>镜像数据表</li>\n<li>LOD</li>\n<li>KD-Tree</li>\n<li>无需每帧都去寻找最优动画<br>因为如果用户没有改变输入，角色一直向前走，只需要从当前动画帧继续向后播放即可。</li>\n</ol>\n<p>可以发现，由于Motion Matching算法本身就是一个搜索算法，不论如何加速，都需要将数据库中的数据放入内存，而Motion Matching实现动画过渡真实自然的基础就是很大的动作数据库，因此Motion Matching对内存的占用很大，这也是限制其在移动端大量应用的原因。</p>\n<h1 id=\"Learned-Motion-Matching\"><a href=\"#Learned-Motion-Matching\" class=\"headerlink\" title=\"Learned Motion Matching\"></a>Learned Motion Matching</h1><p><img src=\"/article_img/2023-03-26-18-32-27.png\"></p>\n<p>为了减小内存占用就要在Motion Matching实现过程中去除对动画数据库的依赖。Learned Motion Matching基于传统Motion Matching，用神经网络代替动画数据库，在实现了很好的动作效果的同时，大大降低了内存占用。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/LMM_M.gif\"></th>\n<th><img src=\"/article_img/LMM_L.gif\"></th>\n</tr>\n</thead>\n</table>\n<h2 id=\"传统Motion-Matching\"><a href=\"#传统Motion-Matching\" class=\"headerlink\" title=\"传统Motion Matching\"></a>传统Motion Matching</h2><p>首先我们先回顾一下Motion Matching：</p>\n<p><img src=\"/article_img/2023-03-26-18-08-33.png\"></p>\n<p>动画片段是由一系列的姿势（full poses）组成的，每个姿势有一个帧序号（frame index）指出这个姿势在动画数据库中的位置，向后播放动画意味着每帧增加frame index并且从动画数据库中找到对应的姿势，每隔几帧做一次利用特征序列（当前姿态信息和由输入估计的轨迹）和特征数据库（提前计算好的动作特征）做对比实现的动作匹配搜索（Motion Matching Search），得到的最匹配的动画帧替换当前帧，作为下一帧继续播放。</p>\n<h2 id=\"代替动作数据库\"><a href=\"#代替动作数据库\" class=\"headerlink\" title=\"代替动作数据库\"></a>代替动作数据库</h2><p><img src=\"/article_img/2023-03-26-18-26-36.png\"></p>\n<p>首先尝试去除对每帧进行的访问动作数据库的依赖，将直接去动作数据库中寻找动作替换成去特征数据库中寻找特征，找到的特征作为一个叫做Decompressor（可以理解为将动作特征解压成完整的动作）的神经网络的输入，由这个神经网络得到完整的姿势（这里是可行的，作者Daniel Holden的另一些工作PFNN就是尝试生成动作）</p>\n<p><img src=\"/article_img/CompDecomp.gif\"></p>\n<p>图中灰色的是直接访问动作数据库生成的，橙色的是Decompressor生成的，可以看到动画效果几乎没有区别，但是仔细观察骨骼的手部，发现还是有差异，这是由于特征不足引起的，我们可以添加更多的特征，但是我们可以用另一个神经网络自动找到这些额外的特征：</p>\n<p><img src=\"/article_img/2023-03-26-18-48-25.png\"></p>\n<p>添加了这个网络之后，动作质量更高了。</p>\n<p><img src=\"/article_img/CompDecompWithExtraFeatures.gif\"></p>\n<p>当去掉了对动作数据库的依赖之后，内存减少了很多：<br><img src=\"/article_img/2023-03-26-18-50-00.png\"></p>\n<p>经过以上优化之后，整个过程如下图，但这时这两个特征数据库实际上还是随动作数据库的增大而增大，如果我们的动作数据库足够大，这两个特征数据库也会占用很大的内存。</p>\n<p><img src=\"/article_img/2023-03-26-18-56-23.png\"></p>\n<p>下一步尝试在每一帧摆脱对特征数据库（Combined Features Database）的依赖。</p>\n<h2 id=\"代替特征数据库\"><a href=\"#代替特征数据库\" class=\"headerlink\" title=\"代替特征数据库\"></a>代替特征数据库</h2><p>首先代替每一帧中的Feature Lookup，如果可以将每一帧的输入换成特征数据（当前动作的特征），可以训练一个神经网络叫做Stepper输出下一帧的动作特征，由于我们每隔几帧就会进行Motion Matching Search，因此这个Stepper网络只需要预测出之后很短一段时间动作特征的变化。此时整个逻辑如下：</p>\n<p><img src=\"/article_img/2023-03-26-19-14-54.png\"><br><img src=\"/article_img/2023-03-26-19-14-59.png\"></p>\n<p>最后我们再训练一个神经网络Projector，用来直接预测与当前输入特征最匹配的特征：</p>\n<p><img src=\"/article_img/2023-03-26-19-17-06.png\"></p>\n<p>最终的整个Learned Motion Matching过程如下：<br><img src=\"/article_img/2023-03-26-19-17-26.png\"></p>\n<p>现在的内存比较：<br><img src=\"/article_img/2023-03-26-19-18-48.png\"><br><img src=\"/article_img/2023-03-26-19-22-16.png\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://archive.org/details/GDC2016Clavet/mode/2up\">GDC2016-Motion Matching</a><br><a href=\"https://montreal.ubisoft.com/en/introducing-learned-motion-matching/\">introducing-learned-motion-matching</a> 中文翻译：<a href=\"https://zhuanlan.zhihu.com/p/611573006\">Motion Matching的发展回顾</a><br><a href=\"https://zhuanlan.zhihu.com/p/378189446\">简单聊聊Motion Matching</a><br><a href=\"https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20\">Games105-计算机角色动画-06</a></p>\n","site":{"data":{}},"wordcount":3431,"excerpt":"<p>MotionMactching基础</p>","more":"<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/mm_1.gif\"></th>\n<th><img src=\"/article_img/LMM_M.gif\"></th>\n<th><img src=\"/article_img/LMM_L.gif\"></th>\n</tr>\n</thead>\n</table>\n<h1 id=\"Motion-Matching简介\"><a href=\"#Motion-Matching简介\" class=\"headerlink\" title=\"Motion Matching简介\"></a>Motion Matching简介</h1><p>Motion Matching是由育碧在GDC2016上提出的一项技术，可以使角色动作更加流畅和真实。与其他方法相比，它不需要在动作图中构造动画片段的结构，不需要仔细地切分或同步它们，也不需要在状态之间显式地创建新的转换。现如今已经被广泛应用在3A游戏中，如《荣耀战魂》，《刺客信条：奥德赛》以及最近的《黑神话：悟空》团队也表明他们也会使用Motion Matching技术。</p>\n<h1 id=\"为什么要用Motion-Matching\"><a href=\"#为什么要用Motion-Matching\" class=\"headerlink\" title=\"为什么要用Motion Matching\"></a>为什么要用Motion Matching</h1><p>如果把游戏的动画系统想象成一个黑盒，我们希望用户输入指令，动画系统这个黑盒输出相应的动画。<br>动画状态机就是目前动画系统这个黑盒最常用的实现方式。<br><img src=\"/article_img/2023-03-26-13-35-34.png\"></p>\n<p>动画状态机需要设置不同的状态（例如走路，跑步），这些不同的状态分别对应不同的动画片段（Animation Clip），除了这些状态外还需要设置状态之间的切换条件，当满足这个条件时进行状态的切换也就是切换播放的动画片段。</p>\n<p>动画状态机虽然很直观，但是其也有很多问题：</p>\n<ol>\n<li>复杂度高：动画状态机需要设计和编写，对于复杂的游戏角色，需要设计更多的状态和转换，使得状态机的复杂度变得很高，需要耗费更多的时间和精力。<br><img src=\"/article_img/2023-03-26-13-34-47.png\"></li>\n<li>难以处理动画过渡：动画状态机中的动画过渡需要手动设置，需要设计人员具有一定的动画技能和经验，否则可能会导致角色动画的不自然和不流畅。<br>**Is there a way to deal with loops and transitions in a uniform way?**——<a href=\"https://archive.org/details/GDC2016Clavet/page/n23/mode/2up\">Simon Clavet - “Motion Matching and The Road to Next-Gen Animation”</a></li>\n<li>难以适应变化：如果游戏需要进行修改或扩展，动画状态机可能需要进行重构或重写，这需要耗费更多的时间和精力。</li>\n<li>有一些动作难以写入状态机<br><img src=\"/article_img/2023-03-26-15-28-33.png\"></li>\n</ol>\n<p>为了解决这些问题，育碧提出了Motion Matching。</p>\n<h1 id=\"Motion-Matching的发展史\"><a href=\"#Motion-Matching的发展史\" class=\"headerlink\" title=\"Motion Matching的发展史\"></a>Motion Matching的发展史</h1><h2 id=\"Motion-Graphs\"><a href=\"#Motion-Graphs\" class=\"headerlink\" title=\"Motion Graphs\"></a>Motion Graphs</h2><p><img src=\"/article_img/2023-03-26-14-43-26.png\"></p>\n<p>Motion Graphs是2002年的工作，他主要是对动画片段中的每一帧进行对比，得到最相似的两帧（可以是速度，位置，pose等等），就设置这两帧为可过渡点。</p>\n<p><img src=\"/article_img/2023-03-26-15-03-35.png\"></p>\n<p>但是这篇工作中的过渡点是预先设定好的，导致动作反馈的及时性比较差，但是找到相似的动画作为下一帧动画的这个思想留给了后人。</p>\n<h2 id=\"Motion-Fields\"><a href=\"#Motion-Fields\" class=\"headerlink\" title=\"Motion Fields\"></a>Motion Fields</h2><p><img src=\"/article_img/2023-03-26-14-42-38.png\"></p>\n<p>这个技术也是一个划时代的技术，其实现效果已经很接近motion matching了，但是其实现方式过于复杂。</p>\n<p><img src=\"/article_img/2023-03-26-15-17-25.png\"></p>\n<p>具体就不讲了，可以参考<a href=\"https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20\">games105-lecture06</a>，这篇工作虽然实现方式很复杂，但是其提供了一个重要的思想：我们可以转换到任何一个我们想要的动画帧。</p>\n<p>motion matching就是在motion fields的基础上进行简化得来的。</p>\n<h1 id=\"Motion-Matching的实现\"><a href=\"#Motion-Matching的实现\" class=\"headerlink\" title=\"Motion Matching的实现\"></a>Motion Matching的实现</h1><p><img src=\"/article_img/2023-03-26-15-19-55.png\"></p>\n<p>可以看出Motion Matching中最重要的就是<strong>如何找到动画数据库中满足用户输入的条件下与当前帧最相近的动画数据。</strong> 用其创始人Simon的话说，这是一个十分暴力的动画搜索方法。</p>\n<p><img src=\"/article_img/2023-03-26-15-36-18.png\"></p>\n<h2 id=\"动画数据库（实现Motion-Matching的第一步）\"><a href=\"#动画数据库（实现Motion-Matching的第一步）\" class=\"headerlink\" title=\"动画数据库（实现Motion Matching的第一步）\"></a>动画数据库（实现Motion Matching的第一步）</h2><p><img src=\"/article_img/2023-03-26-15-38-16.png\"></p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-03-26-15-38-26.png\"></th>\n<th><img src=\"/article_img/2023-03-26-15-38-35.png\"></th>\n<th><img src=\"/article_img/2023-03-26-15-38-40.png\"></th>\n</tr>\n</thead>\n</table>\n<p>Motion Matching使用的动画数据大多来自动作捕捉，为了尽量高效的得到足够多的动作数据，育碧研究人员提出了一个概念叫Dance Card，动捕演员只需要按照Dance Card上的路径进行完成指定动作即可。</p>\n<h2 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h2><p><img src=\"/article_img/2023-03-26-15-42-58.png\"><br><img src=\"/article_img/2023-03-26-15-43-07.png\"><br><img src=\"/article_img/2023-03-26-15-48-40.png\"></p>\n<p>这就是育碧在GDC上给出的代码实现，也是Motion Matching的思路，十分简洁明了。可以看出关键点就是我们上文提出的如何选择下一个要过渡的动画帧，即<strong>ComputeCost</strong>这个函数。</p>\n<p>源码把Cost分为了两部分（situation和trajectory）,我们把计算Cost更直观的分为三部分：</p>\n<ol>\n<li>姿态的Cost，表示候选动画帧姿态和当前姿态的匹配程度；</li>\n<li>速度的Cost，表示候选动画帧的速度，加速度，角速度等信息与当前动画帧的匹配程度；</li>\n<li>轨迹的Cost，表示候选动画帧轨迹和当前用户输入轨迹的匹配程度；</li>\n</ol>\n<p>当然各个Cost要加权平均得到最终的Cost！</p>\n<h3 id=\"姿态Cost\"><a href=\"#姿态Cost\" class=\"headerlink\" title=\"姿态Cost\"></a>姿态Cost</h3><p>角色动画数据本质就是定义了每个关节的旋转和位置，以及一些运动速度等信息。</p>\n<p>在姿势匹配阶段，我们不需要匹配每一个关节的旋转和位置，只需要选取几个重要的关节即可，因为这些关节已经可以很好的代表一个姿势了，一般是左右脚和尾椎骨，也可以根据需要添加，如荣耀战魂中还添加了武器的骨骼。</p>\n<p><img src=\"/article_img/2023-03-26-16-07-46.png\"><br><img src=\"/article_img/2023-03-26-16-08-09.png\"></p>\n<h3 id=\"速度Cost\"><a href=\"#速度Cost\" class=\"headerlink\" title=\"速度Cost\"></a>速度Cost</h3><p>和姿态Cost计算基本一样，直接对比动画数据即可。</p>\n<h3 id=\"轨迹Cost\"><a href=\"#轨迹Cost\" class=\"headerlink\" title=\"轨迹Cost\"></a>轨迹Cost</h3><p><img src=\"/article_img/2023-03-26-16-10-17.png\"></p>\n<p>轨迹计算部分，育碧的源码考虑了未来几帧和过去几帧的位置和朝向，考虑未来的轨迹很好理解，为什么还要考虑过去的轨迹呢？如下图，有可能两个动作片段未来的行为一样，但是其过去不同，这时为了能更好的分辨出哪个动作片段更好，就需要引入过去的行为。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-03-26-16-13-26.png\"></th>\n<th><img src=\"/article_img/2023-03-26-16-13-32.png\"></th>\n</tr>\n</thead>\n</table>\n<p>我们将计算的这些位置和朝向信息的Cost相加就是最终的Cost</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-03-26-16-15-31.png\"></th>\n<th><img src=\"/article_img/2023-03-26-16-15-40.png\"></th>\n</tr>\n</thead>\n</table>\n<h2 id=\"Motion-Matching的优化问题\"><a href=\"#Motion-Matching的优化问题\" class=\"headerlink\" title=\"Motion Matching的优化问题\"></a>Motion Matching的优化问题</h2><ol>\n<li>提前计算特征</li>\n<li>惯性化过渡</li>\n<li>镜像数据表</li>\n<li>LOD</li>\n<li>KD-Tree</li>\n<li>无需每帧都去寻找最优动画<br>因为如果用户没有改变输入，角色一直向前走，只需要从当前动画帧继续向后播放即可。</li>\n</ol>\n<p>可以发现，由于Motion Matching算法本身就是一个搜索算法，不论如何加速，都需要将数据库中的数据放入内存，而Motion Matching实现动画过渡真实自然的基础就是很大的动作数据库，因此Motion Matching对内存的占用很大，这也是限制其在移动端大量应用的原因。</p>\n<h1 id=\"Learned-Motion-Matching\"><a href=\"#Learned-Motion-Matching\" class=\"headerlink\" title=\"Learned Motion Matching\"></a>Learned Motion Matching</h1><p><img src=\"/article_img/2023-03-26-18-32-27.png\"></p>\n<p>为了减小内存占用就要在Motion Matching实现过程中去除对动画数据库的依赖。Learned Motion Matching基于传统Motion Matching，用神经网络代替动画数据库，在实现了很好的动作效果的同时，大大降低了内存占用。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/LMM_M.gif\"></th>\n<th><img src=\"/article_img/LMM_L.gif\"></th>\n</tr>\n</thead>\n</table>\n<h2 id=\"传统Motion-Matching\"><a href=\"#传统Motion-Matching\" class=\"headerlink\" title=\"传统Motion Matching\"></a>传统Motion Matching</h2><p>首先我们先回顾一下Motion Matching：</p>\n<p><img src=\"/article_img/2023-03-26-18-08-33.png\"></p>\n<p>动画片段是由一系列的姿势（full poses）组成的，每个姿势有一个帧序号（frame index）指出这个姿势在动画数据库中的位置，向后播放动画意味着每帧增加frame index并且从动画数据库中找到对应的姿势，每隔几帧做一次利用特征序列（当前姿态信息和由输入估计的轨迹）和特征数据库（提前计算好的动作特征）做对比实现的动作匹配搜索（Motion Matching Search），得到的最匹配的动画帧替换当前帧，作为下一帧继续播放。</p>\n<h2 id=\"代替动作数据库\"><a href=\"#代替动作数据库\" class=\"headerlink\" title=\"代替动作数据库\"></a>代替动作数据库</h2><p><img src=\"/article_img/2023-03-26-18-26-36.png\"></p>\n<p>首先尝试去除对每帧进行的访问动作数据库的依赖，将直接去动作数据库中寻找动作替换成去特征数据库中寻找特征，找到的特征作为一个叫做Decompressor（可以理解为将动作特征解压成完整的动作）的神经网络的输入，由这个神经网络得到完整的姿势（这里是可行的，作者Daniel Holden的另一些工作PFNN就是尝试生成动作）</p>\n<p><img src=\"/article_img/CompDecomp.gif\"></p>\n<p>图中灰色的是直接访问动作数据库生成的，橙色的是Decompressor生成的，可以看到动画效果几乎没有区别，但是仔细观察骨骼的手部，发现还是有差异，这是由于特征不足引起的，我们可以添加更多的特征，但是我们可以用另一个神经网络自动找到这些额外的特征：</p>\n<p><img src=\"/article_img/2023-03-26-18-48-25.png\"></p>\n<p>添加了这个网络之后，动作质量更高了。</p>\n<p><img src=\"/article_img/CompDecompWithExtraFeatures.gif\"></p>\n<p>当去掉了对动作数据库的依赖之后，内存减少了很多：<br><img src=\"/article_img/2023-03-26-18-50-00.png\"></p>\n<p>经过以上优化之后，整个过程如下图，但这时这两个特征数据库实际上还是随动作数据库的增大而增大，如果我们的动作数据库足够大，这两个特征数据库也会占用很大的内存。</p>\n<p><img src=\"/article_img/2023-03-26-18-56-23.png\"></p>\n<p>下一步尝试在每一帧摆脱对特征数据库（Combined Features Database）的依赖。</p>\n<h2 id=\"代替特征数据库\"><a href=\"#代替特征数据库\" class=\"headerlink\" title=\"代替特征数据库\"></a>代替特征数据库</h2><p>首先代替每一帧中的Feature Lookup，如果可以将每一帧的输入换成特征数据（当前动作的特征），可以训练一个神经网络叫做Stepper输出下一帧的动作特征，由于我们每隔几帧就会进行Motion Matching Search，因此这个Stepper网络只需要预测出之后很短一段时间动作特征的变化。此时整个逻辑如下：</p>\n<p><img src=\"/article_img/2023-03-26-19-14-54.png\"><br><img src=\"/article_img/2023-03-26-19-14-59.png\"></p>\n<p>最后我们再训练一个神经网络Projector，用来直接预测与当前输入特征最匹配的特征：</p>\n<p><img src=\"/article_img/2023-03-26-19-17-06.png\"></p>\n<p>最终的整个Learned Motion Matching过程如下：<br><img src=\"/article_img/2023-03-26-19-17-26.png\"></p>\n<p>现在的内存比较：<br><img src=\"/article_img/2023-03-26-19-18-48.png\"><br><img src=\"/article_img/2023-03-26-19-22-16.png\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://archive.org/details/GDC2016Clavet/mode/2up\">GDC2016-Motion Matching</a><br><a href=\"https://montreal.ubisoft.com/en/introducing-learned-motion-matching/\">introducing-learned-motion-matching</a> 中文翻译：<a href=\"https://zhuanlan.zhihu.com/p/611573006\">Motion Matching的发展回顾</a><br><a href=\"https://zhuanlan.zhihu.com/p/378189446\">简单聊聊Motion Matching</a><br><a href=\"https://www.bilibili.com/video/BV1GG4y1p7fF?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20\">Games105-计算机角色动画-06</a></p>"},{"title":"Ray tracing in one weekend笔记","date":"2022-10-08T16:00:00.000Z","index_img":"/img/bg/RayTracing_weekend.jpg","_content":"\nRay tracing in one weekend笔记\n<!-- more -->\n\n# 参考资料\n\n[Ray Tracing in one weekend](https://raytracing.github.io/books/RayTracingInOneWeekend.html)\n\n[中文翻译](https://zhuanlan.zhihu.com/p/128582904)\n\n# 输出图像\n\n使用ppm格式\n\n![](/article_img/2022-09-26-14-26-50.png)\n\n显示ppm格式的图像使用：[OpenSeeIt](https://link.zhihu.com/?target=http%3A//openseeit.sourceforge.net/)，生成图像需要在cmd切换到应用程序目录并执行命令：\n```\nRaytracing_in_one_weekend.exe > image.ppm\n```\n\n![](/article_img/2022-09-26-14-28-48.png)\n\n# vec3类\n\n这里就复习一下c++语法吧\n\n## const关键字小结：\n\n1. const修饰普通类型的变量，表示是一个常量，不能重新赋值\n   ```c++\n   const a = 10;\n   b = a; //正确\n   a = 7; //错误\n   ```\n2. const 修饰指针变量，\"左定值，右定向，const修饰不变量\"，就是修饰谁谁就不能被改变\n   ```c++\n   // const修饰指针\n   int a = 8;\n   int * const p = &a;\n   *p = 9; //正确\n   p = &b; //错误\n\n   // const修饰指针内容\n   const int *p = 9;\n\n   // const修饰指针和指针指向的内容, 指针p和*p都不能改变\n   int a = 8;\n   const int * const p = &a;\n   ```\n3. const参数传递和函数返回值\n   ```c++\n   // const修饰传递的值\n   void fun(const int a){\n      cout<<a;\n      // ++a;  是错误的，a 不能被改变\n   }\n   // const修饰传递的指针,防止指针被意外篡改\n   void fun(int * const p){\n      ...\n   }\n   ```\n   自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。\n\n   ```c++\n   void fun(const my_class& a){\n      cout<<a.class_fun();\n   }\n   ```\n4. const修饰类成员函数\n\n   const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。\n\n## 构造函数和运算符重载\n\n```c++\n   //构造函数\n   vec3(double x,double y,double z):e{x,y,z}{}\n   //运算符重载\n   vec3 operator*=(int t){\n      ...\n   }\n   inline vec3 operator*(const vec3& u, const vec3& v) {\n      return vec3(u.e[0] * v.e[0], u.e[1] * v.e[1], u.e[2] * v.e[2]);\n   }\n```\n\n## inline关键字\n\n在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。\n\n栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。\n\n在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。\n\n**inline就是把函数内容替换到函数调用处。**\n\n**注意：inline函数里不能有while和switch，不能是递归函数**\n\n## C++中的别名定义\n\n```c++\n// 使用别名来区分点和颜色，只是用来区分，不会有警告\nusing point3 = vec3;\nusing color = vec3;\n```\n\n# 光线，简单摄像机和背景\n\n![](/article_img/2022-09-26-21-08-46.png)\n\n```c++\ncolor ray_color(const ray& r) {\n\t// 线性插值颜色\n\tvec3 unit_direction = unit_vector(r.direction());\n\tauto t = 0.5 * (unit_direction.y() + 1.0);\n   // blendedValue=(1−t)⋅startValue+t⋅endValue\n\treturn (1.0 - t) * color(1.0, 1.0, 1.0) + t * color(0.5, 0.7, 1.0);\n}\n```\n\n![](/article_img/2022-09-26-21-01-37.png)\n\n# 添加球面\n\n绘制一个球心在（0，0，-1）处，半径为0.5的球。\n\n主要在于判断球面和光线是否相交，Games101中提到的光线与隐式表面的求交问题，将光线方程带入球面方程，求t。\n\n![](/article_img/2022-09-27-11-50-26.png)\n\n```c++\nbool hit_sphere(const point3& center, double radius, const ray& r) {\n\n\t//  t2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r2=0\n\n\tvec3 oc = r.origin() - center;\n\tauto a = dot(r.direction(), r.direction());\n\tauto b = 2 * dot(r.direction(), oc);\n\tauto c = dot(oc, oc) - radius * radius;\n\tauto discriminant = b * b - 4 * a * c;\n\treturn (discriminant > 0);\n}\n```\n\n![](/article_img/2022-09-27-11-50-57.png)\n\n**存在的问题**：若将球心放置在（0，0，1）渲染的结果和此时一样。\n\n# 法线和多个物体\n\n## 法线可视化\n\n```c++\n\tif (t > 0.0) { // 如果与球面相交直接return颜色\n\t\t// 求得法线\n\t\tvec3 N = unit_vector(r.at(t) - vec3(0, 0, -1));\n      // 将值映射到（0，1），尽管已经是单位向量，但是由于法线坐标会有负值，仍需要做映射\n\t\treturn 0.5 * color(N.x() + 1, N.y() + 1, N.z() + 1); \n\t}\n```\n\n![](/article_img/2022-09-27-13-10-42.png)\n\n## hit_record结构体\n\n记录光线与物体交点的信息：交点坐标，交点处法线，光线方程中的t值\n\n以及判断光线是从哪个方向射向平面，从而**设定法线方向始终与光线入射方向相反**。\n\n```c++\nstruct hit_record { // 记录了与物体交点的信息：交点坐标，交点处法线，光线方程中的t值\n\tpoint3 p;\n\tvec3 normal;\n\tdouble t;\n\n\t// 判断光线是从哪个方向射向平面\n\tbool front_face;\n\n\tinline void set_face_normal(const ray& r, const vec3& outward_normal) {\n\t\t// 保证法线始终与光线入射方向相反\n\t\tfront_face = dot(r.direction(), outward_normal) < 0;\n\t\t// 设置normal\n\t\tnormal = front_face ? outward_normal : -outward_normal;\n\t}\n};\n```\n\n## hittable类\n\n定义了一个虚函数，本书中只解决了与球面判断相交的问题，就是将线段代入球面方程看是否有解。\n\n```c++\nclass hittable {\npublic:\n   virtual bool hit(const ray& r, double t_min, double t_max, hit_record& rec)const = 0;\n};\n```\n## sphere类\n\nsphere类继承自hittable类，实现了hit函数，有两个变量：球心坐标和半径\n\n## hittable_list类（Some New C++ Features）\n\n\n## 渲染结果\n\n在main函数中创建hittable_list对象world，表示场景信息，其中有一个大球一个小球（渲染结果如下），地面（大球）是绿色是因为这里的法线都是向上，观察小球的顶部也是绿色。\n\n![](/article_img/2022-09-27-19-39-22.png)\n\n# 抗锯齿\n\n加大采样率，在每个像素中随机采样一百次，将结果平均作为该像素的颜色。\n\n![](/article_img/2022-09-28-16-15-11.png)\n\n![](/article_img/2022-09-29-15-43-18.png)\n将相机部分的代码封装到了camera类。\n\n# 漫反射材质\n\n![](/article_img/2022-09-29-15-45-06.png)\n\n![](/article_img/2022-09-29-15-45-22.png)\n\n![](/article_img/2022-09-29-15-45-33.png)\n\n方法1： 单位圆中随机  \n方法2： 在单位圆上随机生成  \n方法3： 直接生成反射方向  \n\n方法1比方法2要更加真实，因为前者能让更多光线向相机方向反射，而后者更多光线会靠近法线方法，导致反射次数增加（阴影很黑），使用方法2明显渲染速度变快很多。\n\n```c++\ncolor ray_color(const ray& r, const hittable& world, int depth) {\n\thit_record rec;\n\n\tif (depth <= 0)\n\t\treturn color(0, 0, 0);\n\n\tif (world.hit(r,0.001,infinity,rec)){ // 如果与球面相交直接return颜色\n\t\t// 求得法线\n\t\t//return 0.5 * (rec.normal + color(1,1,1));\n\n\t\t/* 漫反射\n      方法1：单位圆中随机\n\t\tpoint3 target = rec.p + rec.normal + random_in_unit_vector(); \n      方法3：直接生成反射方向\n\t\tpoint3 target = rec.p + random_in_hemisphere(); \n      方法2：在单位圆上随机生成\n      */\n\t\tpoint3 target = rec.p + rec.normal + random_unit_vector(); \n\t\treturn 0.5 * ray_color(ray(rec.p, target - rec.p), world, depth - 1); \n\t}\n\t// 线性插值颜色\n\tvec3 unit_direction = unit_vector(r.direction());\n\tauto t = 0.5 * (unit_direction.y() + 1.0);\n\treturn (1.0 - t) * color(1.0, 1.0, 1.0) + t * color(0.5, 0.7, 1.0);\n}\n```\n\ncolor(1,1,1)表示白色，color(0,0,0)表示黑色，这里的0.5*ray_color(...)相当于每次光线衰减50%，就是变暗一半。\n\n![](/article_img/2022-09-29-15-52-40.png)\n\n# 金属材质\n\n## 材质类\n\n抽象类： material类  \n继承类： metal类，lambertian类\n\n![](/article_img/2022-09-30-14-48-32.png)\n\n## 左侧球呈现镜面效果的原因：  \n光线从相机射出，与球面相交，调用交点材质的scatter函数计算反射光线以及得到衰减率，**进入递归**，发现反射光线不与物体相交，即进行线性插值颜色，**递归结束**，得到的线性插值颜色与衰减率相乘（**这就是为什么左侧球与背景颜色相似但是稍暗一些的原因**），得到最终的颜色。\n\n## 右侧球带有颜色的原因：  \n就是因为其衰减率的RGB三个值不相同，导致有的颜色衰减的更多，就看起来有了某种颜色，而不是简单的变暗。\n\n\n## 关键代码\n\n```c++\ncolor ray_color(const ray& r, const hittable& world, int depth) {\n\thit_record rec;\n\n\tif (depth <= 0)\n\t\treturn color(0, 0, 0);\n\n\tif (world.hit(r,0.001,infinity,rec)){ // 与球面相交\n\t\tray scattered;\n\t\tcolor attenuation;   // 衰减率\n\n      // 调用材质的scatter函数，得到该反射点的材质的衰减率和反射光线。\n\t\tif (rec.mat_ptr->scatter(r, rec, attenuation, scattered))\n\t\t\treturn attenuation * ray_color(scattered, world, depth - 1);\n\t\treturn color(0, 0, 0);\n\t}\n\t// 线性插值颜色\n\tvec3 unit_direction = unit_vector(r.direction());\n\tauto t = 0.5 * (unit_direction.y() + 1.0);\n\treturn (1.0 - t) * color(1.0, 1.0, 1.0) + t * color(0.5, 0.7, 1.0);\n}\n```\n\n# 模糊反射（磨砂镜面）\n\n![](/article_img/2022-10-08-14-55-02.png)\n\n反射光线加一个随机的向量（在单位圆中生成）\n\n在金属材质类（metal）中加一个属性：磨砂系数（fuzz）\n```c++\nscattered = ray(rec.p, reflected + fuzz * random_in_unit_sphere());\n```\n![](/article_img/2022-10-08-14-54-52.png)\n\n# 电解质（透明物体）\n\n## 折射\n\n![](/article_img/2022-10-09-14-06-32.png)\n\n一次折射会让场景颠倒\n\n## Schlick近似\n\n现实世界中的玻璃, 发生折射的概率会随着入射角而改变——从一个很狭窄的角度去看玻璃窗, 它会变成一面镜子。\n\n## 中空球\n\n将球的半径设置为负值，几何形状不会改变，但是法相全部反转到内部。\n\n```c++\nworld.add(make_shared<sphere>(point3(-1.0,    0.0, -1.0),  -0.4, material_left));\n```\n\n![](/article_img/2022-10-09-14-25-53.png)\n\n# 相机\n\n## 相机可视角度（Field of View）\n\n这里的可视角度是竖直方向上的可视角度，实际水平也可以。有了 FOV 再根据宽高比就能求出视图的宽高值。\n\n![](/article_img/2022-10-09-14-28-04.png)\n\n## 相机的定位定向\n\n![](/article_img/2022-10-09-14-51-30.png)\n\n![](/article_img/2022-10-09-14-51-38.png)\n\n```c++\nauto w = unit_vector(lookfrom - lookat);\nauto u = unit_vector(cross(vup, w));\nauto v = cross(w, u);\n```\n\n这里就是要新建一个坐标系，经过以上代码的运算，得到一个新的坐标系：相机看向-w方向，相机的向上方向是v，还有一个水平的方向u。\n\n改变camera类，可以设定相机的位置和相机看向的方向。\n\n```c++\ncamera cam(point3(-2, 2, 1), point3(0, 0, -1), vec3(0, 1, 0), 90, aspect_ratio);\n```\n\n![](/article_img/2022-10-09-14-52-21.png)\n\n# 景深\n\n![](/article_img/2022-10-09-15-26-37.png)\n\n# 常看常新\n\n## 成像平面\n\n之前在我的印象中光线追踪模型应该是下图这样的，摄像机和成像平面在整个场景之前，但其实成像平面在哪并没有什么关系，本例的成像平面就与物体在同一深度。\n\n![](/article_img/2022-10-29-18-15-59.png)\n\n仔细一想，成像平面的意义在于确定从相机发出的路径，所以如下图所示，只要成像平面的面积与平面到相机的距离成比例变化，其实发出的路径都是一样的，都在图示的锥体中。\n\n![](/article_img/2022-10-29-18-20-06.png)\n\n而FOV实际上也是在改变这个锥体，FOV越大，成像平面也就越大（平面到相机的垂直相同的情况下）。\n\n关于FOV还有一个有趣的观察，在这个光线追踪例子中，FOV越小，最终得到的图像和真正将相机离物体很近拍出的图像一模一样。而在现实中（如下图）我们可以轻易的分辨出是从很近的地方拍照还是通过变焦从很远的地方拍照（会明显模糊），而在本例子中并不会产生模糊。原因在于现实中的相机焦距不是任意可调的，理论上来说，拍摄越远的物体，相机内部的成像平面也应该离透镜越远，而真实的相机大小是有限的，因此会产生模糊，在本文中的虚拟的透镜焦距确实是可以任意调整的，因此并不会模糊，就像在很近的距离拍摄的一样，物体又大又清晰。\n\n![](/article_img/2022-10-29-13-44-32.png)\n","source":"_posts/Ray tracing in one weekend.md","raw":"---\ntitle: Ray tracing in one weekend笔记\ndate: 2022-10-09\nindex_img: \"/img/bg/RayTracing_weekend.jpg\"\ntags: [Ray Tracing]\ncategories: \n   -[Ray Tracing 笔记]\n---\n\nRay tracing in one weekend笔记\n<!-- more -->\n\n# 参考资料\n\n[Ray Tracing in one weekend](https://raytracing.github.io/books/RayTracingInOneWeekend.html)\n\n[中文翻译](https://zhuanlan.zhihu.com/p/128582904)\n\n# 输出图像\n\n使用ppm格式\n\n![](/article_img/2022-09-26-14-26-50.png)\n\n显示ppm格式的图像使用：[OpenSeeIt](https://link.zhihu.com/?target=http%3A//openseeit.sourceforge.net/)，生成图像需要在cmd切换到应用程序目录并执行命令：\n```\nRaytracing_in_one_weekend.exe > image.ppm\n```\n\n![](/article_img/2022-09-26-14-28-48.png)\n\n# vec3类\n\n这里就复习一下c++语法吧\n\n## const关键字小结：\n\n1. const修饰普通类型的变量，表示是一个常量，不能重新赋值\n   ```c++\n   const a = 10;\n   b = a; //正确\n   a = 7; //错误\n   ```\n2. const 修饰指针变量，\"左定值，右定向，const修饰不变量\"，就是修饰谁谁就不能被改变\n   ```c++\n   // const修饰指针\n   int a = 8;\n   int * const p = &a;\n   *p = 9; //正确\n   p = &b; //错误\n\n   // const修饰指针内容\n   const int *p = 9;\n\n   // const修饰指针和指针指向的内容, 指针p和*p都不能改变\n   int a = 8;\n   const int * const p = &a;\n   ```\n3. const参数传递和函数返回值\n   ```c++\n   // const修饰传递的值\n   void fun(const int a){\n      cout<<a;\n      // ++a;  是错误的，a 不能被改变\n   }\n   // const修饰传递的指针,防止指针被意外篡改\n   void fun(int * const p){\n      ...\n   }\n   ```\n   自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。\n\n   ```c++\n   void fun(const my_class& a){\n      cout<<a.class_fun();\n   }\n   ```\n4. const修饰类成员函数\n\n   const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。\n\n## 构造函数和运算符重载\n\n```c++\n   //构造函数\n   vec3(double x,double y,double z):e{x,y,z}{}\n   //运算符重载\n   vec3 operator*=(int t){\n      ...\n   }\n   inline vec3 operator*(const vec3& u, const vec3& v) {\n      return vec3(u.e[0] * v.e[0], u.e[1] * v.e[1], u.e[2] * v.e[2]);\n   }\n```\n\n## inline关键字\n\n在 c/c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。\n\n栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。\n\n在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。\n\n**inline就是把函数内容替换到函数调用处。**\n\n**注意：inline函数里不能有while和switch，不能是递归函数**\n\n## C++中的别名定义\n\n```c++\n// 使用别名来区分点和颜色，只是用来区分，不会有警告\nusing point3 = vec3;\nusing color = vec3;\n```\n\n# 光线，简单摄像机和背景\n\n![](/article_img/2022-09-26-21-08-46.png)\n\n```c++\ncolor ray_color(const ray& r) {\n\t// 线性插值颜色\n\tvec3 unit_direction = unit_vector(r.direction());\n\tauto t = 0.5 * (unit_direction.y() + 1.0);\n   // blendedValue=(1−t)⋅startValue+t⋅endValue\n\treturn (1.0 - t) * color(1.0, 1.0, 1.0) + t * color(0.5, 0.7, 1.0);\n}\n```\n\n![](/article_img/2022-09-26-21-01-37.png)\n\n# 添加球面\n\n绘制一个球心在（0，0，-1）处，半径为0.5的球。\n\n主要在于判断球面和光线是否相交，Games101中提到的光线与隐式表面的求交问题，将光线方程带入球面方程，求t。\n\n![](/article_img/2022-09-27-11-50-26.png)\n\n```c++\nbool hit_sphere(const point3& center, double radius, const ray& r) {\n\n\t//  t2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r2=0\n\n\tvec3 oc = r.origin() - center;\n\tauto a = dot(r.direction(), r.direction());\n\tauto b = 2 * dot(r.direction(), oc);\n\tauto c = dot(oc, oc) - radius * radius;\n\tauto discriminant = b * b - 4 * a * c;\n\treturn (discriminant > 0);\n}\n```\n\n![](/article_img/2022-09-27-11-50-57.png)\n\n**存在的问题**：若将球心放置在（0，0，1）渲染的结果和此时一样。\n\n# 法线和多个物体\n\n## 法线可视化\n\n```c++\n\tif (t > 0.0) { // 如果与球面相交直接return颜色\n\t\t// 求得法线\n\t\tvec3 N = unit_vector(r.at(t) - vec3(0, 0, -1));\n      // 将值映射到（0，1），尽管已经是单位向量，但是由于法线坐标会有负值，仍需要做映射\n\t\treturn 0.5 * color(N.x() + 1, N.y() + 1, N.z() + 1); \n\t}\n```\n\n![](/article_img/2022-09-27-13-10-42.png)\n\n## hit_record结构体\n\n记录光线与物体交点的信息：交点坐标，交点处法线，光线方程中的t值\n\n以及判断光线是从哪个方向射向平面，从而**设定法线方向始终与光线入射方向相反**。\n\n```c++\nstruct hit_record { // 记录了与物体交点的信息：交点坐标，交点处法线，光线方程中的t值\n\tpoint3 p;\n\tvec3 normal;\n\tdouble t;\n\n\t// 判断光线是从哪个方向射向平面\n\tbool front_face;\n\n\tinline void set_face_normal(const ray& r, const vec3& outward_normal) {\n\t\t// 保证法线始终与光线入射方向相反\n\t\tfront_face = dot(r.direction(), outward_normal) < 0;\n\t\t// 设置normal\n\t\tnormal = front_face ? outward_normal : -outward_normal;\n\t}\n};\n```\n\n## hittable类\n\n定义了一个虚函数，本书中只解决了与球面判断相交的问题，就是将线段代入球面方程看是否有解。\n\n```c++\nclass hittable {\npublic:\n   virtual bool hit(const ray& r, double t_min, double t_max, hit_record& rec)const = 0;\n};\n```\n## sphere类\n\nsphere类继承自hittable类，实现了hit函数，有两个变量：球心坐标和半径\n\n## hittable_list类（Some New C++ Features）\n\n\n## 渲染结果\n\n在main函数中创建hittable_list对象world，表示场景信息，其中有一个大球一个小球（渲染结果如下），地面（大球）是绿色是因为这里的法线都是向上，观察小球的顶部也是绿色。\n\n![](/article_img/2022-09-27-19-39-22.png)\n\n# 抗锯齿\n\n加大采样率，在每个像素中随机采样一百次，将结果平均作为该像素的颜色。\n\n![](/article_img/2022-09-28-16-15-11.png)\n\n![](/article_img/2022-09-29-15-43-18.png)\n将相机部分的代码封装到了camera类。\n\n# 漫反射材质\n\n![](/article_img/2022-09-29-15-45-06.png)\n\n![](/article_img/2022-09-29-15-45-22.png)\n\n![](/article_img/2022-09-29-15-45-33.png)\n\n方法1： 单位圆中随机  \n方法2： 在单位圆上随机生成  \n方法3： 直接生成反射方向  \n\n方法1比方法2要更加真实，因为前者能让更多光线向相机方向反射，而后者更多光线会靠近法线方法，导致反射次数增加（阴影很黑），使用方法2明显渲染速度变快很多。\n\n```c++\ncolor ray_color(const ray& r, const hittable& world, int depth) {\n\thit_record rec;\n\n\tif (depth <= 0)\n\t\treturn color(0, 0, 0);\n\n\tif (world.hit(r,0.001,infinity,rec)){ // 如果与球面相交直接return颜色\n\t\t// 求得法线\n\t\t//return 0.5 * (rec.normal + color(1,1,1));\n\n\t\t/* 漫反射\n      方法1：单位圆中随机\n\t\tpoint3 target = rec.p + rec.normal + random_in_unit_vector(); \n      方法3：直接生成反射方向\n\t\tpoint3 target = rec.p + random_in_hemisphere(); \n      方法2：在单位圆上随机生成\n      */\n\t\tpoint3 target = rec.p + rec.normal + random_unit_vector(); \n\t\treturn 0.5 * ray_color(ray(rec.p, target - rec.p), world, depth - 1); \n\t}\n\t// 线性插值颜色\n\tvec3 unit_direction = unit_vector(r.direction());\n\tauto t = 0.5 * (unit_direction.y() + 1.0);\n\treturn (1.0 - t) * color(1.0, 1.0, 1.0) + t * color(0.5, 0.7, 1.0);\n}\n```\n\ncolor(1,1,1)表示白色，color(0,0,0)表示黑色，这里的0.5*ray_color(...)相当于每次光线衰减50%，就是变暗一半。\n\n![](/article_img/2022-09-29-15-52-40.png)\n\n# 金属材质\n\n## 材质类\n\n抽象类： material类  \n继承类： metal类，lambertian类\n\n![](/article_img/2022-09-30-14-48-32.png)\n\n## 左侧球呈现镜面效果的原因：  \n光线从相机射出，与球面相交，调用交点材质的scatter函数计算反射光线以及得到衰减率，**进入递归**，发现反射光线不与物体相交，即进行线性插值颜色，**递归结束**，得到的线性插值颜色与衰减率相乘（**这就是为什么左侧球与背景颜色相似但是稍暗一些的原因**），得到最终的颜色。\n\n## 右侧球带有颜色的原因：  \n就是因为其衰减率的RGB三个值不相同，导致有的颜色衰减的更多，就看起来有了某种颜色，而不是简单的变暗。\n\n\n## 关键代码\n\n```c++\ncolor ray_color(const ray& r, const hittable& world, int depth) {\n\thit_record rec;\n\n\tif (depth <= 0)\n\t\treturn color(0, 0, 0);\n\n\tif (world.hit(r,0.001,infinity,rec)){ // 与球面相交\n\t\tray scattered;\n\t\tcolor attenuation;   // 衰减率\n\n      // 调用材质的scatter函数，得到该反射点的材质的衰减率和反射光线。\n\t\tif (rec.mat_ptr->scatter(r, rec, attenuation, scattered))\n\t\t\treturn attenuation * ray_color(scattered, world, depth - 1);\n\t\treturn color(0, 0, 0);\n\t}\n\t// 线性插值颜色\n\tvec3 unit_direction = unit_vector(r.direction());\n\tauto t = 0.5 * (unit_direction.y() + 1.0);\n\treturn (1.0 - t) * color(1.0, 1.0, 1.0) + t * color(0.5, 0.7, 1.0);\n}\n```\n\n# 模糊反射（磨砂镜面）\n\n![](/article_img/2022-10-08-14-55-02.png)\n\n反射光线加一个随机的向量（在单位圆中生成）\n\n在金属材质类（metal）中加一个属性：磨砂系数（fuzz）\n```c++\nscattered = ray(rec.p, reflected + fuzz * random_in_unit_sphere());\n```\n![](/article_img/2022-10-08-14-54-52.png)\n\n# 电解质（透明物体）\n\n## 折射\n\n![](/article_img/2022-10-09-14-06-32.png)\n\n一次折射会让场景颠倒\n\n## Schlick近似\n\n现实世界中的玻璃, 发生折射的概率会随着入射角而改变——从一个很狭窄的角度去看玻璃窗, 它会变成一面镜子。\n\n## 中空球\n\n将球的半径设置为负值，几何形状不会改变，但是法相全部反转到内部。\n\n```c++\nworld.add(make_shared<sphere>(point3(-1.0,    0.0, -1.0),  -0.4, material_left));\n```\n\n![](/article_img/2022-10-09-14-25-53.png)\n\n# 相机\n\n## 相机可视角度（Field of View）\n\n这里的可视角度是竖直方向上的可视角度，实际水平也可以。有了 FOV 再根据宽高比就能求出视图的宽高值。\n\n![](/article_img/2022-10-09-14-28-04.png)\n\n## 相机的定位定向\n\n![](/article_img/2022-10-09-14-51-30.png)\n\n![](/article_img/2022-10-09-14-51-38.png)\n\n```c++\nauto w = unit_vector(lookfrom - lookat);\nauto u = unit_vector(cross(vup, w));\nauto v = cross(w, u);\n```\n\n这里就是要新建一个坐标系，经过以上代码的运算，得到一个新的坐标系：相机看向-w方向，相机的向上方向是v，还有一个水平的方向u。\n\n改变camera类，可以设定相机的位置和相机看向的方向。\n\n```c++\ncamera cam(point3(-2, 2, 1), point3(0, 0, -1), vec3(0, 1, 0), 90, aspect_ratio);\n```\n\n![](/article_img/2022-10-09-14-52-21.png)\n\n# 景深\n\n![](/article_img/2022-10-09-15-26-37.png)\n\n# 常看常新\n\n## 成像平面\n\n之前在我的印象中光线追踪模型应该是下图这样的，摄像机和成像平面在整个场景之前，但其实成像平面在哪并没有什么关系，本例的成像平面就与物体在同一深度。\n\n![](/article_img/2022-10-29-18-15-59.png)\n\n仔细一想，成像平面的意义在于确定从相机发出的路径，所以如下图所示，只要成像平面的面积与平面到相机的距离成比例变化，其实发出的路径都是一样的，都在图示的锥体中。\n\n![](/article_img/2022-10-29-18-20-06.png)\n\n而FOV实际上也是在改变这个锥体，FOV越大，成像平面也就越大（平面到相机的垂直相同的情况下）。\n\n关于FOV还有一个有趣的观察，在这个光线追踪例子中，FOV越小，最终得到的图像和真正将相机离物体很近拍出的图像一模一样。而在现实中（如下图）我们可以轻易的分辨出是从很近的地方拍照还是通过变焦从很远的地方拍照（会明显模糊），而在本例子中并不会产生模糊。原因在于现实中的相机焦距不是任意可调的，理论上来说，拍摄越远的物体，相机内部的成像平面也应该离透镜越远，而真实的相机大小是有限的，因此会产生模糊，在本文中的虚拟的透镜焦距确实是可以任意调整的，因此并不会模糊，就像在很近的距离拍摄的一样，物体又大又清晰。\n\n![](/article_img/2022-10-29-13-44-32.png)\n","slug":"Ray tracing in one weekend","published":1,"updated":"2022-10-29T10:43:18.972Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigm2001hw0je5n1349al","content":"<p>Ray tracing in one weekend笔记</p>\n<span id=\"more\"></span>\n\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://raytracing.github.io/books/RayTracingInOneWeekend.html\">Ray Tracing in one weekend</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/128582904\">中文翻译</a></p>\n<h1 id=\"输出图像\"><a href=\"#输出图像\" class=\"headerlink\" title=\"输出图像\"></a>输出图像</h1><p>使用ppm格式</p>\n<p><img src=\"/article_img/2022-09-26-14-26-50.png\"></p>\n<p>显示ppm格式的图像使用：<a href=\"https://link.zhihu.com/?target=http://openseeit.sourceforge.net/\">OpenSeeIt</a>，生成图像需要在cmd切换到应用程序目录并执行命令：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">Raytracing_in_one_weekend.exe &gt; image.ppm<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-09-26-14-28-48.png\"></p>\n<h1 id=\"vec3类\"><a href=\"#vec3类\" class=\"headerlink\" title=\"vec3类\"></a>vec3类</h1><p>这里就复习一下c++语法吧</p>\n<h2 id=\"const关键字小结：\"><a href=\"#const关键字小结：\" class=\"headerlink\" title=\"const关键字小结：\"></a>const关键字小结：</h2><ol>\n<li><p>const修饰普通类型的变量，表示是一个常量，不能重新赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> a = <span class=\"hljs-number\">10</span>;<br>b = a; <span class=\"hljs-comment\">//正确</span><br>a = <span class=\"hljs-number\">7</span>; <span class=\"hljs-comment\">//错误</span><br></code></pre></td></tr></table></figure></li>\n<li><p>const 修饰指针变量，”左定值，右定向，const修饰不变量”，就是修饰谁谁就不能被改变</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// const修饰指针</span><br><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">8</span>;<br><span class=\"hljs-type\">int</span> * <span class=\"hljs-type\">const</span> p = &amp;a;<br>*p = <span class=\"hljs-number\">9</span>; <span class=\"hljs-comment\">//正确</span><br>p = &amp;b; <span class=\"hljs-comment\">//错误</span><br><br><span class=\"hljs-comment\">// const修饰指针内容</span><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p = <span class=\"hljs-number\">9</span>;<br><br><span class=\"hljs-comment\">// const修饰指针和指针指向的内容, 指针p和*p都不能改变</span><br><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">8</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> * <span class=\"hljs-type\">const</span> p = &amp;a;<br></code></pre></td></tr></table></figure></li>\n<li><p>const参数传递和函数返回值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// const修饰传递的值</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a)</span></span>&#123;<br>   cout&lt;&lt;a;<br>   <span class=\"hljs-comment\">// ++a;  是错误的，a 不能被改变</span><br>&#125;<br><span class=\"hljs-comment\">// const修饰传递的指针,防止指针被意外篡改</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> * <span class=\"hljs-type\">const</span> p)</span></span>&#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> my_class&amp; a)</span></span>&#123;<br>   cout&lt;&lt;a.<span class=\"hljs-built_in\">class_fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>const修饰类成员函数</p>\n<p>const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。</p>\n</li>\n</ol>\n<h2 id=\"构造函数和运算符重载\"><a href=\"#构造函数和运算符重载\" class=\"headerlink\" title=\"构造函数和运算符重载\"></a>构造函数和运算符重载</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//构造函数</span><br><span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-type\">double</span> x,<span class=\"hljs-type\">double</span> y,<span class=\"hljs-type\">double</span> z):e&#123;x,y,z&#125;&#123;&#125;<br><span class=\"hljs-comment\">//运算符重载</span><br>vec3 <span class=\"hljs-keyword\">operator</span>*=(<span class=\"hljs-type\">int</span> t)&#123;<br>   ...<br>&#125;<br><span class=\"hljs-keyword\">inline</span> vec3 <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> vec3&amp; u, <span class=\"hljs-type\">const</span> vec3&amp; v) &#123;<br>   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">vec3</span>(u.e[<span class=\"hljs-number\">0</span>] * v.e[<span class=\"hljs-number\">0</span>], u.e[<span class=\"hljs-number\">1</span>] * v.e[<span class=\"hljs-number\">1</span>], u.e[<span class=\"hljs-number\">2</span>] * v.e[<span class=\"hljs-number\">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"inline关键字\"><a href=\"#inline关键字\" class=\"headerlink\" title=\"inline关键字\"></a>inline关键字</h2><p>在 c&#x2F;c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。</p>\n<p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p>\n<p>在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p>\n<p><strong>inline就是把函数内容替换到函数调用处。</strong></p>\n<p><strong>注意：inline函数里不能有while和switch，不能是递归函数</strong></p>\n<h2 id=\"C-中的别名定义\"><a href=\"#C-中的别名定义\" class=\"headerlink\" title=\"C++中的别名定义\"></a>C++中的别名定义</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 使用别名来区分点和颜色，只是用来区分，不会有警告</span><br><span class=\"hljs-keyword\">using</span> point3 = vec3;<br><span class=\"hljs-keyword\">using</span> color = vec3;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"光线，简单摄像机和背景\"><a href=\"#光线，简单摄像机和背景\" class=\"headerlink\" title=\"光线，简单摄像机和背景\"></a>光线，简单摄像机和背景</h1><p><img src=\"/article_img/2022-09-26-21-08-46.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">color <span class=\"hljs-title\">ray_color</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r)</span> </span>&#123;<br>\t<span class=\"hljs-comment\">// 线性插值颜色</span><br>\tvec3 unit_direction = <span class=\"hljs-built_in\">unit_vector</span>(r.<span class=\"hljs-built_in\">direction</span>());<br>\t<span class=\"hljs-keyword\">auto</span> t = <span class=\"hljs-number\">0.5</span> * (unit_direction.<span class=\"hljs-built_in\">y</span>() + <span class=\"hljs-number\">1.0</span>);<br>   <span class=\"hljs-comment\">// blendedValue=(1−t)⋅startValue+t⋅endValue</span><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1.0</span> - t) * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>) + t * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.7</span>, <span class=\"hljs-number\">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-09-26-21-01-37.png\"></p>\n<h1 id=\"添加球面\"><a href=\"#添加球面\" class=\"headerlink\" title=\"添加球面\"></a>添加球面</h1><p>绘制一个球心在（0，0，-1）处，半径为0.5的球。</p>\n<p>主要在于判断球面和光线是否相交，Games101中提到的光线与隐式表面的求交问题，将光线方程带入球面方程，求t。</p>\n<p><img src=\"/article_img/2022-09-27-11-50-26.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">hit_sphere</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> point3&amp; center, <span class=\"hljs-type\">double</span> radius, <span class=\"hljs-type\">const</span> ray&amp; r)</span> </span>&#123;<br><br>\t<span class=\"hljs-comment\">//  t2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r2=0</span><br><br>\tvec3 oc = r.<span class=\"hljs-built_in\">origin</span>() - center;<br>\t<span class=\"hljs-keyword\">auto</span> a = <span class=\"hljs-built_in\">dot</span>(r.<span class=\"hljs-built_in\">direction</span>(), r.<span class=\"hljs-built_in\">direction</span>());<br>\t<span class=\"hljs-keyword\">auto</span> b = <span class=\"hljs-number\">2</span> * <span class=\"hljs-built_in\">dot</span>(r.<span class=\"hljs-built_in\">direction</span>(), oc);<br>\t<span class=\"hljs-keyword\">auto</span> c = <span class=\"hljs-built_in\">dot</span>(oc, oc) - radius * radius;<br>\t<span class=\"hljs-keyword\">auto</span> discriminant = b * b - <span class=\"hljs-number\">4</span> * a * c;<br>\t<span class=\"hljs-keyword\">return</span> (discriminant &gt; <span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-09-27-11-50-57.png\"></p>\n<p><strong>存在的问题</strong>：若将球心放置在（0，0，1）渲染的结果和此时一样。</p>\n<h1 id=\"法线和多个物体\"><a href=\"#法线和多个物体\" class=\"headerlink\" title=\"法线和多个物体\"></a>法线和多个物体</h1><h2 id=\"法线可视化\"><a href=\"#法线可视化\" class=\"headerlink\" title=\"法线可视化\"></a>法线可视化</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">if</span> (t &gt; <span class=\"hljs-number\">0.0</span>) &#123; <span class=\"hljs-comment\">// 如果与球面相交直接return颜色</span><br>\t<span class=\"hljs-comment\">// 求得法线</span><br>\tvec3 N = <span class=\"hljs-built_in\">unit_vector</span>(r.<span class=\"hljs-built_in\">at</span>(t) - <span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>));<br>     <span class=\"hljs-comment\">// 将值映射到（0，1），尽管已经是单位向量，但是由于法线坐标会有负值，仍需要做映射</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.5</span> * <span class=\"hljs-built_in\">color</span>(N.<span class=\"hljs-built_in\">x</span>() + <span class=\"hljs-number\">1</span>, N.<span class=\"hljs-built_in\">y</span>() + <span class=\"hljs-number\">1</span>, N.<span class=\"hljs-built_in\">z</span>() + <span class=\"hljs-number\">1</span>); <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-09-27-13-10-42.png\"></p>\n<h2 id=\"hit-record结构体\"><a href=\"#hit-record结构体\" class=\"headerlink\" title=\"hit_record结构体\"></a>hit_record结构体</h2><p>记录光线与物体交点的信息：交点坐标，交点处法线，光线方程中的t值</p>\n<p>以及判断光线是从哪个方向射向平面，从而<strong>设定法线方向始终与光线入射方向相反</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">hit_record</span> &#123; <span class=\"hljs-comment\">// 记录了与物体交点的信息：交点坐标，交点处法线，光线方程中的t值</span><br>\tpoint3 p;<br>\tvec3 normal;<br>\t<span class=\"hljs-type\">double</span> t;<br><br>\t<span class=\"hljs-comment\">// 判断光线是从哪个方向射向平面</span><br>\t<span class=\"hljs-type\">bool</span> front_face;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_face_normal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r, <span class=\"hljs-type\">const</span> vec3&amp; outward_normal)</span> </span>&#123;<br>\t\t<span class=\"hljs-comment\">// 保证法线始终与光线入射方向相反</span><br>\t\tfront_face = <span class=\"hljs-built_in\">dot</span>(r.<span class=\"hljs-built_in\">direction</span>(), outward_normal) &lt; <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-comment\">// 设置normal</span><br>\t\tnormal = front_face ? outward_normal : -outward_normal;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"hittable类\"><a href=\"#hittable类\" class=\"headerlink\" title=\"hittable类\"></a>hittable类</h2><p>定义了一个虚函数，本书中只解决了与球面判断相交的问题，就是将线段代入球面方程看是否有解。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">hittable</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">hit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r, <span class=\"hljs-type\">double</span> t_min, <span class=\"hljs-type\">double</span> t_max, hit_record&amp; rec)</span><span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"sphere类\"><a href=\"#sphere类\" class=\"headerlink\" title=\"sphere类\"></a>sphere类</h2><p>sphere类继承自hittable类，实现了hit函数，有两个变量：球心坐标和半径</p>\n<h2 id=\"hittable-list类（Some-New-C-Features）\"><a href=\"#hittable-list类（Some-New-C-Features）\" class=\"headerlink\" title=\"hittable_list类（Some New C++ Features）\"></a>hittable_list类（Some New C++ Features）</h2><h2 id=\"渲染结果\"><a href=\"#渲染结果\" class=\"headerlink\" title=\"渲染结果\"></a>渲染结果</h2><p>在main函数中创建hittable_list对象world，表示场景信息，其中有一个大球一个小球（渲染结果如下），地面（大球）是绿色是因为这里的法线都是向上，观察小球的顶部也是绿色。</p>\n<p><img src=\"/article_img/2022-09-27-19-39-22.png\"></p>\n<h1 id=\"抗锯齿\"><a href=\"#抗锯齿\" class=\"headerlink\" title=\"抗锯齿\"></a>抗锯齿</h1><p>加大采样率，在每个像素中随机采样一百次，将结果平均作为该像素的颜色。</p>\n<p><img src=\"/article_img/2022-09-28-16-15-11.png\"></p>\n<p><img src=\"/article_img/2022-09-29-15-43-18.png\"><br>将相机部分的代码封装到了camera类。</p>\n<h1 id=\"漫反射材质\"><a href=\"#漫反射材质\" class=\"headerlink\" title=\"漫反射材质\"></a>漫反射材质</h1><p><img src=\"/article_img/2022-09-29-15-45-06.png\"></p>\n<p><img src=\"/article_img/2022-09-29-15-45-22.png\"></p>\n<p><img src=\"/article_img/2022-09-29-15-45-33.png\"></p>\n<p>方法1： 单位圆中随机<br>方法2： 在单位圆上随机生成<br>方法3： 直接生成反射方向  </p>\n<p>方法1比方法2要更加真实，因为前者能让更多光线向相机方向反射，而后者更多光线会靠近法线方法，导致反射次数增加（阴影很黑），使用方法2明显渲染速度变快很多。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">color <span class=\"hljs-title\">ray_color</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r, <span class=\"hljs-type\">const</span> hittable&amp; world, <span class=\"hljs-type\">int</span> depth)</span> </span>&#123;<br>\thit_record rec;<br><br>\t<span class=\"hljs-keyword\">if</span> (depth &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br><br>\t<span class=\"hljs-keyword\">if</span> (world.<span class=\"hljs-built_in\">hit</span>(r,<span class=\"hljs-number\">0.001</span>,infinity,rec))&#123; <span class=\"hljs-comment\">// 如果与球面相交直接return颜色</span><br>\t\t<span class=\"hljs-comment\">// 求得法线</span><br>\t\t<span class=\"hljs-comment\">//return 0.5 * (rec.normal + color(1,1,1));</span><br><br>\t\t<span class=\"hljs-comment\">/* 漫反射</span><br><span class=\"hljs-comment\">      方法1：单位圆中随机</span><br><span class=\"hljs-comment\">\t\tpoint3 target = rec.p + rec.normal + random_in_unit_vector(); </span><br><span class=\"hljs-comment\">      方法3：直接生成反射方向</span><br><span class=\"hljs-comment\">\t\tpoint3 target = rec.p + random_in_hemisphere(); </span><br><span class=\"hljs-comment\">      方法2：在单位圆上随机生成</span><br><span class=\"hljs-comment\">      */</span><br>\t\tpoint3 target = rec.p + rec.normal + <span class=\"hljs-built_in\">random_unit_vector</span>(); <br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.5</span> * <span class=\"hljs-built_in\">ray_color</span>(<span class=\"hljs-built_in\">ray</span>(rec.p, target - rec.p), world, depth - <span class=\"hljs-number\">1</span>); <br>\t&#125;<br>\t<span class=\"hljs-comment\">// 线性插值颜色</span><br>\tvec3 unit_direction = <span class=\"hljs-built_in\">unit_vector</span>(r.<span class=\"hljs-built_in\">direction</span>());<br>\t<span class=\"hljs-keyword\">auto</span> t = <span class=\"hljs-number\">0.5</span> * (unit_direction.<span class=\"hljs-built_in\">y</span>() + <span class=\"hljs-number\">1.0</span>);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1.0</span> - t) * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>) + t * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.7</span>, <span class=\"hljs-number\">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>color(1,1,1)表示白色，color(0,0,0)表示黑色，这里的0.5*ray_color(…)相当于每次光线衰减50%，就是变暗一半。</p>\n<p><img src=\"/article_img/2022-09-29-15-52-40.png\"></p>\n<h1 id=\"金属材质\"><a href=\"#金属材质\" class=\"headerlink\" title=\"金属材质\"></a>金属材质</h1><h2 id=\"材质类\"><a href=\"#材质类\" class=\"headerlink\" title=\"材质类\"></a>材质类</h2><p>抽象类： material类<br>继承类： metal类，lambertian类</p>\n<p><img src=\"/article_img/2022-09-30-14-48-32.png\"></p>\n<h2 id=\"左侧球呈现镜面效果的原因：\"><a href=\"#左侧球呈现镜面效果的原因：\" class=\"headerlink\" title=\"左侧球呈现镜面效果的原因：\"></a>左侧球呈现镜面效果的原因：</h2><p>光线从相机射出，与球面相交，调用交点材质的scatter函数计算反射光线以及得到衰减率，<strong>进入递归</strong>，发现反射光线不与物体相交，即进行线性插值颜色，<strong>递归结束</strong>，得到的线性插值颜色与衰减率相乘（<strong>这就是为什么左侧球与背景颜色相似但是稍暗一些的原因</strong>），得到最终的颜色。</p>\n<h2 id=\"右侧球带有颜色的原因：\"><a href=\"#右侧球带有颜色的原因：\" class=\"headerlink\" title=\"右侧球带有颜色的原因：\"></a>右侧球带有颜色的原因：</h2><p>就是因为其衰减率的RGB三个值不相同，导致有的颜色衰减的更多，就看起来有了某种颜色，而不是简单的变暗。</p>\n<h2 id=\"关键代码\"><a href=\"#关键代码\" class=\"headerlink\" title=\"关键代码\"></a>关键代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">color <span class=\"hljs-title\">ray_color</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r, <span class=\"hljs-type\">const</span> hittable&amp; world, <span class=\"hljs-type\">int</span> depth)</span> </span>&#123;<br>\thit_record rec;<br><br>\t<span class=\"hljs-keyword\">if</span> (depth &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br><br>\t<span class=\"hljs-keyword\">if</span> (world.<span class=\"hljs-built_in\">hit</span>(r,<span class=\"hljs-number\">0.001</span>,infinity,rec))&#123; <span class=\"hljs-comment\">// 与球面相交</span><br>\t\tray scattered;<br>\t\tcolor attenuation;   <span class=\"hljs-comment\">// 衰减率</span><br><br>      <span class=\"hljs-comment\">// 调用材质的scatter函数，得到该反射点的材质的衰减率和反射光线。</span><br>\t\t<span class=\"hljs-keyword\">if</span> (rec.mat_ptr-&gt;<span class=\"hljs-built_in\">scatter</span>(r, rec, attenuation, scattered))<br>\t\t\t<span class=\"hljs-keyword\">return</span> attenuation * <span class=\"hljs-built_in\">ray_color</span>(scattered, world, depth - <span class=\"hljs-number\">1</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 线性插值颜色</span><br>\tvec3 unit_direction = <span class=\"hljs-built_in\">unit_vector</span>(r.<span class=\"hljs-built_in\">direction</span>());<br>\t<span class=\"hljs-keyword\">auto</span> t = <span class=\"hljs-number\">0.5</span> * (unit_direction.<span class=\"hljs-built_in\">y</span>() + <span class=\"hljs-number\">1.0</span>);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1.0</span> - t) * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>) + t * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.7</span>, <span class=\"hljs-number\">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"模糊反射（磨砂镜面）\"><a href=\"#模糊反射（磨砂镜面）\" class=\"headerlink\" title=\"模糊反射（磨砂镜面）\"></a>模糊反射（磨砂镜面）</h1><p><img src=\"/article_img/2022-10-08-14-55-02.png\"></p>\n<p>反射光线加一个随机的向量（在单位圆中生成）</p>\n<p>在金属材质类（metal）中加一个属性：磨砂系数（fuzz）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">scattered = <span class=\"hljs-built_in\">ray</span>(rec.p, reflected + fuzz * <span class=\"hljs-built_in\">random_in_unit_sphere</span>());<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article_img/2022-10-08-14-54-52.png\"></p>\n<h1 id=\"电解质（透明物体）\"><a href=\"#电解质（透明物体）\" class=\"headerlink\" title=\"电解质（透明物体）\"></a>电解质（透明物体）</h1><h2 id=\"折射\"><a href=\"#折射\" class=\"headerlink\" title=\"折射\"></a>折射</h2><p><img src=\"/article_img/2022-10-09-14-06-32.png\"></p>\n<p>一次折射会让场景颠倒</p>\n<h2 id=\"Schlick近似\"><a href=\"#Schlick近似\" class=\"headerlink\" title=\"Schlick近似\"></a>Schlick近似</h2><p>现实世界中的玻璃, 发生折射的概率会随着入射角而改变——从一个很狭窄的角度去看玻璃窗, 它会变成一面镜子。</p>\n<h2 id=\"中空球\"><a href=\"#中空球\" class=\"headerlink\" title=\"中空球\"></a>中空球</h2><p>将球的半径设置为负值，几何形状不会改变，但是法相全部反转到内部。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">world.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-built_in\">make_shared</span>&lt;sphere&gt;(<span class=\"hljs-built_in\">point3</span>(<span class=\"hljs-number\">-1.0</span>,    <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">-1.0</span>),  <span class=\"hljs-number\">-0.4</span>, material_left));<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-10-09-14-25-53.png\"></p>\n<h1 id=\"相机\"><a href=\"#相机\" class=\"headerlink\" title=\"相机\"></a>相机</h1><h2 id=\"相机可视角度（Field-of-View）\"><a href=\"#相机可视角度（Field-of-View）\" class=\"headerlink\" title=\"相机可视角度（Field of View）\"></a>相机可视角度（Field of View）</h2><p>这里的可视角度是竖直方向上的可视角度，实际水平也可以。有了 FOV 再根据宽高比就能求出视图的宽高值。</p>\n<p><img src=\"/article_img/2022-10-09-14-28-04.png\"></p>\n<h2 id=\"相机的定位定向\"><a href=\"#相机的定位定向\" class=\"headerlink\" title=\"相机的定位定向\"></a>相机的定位定向</h2><p><img src=\"/article_img/2022-10-09-14-51-30.png\"></p>\n<p><img src=\"/article_img/2022-10-09-14-51-38.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> w = <span class=\"hljs-built_in\">unit_vector</span>(lookfrom - lookat);<br><span class=\"hljs-keyword\">auto</span> u = <span class=\"hljs-built_in\">unit_vector</span>(<span class=\"hljs-built_in\">cross</span>(vup, w));<br><span class=\"hljs-keyword\">auto</span> v = <span class=\"hljs-built_in\">cross</span>(w, u);<br></code></pre></td></tr></table></figure>\n\n<p>这里就是要新建一个坐标系，经过以上代码的运算，得到一个新的坐标系：相机看向-w方向，相机的向上方向是v，还有一个水平的方向u。</p>\n<p>改变camera类，可以设定相机的位置和相机看向的方向。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">camera <span class=\"hljs-title\">cam</span><span class=\"hljs-params\">(point3(<span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>), point3(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>), vec3(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">90</span>, aspect_ratio)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-10-09-14-52-21.png\"></p>\n<h1 id=\"景深\"><a href=\"#景深\" class=\"headerlink\" title=\"景深\"></a>景深</h1><p><img src=\"/article_img/2022-10-09-15-26-37.png\"></p>\n<h1 id=\"常看常新\"><a href=\"#常看常新\" class=\"headerlink\" title=\"常看常新\"></a>常看常新</h1><h2 id=\"成像平面\"><a href=\"#成像平面\" class=\"headerlink\" title=\"成像平面\"></a>成像平面</h2><p>之前在我的印象中光线追踪模型应该是下图这样的，摄像机和成像平面在整个场景之前，但其实成像平面在哪并没有什么关系，本例的成像平面就与物体在同一深度。</p>\n<p><img src=\"/article_img/2022-10-29-18-15-59.png\"></p>\n<p>仔细一想，成像平面的意义在于确定从相机发出的路径，所以如下图所示，只要成像平面的面积与平面到相机的距离成比例变化，其实发出的路径都是一样的，都在图示的锥体中。</p>\n<p><img src=\"/article_img/2022-10-29-18-20-06.png\"></p>\n<p>而FOV实际上也是在改变这个锥体，FOV越大，成像平面也就越大（平面到相机的垂直相同的情况下）。</p>\n<p>关于FOV还有一个有趣的观察，在这个光线追踪例子中，FOV越小，最终得到的图像和真正将相机离物体很近拍出的图像一模一样。而在现实中（如下图）我们可以轻易的分辨出是从很近的地方拍照还是通过变焦从很远的地方拍照（会明显模糊），而在本例子中并不会产生模糊。原因在于现实中的相机焦距不是任意可调的，理论上来说，拍摄越远的物体，相机内部的成像平面也应该离透镜越远，而真实的相机大小是有限的，因此会产生模糊，在本文中的虚拟的透镜焦距确实是可以任意调整的，因此并不会模糊，就像在很近的距离拍摄的一样，物体又大又清晰。</p>\n<p><img src=\"/article_img/2022-10-29-13-44-32.png\"></p>\n","site":{"data":{}},"wordcount":5830,"excerpt":"<p>Ray tracing in one weekend笔记</p>","more":"<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p><a href=\"https://raytracing.github.io/books/RayTracingInOneWeekend.html\">Ray Tracing in one weekend</a></p>\n<p><a href=\"https://zhuanlan.zhihu.com/p/128582904\">中文翻译</a></p>\n<h1 id=\"输出图像\"><a href=\"#输出图像\" class=\"headerlink\" title=\"输出图像\"></a>输出图像</h1><p>使用ppm格式</p>\n<p><img src=\"/article_img/2022-09-26-14-26-50.png\"></p>\n<p>显示ppm格式的图像使用：<a href=\"https://link.zhihu.com/?target=http://openseeit.sourceforge.net/\">OpenSeeIt</a>，生成图像需要在cmd切换到应用程序目录并执行命令：</p>\n<figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arduino\">Raytracing_in_one_weekend.exe &gt; image.ppm<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-09-26-14-28-48.png\"></p>\n<h1 id=\"vec3类\"><a href=\"#vec3类\" class=\"headerlink\" title=\"vec3类\"></a>vec3类</h1><p>这里就复习一下c++语法吧</p>\n<h2 id=\"const关键字小结：\"><a href=\"#const关键字小结：\" class=\"headerlink\" title=\"const关键字小结：\"></a>const关键字小结：</h2><ol>\n<li><p>const修饰普通类型的变量，表示是一个常量，不能重新赋值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> a = <span class=\"hljs-number\">10</span>;<br>b = a; <span class=\"hljs-comment\">//正确</span><br>a = <span class=\"hljs-number\">7</span>; <span class=\"hljs-comment\">//错误</span><br></code></pre></td></tr></table></figure></li>\n<li><p>const 修饰指针变量，”左定值，右定向，const修饰不变量”，就是修饰谁谁就不能被改变</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// const修饰指针</span><br><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">8</span>;<br><span class=\"hljs-type\">int</span> * <span class=\"hljs-type\">const</span> p = &amp;a;<br>*p = <span class=\"hljs-number\">9</span>; <span class=\"hljs-comment\">//正确</span><br>p = &amp;b; <span class=\"hljs-comment\">//错误</span><br><br><span class=\"hljs-comment\">// const修饰指针内容</span><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> *p = <span class=\"hljs-number\">9</span>;<br><br><span class=\"hljs-comment\">// const修饰指针和指针指向的内容, 指针p和*p都不能改变</span><br><span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">8</span>;<br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> * <span class=\"hljs-type\">const</span> p = &amp;a;<br></code></pre></td></tr></table></figure></li>\n<li><p>const参数传递和函数返回值</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// const修饰传递的值</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> a)</span></span>&#123;<br>   cout&lt;&lt;a;<br>   <span class=\"hljs-comment\">// ++a;  是错误的，a 不能被改变</span><br>&#125;<br><span class=\"hljs-comment\">// const修饰传递的指针,防止指针被意外篡改</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> * <span class=\"hljs-type\">const</span> p)</span></span>&#123;<br>   ...<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>自定义类型的参数传递，需要临时对象复制参数，对于临时对象的构造，需要调用构造函数，比较浪费时间，因此我们采取 const 外加引用传递的方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> my_class&amp; a)</span></span>&#123;<br>   cout&lt;&lt;a.<span class=\"hljs-built_in\">class_fun</span>();<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li><p>const修饰类成员函数</p>\n<p>const 修饰类成员函数，其目的是防止成员函数修改被调用对象的值，如果我们不想修改一个调用对象的值，所有的成员函数都应当声明为 const 成员函数。</p>\n</li>\n</ol>\n<h2 id=\"构造函数和运算符重载\"><a href=\"#构造函数和运算符重载\" class=\"headerlink\" title=\"构造函数和运算符重载\"></a>构造函数和运算符重载</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//构造函数</span><br><span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-type\">double</span> x,<span class=\"hljs-type\">double</span> y,<span class=\"hljs-type\">double</span> z):e&#123;x,y,z&#125;&#123;&#125;<br><span class=\"hljs-comment\">//运算符重载</span><br>vec3 <span class=\"hljs-keyword\">operator</span>*=(<span class=\"hljs-type\">int</span> t)&#123;<br>   ...<br>&#125;<br><span class=\"hljs-keyword\">inline</span> vec3 <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> vec3&amp; u, <span class=\"hljs-type\">const</span> vec3&amp; v) &#123;<br>   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">vec3</span>(u.e[<span class=\"hljs-number\">0</span>] * v.e[<span class=\"hljs-number\">0</span>], u.e[<span class=\"hljs-number\">1</span>] * v.e[<span class=\"hljs-number\">1</span>], u.e[<span class=\"hljs-number\">2</span>] * v.e[<span class=\"hljs-number\">2</span>]);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"inline关键字\"><a href=\"#inline关键字\" class=\"headerlink\" title=\"inline关键字\"></a>inline关键字</h2><p>在 c&#x2F;c++ 中，为了解决一些频繁调用的小函数大量消耗栈空间（栈内存）的问题，特别的引入了 inline 修饰符，表示为内联函数。</p>\n<p>栈空间就是指放置程序的局部数据（也就是函数内数据）的内存空间。</p>\n<p>在系统下，栈空间是有限的，假如频繁大量的使用就会造成因栈空间不足而导致程序出错的问题，如，函数的死循环递归调用的最终结果就是导致栈内存空间枯竭。</p>\n<p><strong>inline就是把函数内容替换到函数调用处。</strong></p>\n<p><strong>注意：inline函数里不能有while和switch，不能是递归函数</strong></p>\n<h2 id=\"C-中的别名定义\"><a href=\"#C-中的别名定义\" class=\"headerlink\" title=\"C++中的别名定义\"></a>C++中的别名定义</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 使用别名来区分点和颜色，只是用来区分，不会有警告</span><br><span class=\"hljs-keyword\">using</span> point3 = vec3;<br><span class=\"hljs-keyword\">using</span> color = vec3;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"光线，简单摄像机和背景\"><a href=\"#光线，简单摄像机和背景\" class=\"headerlink\" title=\"光线，简单摄像机和背景\"></a>光线，简单摄像机和背景</h1><p><img src=\"/article_img/2022-09-26-21-08-46.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">color <span class=\"hljs-title\">ray_color</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r)</span> </span>&#123;<br>\t<span class=\"hljs-comment\">// 线性插值颜色</span><br>\tvec3 unit_direction = <span class=\"hljs-built_in\">unit_vector</span>(r.<span class=\"hljs-built_in\">direction</span>());<br>\t<span class=\"hljs-keyword\">auto</span> t = <span class=\"hljs-number\">0.5</span> * (unit_direction.<span class=\"hljs-built_in\">y</span>() + <span class=\"hljs-number\">1.0</span>);<br>   <span class=\"hljs-comment\">// blendedValue=(1−t)⋅startValue+t⋅endValue</span><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1.0</span> - t) * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>) + t * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.7</span>, <span class=\"hljs-number\">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-09-26-21-01-37.png\"></p>\n<h1 id=\"添加球面\"><a href=\"#添加球面\" class=\"headerlink\" title=\"添加球面\"></a>添加球面</h1><p>绘制一个球心在（0，0，-1）处，半径为0.5的球。</p>\n<p>主要在于判断球面和光线是否相交，Games101中提到的光线与隐式表面的求交问题，将光线方程带入球面方程，求t。</p>\n<p><img src=\"/article_img/2022-09-27-11-50-26.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">hit_sphere</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> point3&amp; center, <span class=\"hljs-type\">double</span> radius, <span class=\"hljs-type\">const</span> ray&amp; r)</span> </span>&#123;<br><br>\t<span class=\"hljs-comment\">//  t2b⋅b+2tb⋅(A−C)+(A−C)⋅(A−C)−r2=0</span><br><br>\tvec3 oc = r.<span class=\"hljs-built_in\">origin</span>() - center;<br>\t<span class=\"hljs-keyword\">auto</span> a = <span class=\"hljs-built_in\">dot</span>(r.<span class=\"hljs-built_in\">direction</span>(), r.<span class=\"hljs-built_in\">direction</span>());<br>\t<span class=\"hljs-keyword\">auto</span> b = <span class=\"hljs-number\">2</span> * <span class=\"hljs-built_in\">dot</span>(r.<span class=\"hljs-built_in\">direction</span>(), oc);<br>\t<span class=\"hljs-keyword\">auto</span> c = <span class=\"hljs-built_in\">dot</span>(oc, oc) - radius * radius;<br>\t<span class=\"hljs-keyword\">auto</span> discriminant = b * b - <span class=\"hljs-number\">4</span> * a * c;<br>\t<span class=\"hljs-keyword\">return</span> (discriminant &gt; <span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-09-27-11-50-57.png\"></p>\n<p><strong>存在的问题</strong>：若将球心放置在（0，0，1）渲染的结果和此时一样。</p>\n<h1 id=\"法线和多个物体\"><a href=\"#法线和多个物体\" class=\"headerlink\" title=\"法线和多个物体\"></a>法线和多个物体</h1><h2 id=\"法线可视化\"><a href=\"#法线可视化\" class=\"headerlink\" title=\"法线可视化\"></a>法线可视化</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">if</span> (t &gt; <span class=\"hljs-number\">0.0</span>) &#123; <span class=\"hljs-comment\">// 如果与球面相交直接return颜色</span><br>\t<span class=\"hljs-comment\">// 求得法线</span><br>\tvec3 N = <span class=\"hljs-built_in\">unit_vector</span>(r.<span class=\"hljs-built_in\">at</span>(t) - <span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>));<br>     <span class=\"hljs-comment\">// 将值映射到（0，1），尽管已经是单位向量，但是由于法线坐标会有负值，仍需要做映射</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.5</span> * <span class=\"hljs-built_in\">color</span>(N.<span class=\"hljs-built_in\">x</span>() + <span class=\"hljs-number\">1</span>, N.<span class=\"hljs-built_in\">y</span>() + <span class=\"hljs-number\">1</span>, N.<span class=\"hljs-built_in\">z</span>() + <span class=\"hljs-number\">1</span>); <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-09-27-13-10-42.png\"></p>\n<h2 id=\"hit-record结构体\"><a href=\"#hit-record结构体\" class=\"headerlink\" title=\"hit_record结构体\"></a>hit_record结构体</h2><p>记录光线与物体交点的信息：交点坐标，交点处法线，光线方程中的t值</p>\n<p>以及判断光线是从哪个方向射向平面，从而<strong>设定法线方向始终与光线入射方向相反</strong>。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">hit_record</span> &#123; <span class=\"hljs-comment\">// 记录了与物体交点的信息：交点坐标，交点处法线，光线方程中的t值</span><br>\tpoint3 p;<br>\tvec3 normal;<br>\t<span class=\"hljs-type\">double</span> t;<br><br>\t<span class=\"hljs-comment\">// 判断光线是从哪个方向射向平面</span><br>\t<span class=\"hljs-type\">bool</span> front_face;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">inline</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_face_normal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r, <span class=\"hljs-type\">const</span> vec3&amp; outward_normal)</span> </span>&#123;<br>\t\t<span class=\"hljs-comment\">// 保证法线始终与光线入射方向相反</span><br>\t\tfront_face = <span class=\"hljs-built_in\">dot</span>(r.<span class=\"hljs-built_in\">direction</span>(), outward_normal) &lt; <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-comment\">// 设置normal</span><br>\t\tnormal = front_face ? outward_normal : -outward_normal;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"hittable类\"><a href=\"#hittable类\" class=\"headerlink\" title=\"hittable类\"></a>hittable类</h2><p>定义了一个虚函数，本书中只解决了与球面判断相交的问题，就是将线段代入球面方程看是否有解。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">hittable</span> &#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">hit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r, <span class=\"hljs-type\">double</span> t_min, <span class=\"hljs-type\">double</span> t_max, hit_record&amp; rec)</span><span class=\"hljs-type\">const</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<h2 id=\"sphere类\"><a href=\"#sphere类\" class=\"headerlink\" title=\"sphere类\"></a>sphere类</h2><p>sphere类继承自hittable类，实现了hit函数，有两个变量：球心坐标和半径</p>\n<h2 id=\"hittable-list类（Some-New-C-Features）\"><a href=\"#hittable-list类（Some-New-C-Features）\" class=\"headerlink\" title=\"hittable_list类（Some New C++ Features）\"></a>hittable_list类（Some New C++ Features）</h2><h2 id=\"渲染结果\"><a href=\"#渲染结果\" class=\"headerlink\" title=\"渲染结果\"></a>渲染结果</h2><p>在main函数中创建hittable_list对象world，表示场景信息，其中有一个大球一个小球（渲染结果如下），地面（大球）是绿色是因为这里的法线都是向上，观察小球的顶部也是绿色。</p>\n<p><img src=\"/article_img/2022-09-27-19-39-22.png\"></p>\n<h1 id=\"抗锯齿\"><a href=\"#抗锯齿\" class=\"headerlink\" title=\"抗锯齿\"></a>抗锯齿</h1><p>加大采样率，在每个像素中随机采样一百次，将结果平均作为该像素的颜色。</p>\n<p><img src=\"/article_img/2022-09-28-16-15-11.png\"></p>\n<p><img src=\"/article_img/2022-09-29-15-43-18.png\"><br>将相机部分的代码封装到了camera类。</p>\n<h1 id=\"漫反射材质\"><a href=\"#漫反射材质\" class=\"headerlink\" title=\"漫反射材质\"></a>漫反射材质</h1><p><img src=\"/article_img/2022-09-29-15-45-06.png\"></p>\n<p><img src=\"/article_img/2022-09-29-15-45-22.png\"></p>\n<p><img src=\"/article_img/2022-09-29-15-45-33.png\"></p>\n<p>方法1： 单位圆中随机<br>方法2： 在单位圆上随机生成<br>方法3： 直接生成反射方向  </p>\n<p>方法1比方法2要更加真实，因为前者能让更多光线向相机方向反射，而后者更多光线会靠近法线方法，导致反射次数增加（阴影很黑），使用方法2明显渲染速度变快很多。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">color <span class=\"hljs-title\">ray_color</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r, <span class=\"hljs-type\">const</span> hittable&amp; world, <span class=\"hljs-type\">int</span> depth)</span> </span>&#123;<br>\thit_record rec;<br><br>\t<span class=\"hljs-keyword\">if</span> (depth &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br><br>\t<span class=\"hljs-keyword\">if</span> (world.<span class=\"hljs-built_in\">hit</span>(r,<span class=\"hljs-number\">0.001</span>,infinity,rec))&#123; <span class=\"hljs-comment\">// 如果与球面相交直接return颜色</span><br>\t\t<span class=\"hljs-comment\">// 求得法线</span><br>\t\t<span class=\"hljs-comment\">//return 0.5 * (rec.normal + color(1,1,1));</span><br><br>\t\t<span class=\"hljs-comment\">/* 漫反射</span><br><span class=\"hljs-comment\">      方法1：单位圆中随机</span><br><span class=\"hljs-comment\">\t\tpoint3 target = rec.p + rec.normal + random_in_unit_vector(); </span><br><span class=\"hljs-comment\">      方法3：直接生成反射方向</span><br><span class=\"hljs-comment\">\t\tpoint3 target = rec.p + random_in_hemisphere(); </span><br><span class=\"hljs-comment\">      方法2：在单位圆上随机生成</span><br><span class=\"hljs-comment\">      */</span><br>\t\tpoint3 target = rec.p + rec.normal + <span class=\"hljs-built_in\">random_unit_vector</span>(); <br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.5</span> * <span class=\"hljs-built_in\">ray_color</span>(<span class=\"hljs-built_in\">ray</span>(rec.p, target - rec.p), world, depth - <span class=\"hljs-number\">1</span>); <br>\t&#125;<br>\t<span class=\"hljs-comment\">// 线性插值颜色</span><br>\tvec3 unit_direction = <span class=\"hljs-built_in\">unit_vector</span>(r.<span class=\"hljs-built_in\">direction</span>());<br>\t<span class=\"hljs-keyword\">auto</span> t = <span class=\"hljs-number\">0.5</span> * (unit_direction.<span class=\"hljs-built_in\">y</span>() + <span class=\"hljs-number\">1.0</span>);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1.0</span> - t) * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>) + t * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.7</span>, <span class=\"hljs-number\">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>color(1,1,1)表示白色，color(0,0,0)表示黑色，这里的0.5*ray_color(…)相当于每次光线衰减50%，就是变暗一半。</p>\n<p><img src=\"/article_img/2022-09-29-15-52-40.png\"></p>\n<h1 id=\"金属材质\"><a href=\"#金属材质\" class=\"headerlink\" title=\"金属材质\"></a>金属材质</h1><h2 id=\"材质类\"><a href=\"#材质类\" class=\"headerlink\" title=\"材质类\"></a>材质类</h2><p>抽象类： material类<br>继承类： metal类，lambertian类</p>\n<p><img src=\"/article_img/2022-09-30-14-48-32.png\"></p>\n<h2 id=\"左侧球呈现镜面效果的原因：\"><a href=\"#左侧球呈现镜面效果的原因：\" class=\"headerlink\" title=\"左侧球呈现镜面效果的原因：\"></a>左侧球呈现镜面效果的原因：</h2><p>光线从相机射出，与球面相交，调用交点材质的scatter函数计算反射光线以及得到衰减率，<strong>进入递归</strong>，发现反射光线不与物体相交，即进行线性插值颜色，<strong>递归结束</strong>，得到的线性插值颜色与衰减率相乘（<strong>这就是为什么左侧球与背景颜色相似但是稍暗一些的原因</strong>），得到最终的颜色。</p>\n<h2 id=\"右侧球带有颜色的原因：\"><a href=\"#右侧球带有颜色的原因：\" class=\"headerlink\" title=\"右侧球带有颜色的原因：\"></a>右侧球带有颜色的原因：</h2><p>就是因为其衰减率的RGB三个值不相同，导致有的颜色衰减的更多，就看起来有了某种颜色，而不是简单的变暗。</p>\n<h2 id=\"关键代码\"><a href=\"#关键代码\" class=\"headerlink\" title=\"关键代码\"></a>关键代码</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">color <span class=\"hljs-title\">ray_color</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> ray&amp; r, <span class=\"hljs-type\">const</span> hittable&amp; world, <span class=\"hljs-type\">int</span> depth)</span> </span>&#123;<br>\thit_record rec;<br><br>\t<span class=\"hljs-keyword\">if</span> (depth &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br><br>\t<span class=\"hljs-keyword\">if</span> (world.<span class=\"hljs-built_in\">hit</span>(r,<span class=\"hljs-number\">0.001</span>,infinity,rec))&#123; <span class=\"hljs-comment\">// 与球面相交</span><br>\t\tray scattered;<br>\t\tcolor attenuation;   <span class=\"hljs-comment\">// 衰减率</span><br><br>      <span class=\"hljs-comment\">// 调用材质的scatter函数，得到该反射点的材质的衰减率和反射光线。</span><br>\t\t<span class=\"hljs-keyword\">if</span> (rec.mat_ptr-&gt;<span class=\"hljs-built_in\">scatter</span>(r, rec, attenuation, scattered))<br>\t\t\t<span class=\"hljs-keyword\">return</span> attenuation * <span class=\"hljs-built_in\">ray_color</span>(scattered, world, depth - <span class=\"hljs-number\">1</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 线性插值颜色</span><br>\tvec3 unit_direction = <span class=\"hljs-built_in\">unit_vector</span>(r.<span class=\"hljs-built_in\">direction</span>());<br>\t<span class=\"hljs-keyword\">auto</span> t = <span class=\"hljs-number\">0.5</span> * (unit_direction.<span class=\"hljs-built_in\">y</span>() + <span class=\"hljs-number\">1.0</span>);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1.0</span> - t) * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">1.0</span>) + t * <span class=\"hljs-built_in\">color</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.7</span>, <span class=\"hljs-number\">1.0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"模糊反射（磨砂镜面）\"><a href=\"#模糊反射（磨砂镜面）\" class=\"headerlink\" title=\"模糊反射（磨砂镜面）\"></a>模糊反射（磨砂镜面）</h1><p><img src=\"/article_img/2022-10-08-14-55-02.png\"></p>\n<p>反射光线加一个随机的向量（在单位圆中生成）</p>\n<p>在金属材质类（metal）中加一个属性：磨砂系数（fuzz）</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">scattered = <span class=\"hljs-built_in\">ray</span>(rec.p, reflected + fuzz * <span class=\"hljs-built_in\">random_in_unit_sphere</span>());<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article_img/2022-10-08-14-54-52.png\"></p>\n<h1 id=\"电解质（透明物体）\"><a href=\"#电解质（透明物体）\" class=\"headerlink\" title=\"电解质（透明物体）\"></a>电解质（透明物体）</h1><h2 id=\"折射\"><a href=\"#折射\" class=\"headerlink\" title=\"折射\"></a>折射</h2><p><img src=\"/article_img/2022-10-09-14-06-32.png\"></p>\n<p>一次折射会让场景颠倒</p>\n<h2 id=\"Schlick近似\"><a href=\"#Schlick近似\" class=\"headerlink\" title=\"Schlick近似\"></a>Schlick近似</h2><p>现实世界中的玻璃, 发生折射的概率会随着入射角而改变——从一个很狭窄的角度去看玻璃窗, 它会变成一面镜子。</p>\n<h2 id=\"中空球\"><a href=\"#中空球\" class=\"headerlink\" title=\"中空球\"></a>中空球</h2><p>将球的半径设置为负值，几何形状不会改变，但是法相全部反转到内部。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">world.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-built_in\">make_shared</span>&lt;sphere&gt;(<span class=\"hljs-built_in\">point3</span>(<span class=\"hljs-number\">-1.0</span>,    <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">-1.0</span>),  <span class=\"hljs-number\">-0.4</span>, material_left));<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-10-09-14-25-53.png\"></p>\n<h1 id=\"相机\"><a href=\"#相机\" class=\"headerlink\" title=\"相机\"></a>相机</h1><h2 id=\"相机可视角度（Field-of-View）\"><a href=\"#相机可视角度（Field-of-View）\" class=\"headerlink\" title=\"相机可视角度（Field of View）\"></a>相机可视角度（Field of View）</h2><p>这里的可视角度是竖直方向上的可视角度，实际水平也可以。有了 FOV 再根据宽高比就能求出视图的宽高值。</p>\n<p><img src=\"/article_img/2022-10-09-14-28-04.png\"></p>\n<h2 id=\"相机的定位定向\"><a href=\"#相机的定位定向\" class=\"headerlink\" title=\"相机的定位定向\"></a>相机的定位定向</h2><p><img src=\"/article_img/2022-10-09-14-51-30.png\"></p>\n<p><img src=\"/article_img/2022-10-09-14-51-38.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">auto</span> w = <span class=\"hljs-built_in\">unit_vector</span>(lookfrom - lookat);<br><span class=\"hljs-keyword\">auto</span> u = <span class=\"hljs-built_in\">unit_vector</span>(<span class=\"hljs-built_in\">cross</span>(vup, w));<br><span class=\"hljs-keyword\">auto</span> v = <span class=\"hljs-built_in\">cross</span>(w, u);<br></code></pre></td></tr></table></figure>\n\n<p>这里就是要新建一个坐标系，经过以上代码的运算，得到一个新的坐标系：相机看向-w方向，相机的向上方向是v，还有一个水平的方向u。</p>\n<p>改变camera类，可以设定相机的位置和相机看向的方向。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\">camera <span class=\"hljs-title\">cam</span><span class=\"hljs-params\">(point3(<span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>), point3(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">-1</span>), vec3(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>), <span class=\"hljs-number\">90</span>, aspect_ratio)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-10-09-14-52-21.png\"></p>\n<h1 id=\"景深\"><a href=\"#景深\" class=\"headerlink\" title=\"景深\"></a>景深</h1><p><img src=\"/article_img/2022-10-09-15-26-37.png\"></p>\n<h1 id=\"常看常新\"><a href=\"#常看常新\" class=\"headerlink\" title=\"常看常新\"></a>常看常新</h1><h2 id=\"成像平面\"><a href=\"#成像平面\" class=\"headerlink\" title=\"成像平面\"></a>成像平面</h2><p>之前在我的印象中光线追踪模型应该是下图这样的，摄像机和成像平面在整个场景之前，但其实成像平面在哪并没有什么关系，本例的成像平面就与物体在同一深度。</p>\n<p><img src=\"/article_img/2022-10-29-18-15-59.png\"></p>\n<p>仔细一想，成像平面的意义在于确定从相机发出的路径，所以如下图所示，只要成像平面的面积与平面到相机的距离成比例变化，其实发出的路径都是一样的，都在图示的锥体中。</p>\n<p><img src=\"/article_img/2022-10-29-18-20-06.png\"></p>\n<p>而FOV实际上也是在改变这个锥体，FOV越大，成像平面也就越大（平面到相机的垂直相同的情况下）。</p>\n<p>关于FOV还有一个有趣的观察，在这个光线追踪例子中，FOV越小，最终得到的图像和真正将相机离物体很近拍出的图像一模一样。而在现实中（如下图）我们可以轻易的分辨出是从很近的地方拍照还是通过变焦从很远的地方拍照（会明显模糊），而在本例子中并不会产生模糊。原因在于现实中的相机焦距不是任意可调的，理论上来说，拍摄越远的物体，相机内部的成像平面也应该离透镜越远，而真实的相机大小是有限的，因此会产生模糊，在本文中的虚拟的透镜焦距确实是可以任意调整的，因此并不会模糊，就像在很近的距离拍摄的一样，物体又大又清晰。</p>\n<p><img src=\"/article_img/2022-10-29-13-44-32.png\"></p>"},{"title":"Unity快捷键总结","date":"2023-03-04T16:00:00.000Z","index_img":"/img/bg/unity_logo.jpg","_content":"\nUnity快捷键总结\n<!-- more -->\n\n**Shift+鼠标点击左上角坐标系中间方块**： 转换到透视试图\n**q+左键**： 拖拽\n**alt+左键**： 旋转\n**点层级菜单中的物体+f/双击物体**： 聚焦到该物体","source":"_posts/Unity常用快捷键.md","raw":"---\ntitle: Unity快捷键总结\ndate: 2023-03-05\nindex_img: \"/img/bg/unity_logo.jpg\"\ntags: [Unity]\ncategories: \n   -[笔记]\n---\n\nUnity快捷键总结\n<!-- more -->\n\n**Shift+鼠标点击左上角坐标系中间方块**： 转换到透视试图\n**q+左键**： 拖拽\n**alt+左键**： 旋转\n**点层级菜单中的物体+f/双击物体**： 聚焦到该物体","slug":"Unity常用快捷键","published":1,"updated":"2023-03-17T10:13:55.810Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigm3001lw0je5r671gtx","content":"<p>Unity快捷键总结</p>\n<span id=\"more\"></span>\n\n<p><strong>Shift+鼠标点击左上角坐标系中间方块</strong>： 转换到透视试图<br><strong>q+左键</strong>： 拖拽<br><strong>alt+左键</strong>： 旋转<br><strong>点层级菜单中的物体+f&#x2F;双击物体</strong>： 聚焦到该物体</p>\n","site":{"data":{}},"wordcount":82,"excerpt":"<p>Unity快捷键总结</p>","more":"<p><strong>Shift+鼠标点击左上角坐标系中间方块</strong>： 转换到透视试图<br><strong>q+左键</strong>： 拖拽<br><strong>alt+左键</strong>： 旋转<br><strong>点层级菜单中的物体+f&#x2F;双击物体</strong>： 聚焦到该物体</p>"},{"title":"【边学边做】DreamGuard","date":"2023-03-21T16:00:00.000Z","index_img":"/img/bg/Logo.jpg","_content":"\n记录学习unity开发中的各种问题和常见解决方法\n<!-- more -->\n\n# 第三人称角色控制器\n\n在开发DreamGuard的时候，原本打算使用unity自带的第三人称模板，但是发现其实现是基于New Input System，阅读代码出现困难，就想着自己实现一下。\n\n## New Input System\n\n[官方文档](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/index.html)\n\n[视频教程](https://www.bilibili.com/video/BV1tg411j7ni/?spm_id_from=333.880.top_right_bar_window_custom_collection.content.click&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n我对New Input System的理解是unity希望规范开发者对用户输入的处理。New Input System除了实现老版本输入系统的功能外，主要还方便了用户输入设备的切换（如从键盘切换到手柄）以及方便对不同输入模式的切换（如在游戏中空格代表跳跃，在ui界面中空格代表确定）\n\n### 新输入系统的几种用法\n\n![](/article_img/2023-03-22-12-13-16.png)\n\n按照官网的介绍，新输入系统有四种用法，第一种是和老版本输入系统类似的写法；后面三种都需要借助Actions Asset，可以在Project窗口右键创建，可以将其理解为配置输入的界面，通过Actions Asset就可以可视化的将输入分类，实现输入设备的切换和输入模式的切换。同时在配置Actions Asset时可以选择生成一个C#类来方便在代码中直接使用Actions Asset。\n\nunity自带的第三人称模板使用的是第四种，这是一种我认为较为直观的使用方法，借助PlayerInput组件，可以选择要使用的Actions Asset以及输入时的行为，下图中的Behavior。\n\n![](/article_img/2023-03-22-12-25-07.png)\n\n第三人称模板使用的Behavior是[Send Messages](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)，这个方法是最简单的物体间的通信方法，他会将信息传递给该物体上附加的所有脚本；[Broadcast Messages](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)会将信息传递给附加到该游戏对象及其所有子对象的每个脚本；[Invoke Unity Events](https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html)对每个单独的消息类型使用单独的 UnityEvent；Invoke C Sharp Events和Invoke Unity Events类似，只是会触发一个C#事件。\n\n由于Send Messages效率较低（？还不太懂为啥），所以我自己实现的第三人称控制器使用Invoke Unity Events方法。\n\n这种方法需要配置Events，只需要为每个输入消息配置一个函数，就可以实现当有输入时，直接调用这个函数，使用起来十分方便。\n\n![](/article_img/2023-03-22-12-49-01.png)\n\n## 脚本实现\n\n第三人称控制器需要相机根据玩家鼠标的移动来回旋转，角色的移动是相对与玩家视角的移动（当玩家看向哪，前进方向就是哪），角色的旋转则永远指向角色的移动方向（不会随相机视角的旋转而旋转）。\n\n### 相机旋转\n\n这里的相机使用了Cinemachine系统中的virtual camera，其可以实现跟随角色以及看向角色。\n\n![](/article_img/2023-03-22-12-56-23.png)\n\n由于其会一直看向Look At设置的对象，因此要旋转相机只需要旋转相机看向的这个对象。在角色对象上添加一个空的子物体cameraLookAt，作为相机看向的方向。\n\n![](/article_img/2023-03-22-13-00-16.png)\n\n在Actions Asset中设置输入，获取玩家鼠标的与上一帧的相对移动，由于是相对移动，直接将这个值不断累加并且映射到角度值，就可以得到cameraLookAt这个子物体的旋转值。注意只有在用户有输入时才改变旋转值，否则会导致用户没有输入时旋转值也为0，由旋转回默认方向。\n\n```Csharp\n    private void CameraRotate()\n    {\n        if (lookDirection.sqrMagnitude > 0.1f)\n        {\n            cameraPitch += lookDirection.y;\n            cameraYaw += lookDirection.x;\n        }\n        cameraPitch = ClampAngle(cameraPitch, -70f, 70f);\n        cameraYaw = ClampAngle(cameraYaw, float.MinValue, float.MaxValue);\n\n        cameraLookAt.transform.rotation = Quaternion.Euler(cameraPitch, cameraYaw, 0);\n    }\n```\n\n### 角色移动和旋转\n\n角色移动依靠Character Controller实现。\n\n根据需要，角色需要是相对相机视角的移动，因此不能直接使用输入系统获取的相对与世界坐标系的方向，要将该方向变换到相机坐标系中。由于角色只在XZ平面移动，因此这种变换可以用欧拉角旋转实现。\n\n先计算输入应该使角色旋转多少°（即相对与相机的旋转角度），再将这个值和相机旋转相加，得到世界坐标中应该旋转的值（因为Character Controller中的Move方法是相对与世界坐标系定义的）。这里的mainCamera就是现在游戏中正在起作用的相机!\n\n```Csharp\n   targetRotation = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg + mainCamera.transform.rotation.eulerAngles.y;\n   // mainCamera = GameObject.FindGameObjectWithTag(\"MainCamera\");在awake中得到\n```\n\n有了最关键的移动方向，角色旋转和移动就很好实现了。\n\n### Bug\n\n在一开始的实现中，我将角色移动和旋转和相机旋转都放进了Update中，产生了奇怪的bug，发现原因是角色的旋转会带动其子物体cameraLookAt的旋转，导致角色旋转会带动玩家视角旋转，天旋地转。因此相机的旋转应该不受角色旋转的影响，只受玩家鼠标移动的控制。但是unity中子物体必然跟随父物体旋转，一个思路就是在角色旋转后，将相机再旋转回去，由于我们的旋转都是相对与世界坐标系的旋转，因此可以相机旋转放在LateUpdate中，在角色旋转后，再对相机进行旋转（这里容易产生误解，因为旋转是一个变换，其实在实现一个旋转时，每一帧都是从初始位置开始旋转的，只是旋转的角度不断增加产生旋转的效果，**角色旋转后再对相机旋转，不需要向反方向旋转，因为相机还是从初始位置开始旋转，旋转的角度完全由鼠标移动控制**）\n\n### 角色跳跃\n\n角色跳跃基于Character Controller组件的isGrounded，当角色在地面时才能跳跃，给予角色一个向上的速度即可，这个速度通过 **v^2 = 2gh** 计算，这样可以方便控制角色跳跃的高度。\n\nCharacter Controller并没有实现角色重力，要自己实现，只需要检测当角色不在地面时，给角色一个向下的速度，这个速度由 **v=gt** 累加计算得来。\n\n```Csharp\nif(characterController.isGrounded){\n   if(verticalSpeed < -1) verticalSpeed = -1;  // 当角色落地后将竖直速度置零\n}else{\n   verticalSpeed += gravity * Time.deltaTime;\n}\n```\n","source":"_posts/[边学边做]DreamGuard.md","raw":"---\ntitle: 【边学边做】DreamGuard\ndate: 2023-03-22\nindex_img: \"/img/bg/Logo.jpg\"\ntags: 【边学边做】\ncategories: \n   -游戏Demo\n---\n\n记录学习unity开发中的各种问题和常见解决方法\n<!-- more -->\n\n# 第三人称角色控制器\n\n在开发DreamGuard的时候，原本打算使用unity自带的第三人称模板，但是发现其实现是基于New Input System，阅读代码出现困难，就想着自己实现一下。\n\n## New Input System\n\n[官方文档](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/index.html)\n\n[视频教程](https://www.bilibili.com/video/BV1tg411j7ni/?spm_id_from=333.880.top_right_bar_window_custom_collection.content.click&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n我对New Input System的理解是unity希望规范开发者对用户输入的处理。New Input System除了实现老版本输入系统的功能外，主要还方便了用户输入设备的切换（如从键盘切换到手柄）以及方便对不同输入模式的切换（如在游戏中空格代表跳跃，在ui界面中空格代表确定）\n\n### 新输入系统的几种用法\n\n![](/article_img/2023-03-22-12-13-16.png)\n\n按照官网的介绍，新输入系统有四种用法，第一种是和老版本输入系统类似的写法；后面三种都需要借助Actions Asset，可以在Project窗口右键创建，可以将其理解为配置输入的界面，通过Actions Asset就可以可视化的将输入分类，实现输入设备的切换和输入模式的切换。同时在配置Actions Asset时可以选择生成一个C#类来方便在代码中直接使用Actions Asset。\n\nunity自带的第三人称模板使用的是第四种，这是一种我认为较为直观的使用方法，借助PlayerInput组件，可以选择要使用的Actions Asset以及输入时的行为，下图中的Behavior。\n\n![](/article_img/2023-03-22-12-25-07.png)\n\n第三人称模板使用的Behavior是[Send Messages](https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html)，这个方法是最简单的物体间的通信方法，他会将信息传递给该物体上附加的所有脚本；[Broadcast Messages](https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html)会将信息传递给附加到该游戏对象及其所有子对象的每个脚本；[Invoke Unity Events](https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html)对每个单独的消息类型使用单独的 UnityEvent；Invoke C Sharp Events和Invoke Unity Events类似，只是会触发一个C#事件。\n\n由于Send Messages效率较低（？还不太懂为啥），所以我自己实现的第三人称控制器使用Invoke Unity Events方法。\n\n这种方法需要配置Events，只需要为每个输入消息配置一个函数，就可以实现当有输入时，直接调用这个函数，使用起来十分方便。\n\n![](/article_img/2023-03-22-12-49-01.png)\n\n## 脚本实现\n\n第三人称控制器需要相机根据玩家鼠标的移动来回旋转，角色的移动是相对与玩家视角的移动（当玩家看向哪，前进方向就是哪），角色的旋转则永远指向角色的移动方向（不会随相机视角的旋转而旋转）。\n\n### 相机旋转\n\n这里的相机使用了Cinemachine系统中的virtual camera，其可以实现跟随角色以及看向角色。\n\n![](/article_img/2023-03-22-12-56-23.png)\n\n由于其会一直看向Look At设置的对象，因此要旋转相机只需要旋转相机看向的这个对象。在角色对象上添加一个空的子物体cameraLookAt，作为相机看向的方向。\n\n![](/article_img/2023-03-22-13-00-16.png)\n\n在Actions Asset中设置输入，获取玩家鼠标的与上一帧的相对移动，由于是相对移动，直接将这个值不断累加并且映射到角度值，就可以得到cameraLookAt这个子物体的旋转值。注意只有在用户有输入时才改变旋转值，否则会导致用户没有输入时旋转值也为0，由旋转回默认方向。\n\n```Csharp\n    private void CameraRotate()\n    {\n        if (lookDirection.sqrMagnitude > 0.1f)\n        {\n            cameraPitch += lookDirection.y;\n            cameraYaw += lookDirection.x;\n        }\n        cameraPitch = ClampAngle(cameraPitch, -70f, 70f);\n        cameraYaw = ClampAngle(cameraYaw, float.MinValue, float.MaxValue);\n\n        cameraLookAt.transform.rotation = Quaternion.Euler(cameraPitch, cameraYaw, 0);\n    }\n```\n\n### 角色移动和旋转\n\n角色移动依靠Character Controller实现。\n\n根据需要，角色需要是相对相机视角的移动，因此不能直接使用输入系统获取的相对与世界坐标系的方向，要将该方向变换到相机坐标系中。由于角色只在XZ平面移动，因此这种变换可以用欧拉角旋转实现。\n\n先计算输入应该使角色旋转多少°（即相对与相机的旋转角度），再将这个值和相机旋转相加，得到世界坐标中应该旋转的值（因为Character Controller中的Move方法是相对与世界坐标系定义的）。这里的mainCamera就是现在游戏中正在起作用的相机!\n\n```Csharp\n   targetRotation = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg + mainCamera.transform.rotation.eulerAngles.y;\n   // mainCamera = GameObject.FindGameObjectWithTag(\"MainCamera\");在awake中得到\n```\n\n有了最关键的移动方向，角色旋转和移动就很好实现了。\n\n### Bug\n\n在一开始的实现中，我将角色移动和旋转和相机旋转都放进了Update中，产生了奇怪的bug，发现原因是角色的旋转会带动其子物体cameraLookAt的旋转，导致角色旋转会带动玩家视角旋转，天旋地转。因此相机的旋转应该不受角色旋转的影响，只受玩家鼠标移动的控制。但是unity中子物体必然跟随父物体旋转，一个思路就是在角色旋转后，将相机再旋转回去，由于我们的旋转都是相对与世界坐标系的旋转，因此可以相机旋转放在LateUpdate中，在角色旋转后，再对相机进行旋转（这里容易产生误解，因为旋转是一个变换，其实在实现一个旋转时，每一帧都是从初始位置开始旋转的，只是旋转的角度不断增加产生旋转的效果，**角色旋转后再对相机旋转，不需要向反方向旋转，因为相机还是从初始位置开始旋转，旋转的角度完全由鼠标移动控制**）\n\n### 角色跳跃\n\n角色跳跃基于Character Controller组件的isGrounded，当角色在地面时才能跳跃，给予角色一个向上的速度即可，这个速度通过 **v^2 = 2gh** 计算，这样可以方便控制角色跳跃的高度。\n\nCharacter Controller并没有实现角色重力，要自己实现，只需要检测当角色不在地面时，给角色一个向下的速度，这个速度由 **v=gt** 累加计算得来。\n\n```Csharp\nif(characterController.isGrounded){\n   if(verticalSpeed < -1) verticalSpeed = -1;  // 当角色落地后将竖直速度置零\n}else{\n   verticalSpeed += gravity * Time.deltaTime;\n}\n```\n","slug":"[边学边做]DreamGuard","published":1,"updated":"2023-04-17T09:45:40.873Z","_id":"clgkjigm4001ow0je7s5qaodk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>记录学习unity开发中的各种问题和常见解决方法</p>\n<span id=\"more\"></span>\n\n<h1 id=\"第三人称角色控制器\"><a href=\"#第三人称角色控制器\" class=\"headerlink\" title=\"第三人称角色控制器\"></a>第三人称角色控制器</h1><p>在开发DreamGuard的时候，原本打算使用unity自带的第三人称模板，但是发现其实现是基于New Input System，阅读代码出现困难，就想着自己实现一下。</p>\n<h2 id=\"New-Input-System\"><a href=\"#New-Input-System\" class=\"headerlink\" title=\"New Input System\"></a>New Input System</h2><p><a href=\"https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/index.html\">官方文档</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1tg411j7ni/?spm_id_from=333.880.top_right_bar_window_custom_collection.content.click&vd_source=93b215eab72b2548f75d0772e28f8b20\">视频教程</a></p>\n<p>我对New Input System的理解是unity希望规范开发者对用户输入的处理。New Input System除了实现老版本输入系统的功能外，主要还方便了用户输入设备的切换（如从键盘切换到手柄）以及方便对不同输入模式的切换（如在游戏中空格代表跳跃，在ui界面中空格代表确定）</p>\n<h3 id=\"新输入系统的几种用法\"><a href=\"#新输入系统的几种用法\" class=\"headerlink\" title=\"新输入系统的几种用法\"></a>新输入系统的几种用法</h3><p><img src=\"/article_img/2023-03-22-12-13-16.png\"></p>\n<p>按照官网的介绍，新输入系统有四种用法，第一种是和老版本输入系统类似的写法；后面三种都需要借助Actions Asset，可以在Project窗口右键创建，可以将其理解为配置输入的界面，通过Actions Asset就可以可视化的将输入分类，实现输入设备的切换和输入模式的切换。同时在配置Actions Asset时可以选择生成一个C#类来方便在代码中直接使用Actions Asset。</p>\n<p>unity自带的第三人称模板使用的是第四种，这是一种我认为较为直观的使用方法，借助PlayerInput组件，可以选择要使用的Actions Asset以及输入时的行为，下图中的Behavior。</p>\n<p><img src=\"/article_img/2023-03-22-12-25-07.png\"></p>\n<p>第三人称模板使用的Behavior是<a href=\"https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html\">Send Messages</a>，这个方法是最简单的物体间的通信方法，他会将信息传递给该物体上附加的所有脚本；<a href=\"https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html\">Broadcast Messages</a>会将信息传递给附加到该游戏对象及其所有子对象的每个脚本；<a href=\"https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html\">Invoke Unity Events</a>对每个单独的消息类型使用单独的 UnityEvent；Invoke C Sharp Events和Invoke Unity Events类似，只是会触发一个C#事件。</p>\n<p>由于Send Messages效率较低（？还不太懂为啥），所以我自己实现的第三人称控制器使用Invoke Unity Events方法。</p>\n<p>这种方法需要配置Events，只需要为每个输入消息配置一个函数，就可以实现当有输入时，直接调用这个函数，使用起来十分方便。</p>\n<p><img src=\"/article_img/2023-03-22-12-49-01.png\"></p>\n<h2 id=\"脚本实现\"><a href=\"#脚本实现\" class=\"headerlink\" title=\"脚本实现\"></a>脚本实现</h2><p>第三人称控制器需要相机根据玩家鼠标的移动来回旋转，角色的移动是相对与玩家视角的移动（当玩家看向哪，前进方向就是哪），角色的旋转则永远指向角色的移动方向（不会随相机视角的旋转而旋转）。</p>\n<h3 id=\"相机旋转\"><a href=\"#相机旋转\" class=\"headerlink\" title=\"相机旋转\"></a>相机旋转</h3><p>这里的相机使用了Cinemachine系统中的virtual camera，其可以实现跟随角色以及看向角色。</p>\n<p><img src=\"/article_img/2023-03-22-12-56-23.png\"></p>\n<p>由于其会一直看向Look At设置的对象，因此要旋转相机只需要旋转相机看向的这个对象。在角色对象上添加一个空的子物体cameraLookAt，作为相机看向的方向。</p>\n<p><img src=\"/article_img/2023-03-22-13-00-16.png\"></p>\n<p>在Actions Asset中设置输入，获取玩家鼠标的与上一帧的相对移动，由于是相对移动，直接将这个值不断累加并且映射到角度值，就可以得到cameraLookAt这个子物体的旋转值。注意只有在用户有输入时才改变旋转值，否则会导致用户没有输入时旋转值也为0，由旋转回默认方向。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Csharp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CameraRotate</span>()</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span> (lookDirection.sqrMagnitude &gt; <span class=\"hljs-number\">0.1f</span>)<br>    &#123;<br>        cameraPitch += lookDirection.y;<br>        cameraYaw += lookDirection.x;<br>    &#125;<br>    cameraPitch = ClampAngle(cameraPitch, <span class=\"hljs-number\">-70f</span>, <span class=\"hljs-number\">70f</span>);<br>    cameraYaw = ClampAngle(cameraYaw, <span class=\"hljs-built_in\">float</span>.MinValue, <span class=\"hljs-built_in\">float</span>.MaxValue);<br><br>    cameraLookAt.transform.rotation = Quaternion.Euler(cameraPitch, cameraYaw, <span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"角色移动和旋转\"><a href=\"#角色移动和旋转\" class=\"headerlink\" title=\"角色移动和旋转\"></a>角色移动和旋转</h3><p>角色移动依靠Character Controller实现。</p>\n<p>根据需要，角色需要是相对相机视角的移动，因此不能直接使用输入系统获取的相对与世界坐标系的方向，要将该方向变换到相机坐标系中。由于角色只在XZ平面移动，因此这种变换可以用欧拉角旋转实现。</p>\n<p>先计算输入应该使角色旋转多少°（即相对与相机的旋转角度），再将这个值和相机旋转相加，得到世界坐标中应该旋转的值（因为Character Controller中的Move方法是相对与世界坐标系定义的）。这里的mainCamera就是现在游戏中正在起作用的相机!</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Csharp\">targetRotation = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg + mainCamera.transform.rotation.eulerAngles.y;<br><span class=\"hljs-comment\">// mainCamera = GameObject.FindGameObjectWithTag(&quot;MainCamera&quot;);在awake中得到</span><br></code></pre></td></tr></table></figure>\n\n<p>有了最关键的移动方向，角色旋转和移动就很好实现了。</p>\n<h3 id=\"Bug\"><a href=\"#Bug\" class=\"headerlink\" title=\"Bug\"></a>Bug</h3><p>在一开始的实现中，我将角色移动和旋转和相机旋转都放进了Update中，产生了奇怪的bug，发现原因是角色的旋转会带动其子物体cameraLookAt的旋转，导致角色旋转会带动玩家视角旋转，天旋地转。因此相机的旋转应该不受角色旋转的影响，只受玩家鼠标移动的控制。但是unity中子物体必然跟随父物体旋转，一个思路就是在角色旋转后，将相机再旋转回去，由于我们的旋转都是相对与世界坐标系的旋转，因此可以相机旋转放在LateUpdate中，在角色旋转后，再对相机进行旋转（这里容易产生误解，因为旋转是一个变换，其实在实现一个旋转时，每一帧都是从初始位置开始旋转的，只是旋转的角度不断增加产生旋转的效果，<strong>角色旋转后再对相机旋转，不需要向反方向旋转，因为相机还是从初始位置开始旋转，旋转的角度完全由鼠标移动控制</strong>）</p>\n<h3 id=\"角色跳跃\"><a href=\"#角色跳跃\" class=\"headerlink\" title=\"角色跳跃\"></a>角色跳跃</h3><p>角色跳跃基于Character Controller组件的isGrounded，当角色在地面时才能跳跃，给予角色一个向上的速度即可，这个速度通过 <strong>v^2 &#x3D; 2gh</strong> 计算，这样可以方便控制角色跳跃的高度。</p>\n<p>Character Controller并没有实现角色重力，要自己实现，只需要检测当角色不在地面时，给角色一个向下的速度，这个速度由 <strong>v&#x3D;gt</strong> 累加计算得来。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Csharp\"><span class=\"hljs-keyword\">if</span>(characterController.isGrounded)&#123;<br>   <span class=\"hljs-keyword\">if</span>(verticalSpeed &lt; <span class=\"hljs-number\">-1</span>) verticalSpeed = <span class=\"hljs-number\">-1</span>;  <span class=\"hljs-comment\">// 当角色落地后将竖直速度置零</span><br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>   verticalSpeed += gravity * Time.deltaTime;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"wordcount":2790,"excerpt":"<p>记录学习unity开发中的各种问题和常见解决方法</p>","more":"<h1 id=\"第三人称角色控制器\"><a href=\"#第三人称角色控制器\" class=\"headerlink\" title=\"第三人称角色控制器\"></a>第三人称角色控制器</h1><p>在开发DreamGuard的时候，原本打算使用unity自带的第三人称模板，但是发现其实现是基于New Input System，阅读代码出现困难，就想着自己实现一下。</p>\n<h2 id=\"New-Input-System\"><a href=\"#New-Input-System\" class=\"headerlink\" title=\"New Input System\"></a>New Input System</h2><p><a href=\"https://docs.unity3d.com/Packages/com.unity.inputsystem@1.5/manual/index.html\">官方文档</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV1tg411j7ni/?spm_id_from=333.880.top_right_bar_window_custom_collection.content.click&vd_source=93b215eab72b2548f75d0772e28f8b20\">视频教程</a></p>\n<p>我对New Input System的理解是unity希望规范开发者对用户输入的处理。New Input System除了实现老版本输入系统的功能外，主要还方便了用户输入设备的切换（如从键盘切换到手柄）以及方便对不同输入模式的切换（如在游戏中空格代表跳跃，在ui界面中空格代表确定）</p>\n<h3 id=\"新输入系统的几种用法\"><a href=\"#新输入系统的几种用法\" class=\"headerlink\" title=\"新输入系统的几种用法\"></a>新输入系统的几种用法</h3><p><img src=\"/article_img/2023-03-22-12-13-16.png\"></p>\n<p>按照官网的介绍，新输入系统有四种用法，第一种是和老版本输入系统类似的写法；后面三种都需要借助Actions Asset，可以在Project窗口右键创建，可以将其理解为配置输入的界面，通过Actions Asset就可以可视化的将输入分类，实现输入设备的切换和输入模式的切换。同时在配置Actions Asset时可以选择生成一个C#类来方便在代码中直接使用Actions Asset。</p>\n<p>unity自带的第三人称模板使用的是第四种，这是一种我认为较为直观的使用方法，借助PlayerInput组件，可以选择要使用的Actions Asset以及输入时的行为，下图中的Behavior。</p>\n<p><img src=\"/article_img/2023-03-22-12-25-07.png\"></p>\n<p>第三人称模板使用的Behavior是<a href=\"https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html\">Send Messages</a>，这个方法是最简单的物体间的通信方法，他会将信息传递给该物体上附加的所有脚本；<a href=\"https://docs.unity3d.com/ScriptReference/GameObject.BroadcastMessage.html\">Broadcast Messages</a>会将信息传递给附加到该游戏对象及其所有子对象的每个脚本；<a href=\"https://docs.unity3d.com/ScriptReference/Events.UnityEvent.html\">Invoke Unity Events</a>对每个单独的消息类型使用单独的 UnityEvent；Invoke C Sharp Events和Invoke Unity Events类似，只是会触发一个C#事件。</p>\n<p>由于Send Messages效率较低（？还不太懂为啥），所以我自己实现的第三人称控制器使用Invoke Unity Events方法。</p>\n<p>这种方法需要配置Events，只需要为每个输入消息配置一个函数，就可以实现当有输入时，直接调用这个函数，使用起来十分方便。</p>\n<p><img src=\"/article_img/2023-03-22-12-49-01.png\"></p>\n<h2 id=\"脚本实现\"><a href=\"#脚本实现\" class=\"headerlink\" title=\"脚本实现\"></a>脚本实现</h2><p>第三人称控制器需要相机根据玩家鼠标的移动来回旋转，角色的移动是相对与玩家视角的移动（当玩家看向哪，前进方向就是哪），角色的旋转则永远指向角色的移动方向（不会随相机视角的旋转而旋转）。</p>\n<h3 id=\"相机旋转\"><a href=\"#相机旋转\" class=\"headerlink\" title=\"相机旋转\"></a>相机旋转</h3><p>这里的相机使用了Cinemachine系统中的virtual camera，其可以实现跟随角色以及看向角色。</p>\n<p><img src=\"/article_img/2023-03-22-12-56-23.png\"></p>\n<p>由于其会一直看向Look At设置的对象，因此要旋转相机只需要旋转相机看向的这个对象。在角色对象上添加一个空的子物体cameraLookAt，作为相机看向的方向。</p>\n<p><img src=\"/article_img/2023-03-22-13-00-16.png\"></p>\n<p>在Actions Asset中设置输入，获取玩家鼠标的与上一帧的相对移动，由于是相对移动，直接将这个值不断累加并且映射到角度值，就可以得到cameraLookAt这个子物体的旋转值。注意只有在用户有输入时才改变旋转值，否则会导致用户没有输入时旋转值也为0，由旋转回默认方向。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Csharp\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CameraRotate</span>()</span><br>&#123;<br>    <span class=\"hljs-keyword\">if</span> (lookDirection.sqrMagnitude &gt; <span class=\"hljs-number\">0.1f</span>)<br>    &#123;<br>        cameraPitch += lookDirection.y;<br>        cameraYaw += lookDirection.x;<br>    &#125;<br>    cameraPitch = ClampAngle(cameraPitch, <span class=\"hljs-number\">-70f</span>, <span class=\"hljs-number\">70f</span>);<br>    cameraYaw = ClampAngle(cameraYaw, <span class=\"hljs-built_in\">float</span>.MinValue, <span class=\"hljs-built_in\">float</span>.MaxValue);<br><br>    cameraLookAt.transform.rotation = Quaternion.Euler(cameraPitch, cameraYaw, <span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"角色移动和旋转\"><a href=\"#角色移动和旋转\" class=\"headerlink\" title=\"角色移动和旋转\"></a>角色移动和旋转</h3><p>角色移动依靠Character Controller实现。</p>\n<p>根据需要，角色需要是相对相机视角的移动，因此不能直接使用输入系统获取的相对与世界坐标系的方向，要将该方向变换到相机坐标系中。由于角色只在XZ平面移动，因此这种变换可以用欧拉角旋转实现。</p>\n<p>先计算输入应该使角色旋转多少°（即相对与相机的旋转角度），再将这个值和相机旋转相加，得到世界坐标中应该旋转的值（因为Character Controller中的Move方法是相对与世界坐标系定义的）。这里的mainCamera就是现在游戏中正在起作用的相机!</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Csharp\">targetRotation = Mathf.Atan2(moveDirection.x, moveDirection.z) * Mathf.Rad2Deg + mainCamera.transform.rotation.eulerAngles.y;<br><span class=\"hljs-comment\">// mainCamera = GameObject.FindGameObjectWithTag(&quot;MainCamera&quot;);在awake中得到</span><br></code></pre></td></tr></table></figure>\n\n<p>有了最关键的移动方向，角色旋转和移动就很好实现了。</p>\n<h3 id=\"Bug\"><a href=\"#Bug\" class=\"headerlink\" title=\"Bug\"></a>Bug</h3><p>在一开始的实现中，我将角色移动和旋转和相机旋转都放进了Update中，产生了奇怪的bug，发现原因是角色的旋转会带动其子物体cameraLookAt的旋转，导致角色旋转会带动玩家视角旋转，天旋地转。因此相机的旋转应该不受角色旋转的影响，只受玩家鼠标移动的控制。但是unity中子物体必然跟随父物体旋转，一个思路就是在角色旋转后，将相机再旋转回去，由于我们的旋转都是相对与世界坐标系的旋转，因此可以相机旋转放在LateUpdate中，在角色旋转后，再对相机进行旋转（这里容易产生误解，因为旋转是一个变换，其实在实现一个旋转时，每一帧都是从初始位置开始旋转的，只是旋转的角度不断增加产生旋转的效果，<strong>角色旋转后再对相机旋转，不需要向反方向旋转，因为相机还是从初始位置开始旋转，旋转的角度完全由鼠标移动控制</strong>）</p>\n<h3 id=\"角色跳跃\"><a href=\"#角色跳跃\" class=\"headerlink\" title=\"角色跳跃\"></a>角色跳跃</h3><p>角色跳跃基于Character Controller组件的isGrounded，当角色在地面时才能跳跃，给予角色一个向上的速度即可，这个速度通过 <strong>v^2 &#x3D; 2gh</strong> 计算，这样可以方便控制角色跳跃的高度。</p>\n<p>Character Controller并没有实现角色重力，要自己实现，只需要检测当角色不在地面时，给角色一个向下的速度，这个速度由 <strong>v&#x3D;gt</strong> 累加计算得来。</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Csharp\"><span class=\"hljs-keyword\">if</span>(characterController.isGrounded)&#123;<br>   <span class=\"hljs-keyword\">if</span>(verticalSpeed &lt; <span class=\"hljs-number\">-1</span>) verticalSpeed = <span class=\"hljs-number\">-1</span>;  <span class=\"hljs-comment\">// 当角色落地后将竖直速度置零</span><br>&#125;<span class=\"hljs-keyword\">else</span>&#123;<br>   verticalSpeed += gravity * Time.deltaTime;<br>&#125;<br></code></pre></td></tr></table></figure>"},{"title":"Hello World","hide":true,"_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\nhide: true\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"date":"2022-09-24T10:31:31.239Z","updated":"2022-09-24T10:44:01.131Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigm5001sw0jehdje16s9","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"wordcount":367,"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo new <span class=\"hljs-string\">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo server<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ hexo deploy<br></code></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"learnopengl-1-你好三角形","date":"2022-10-26T16:00:00.000Z","index_img":"/img/bg/opengl.jpg","_content":"\nlearnopengl-1-你好三角形\n<!-- more -->\n\n[你好，三角形-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_7)\n\n[傅老師/OpenGL教學 第一章](https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n环境的搭建和窗口的生成有时间之后补上。\n\n本篇笔记先按照网站的顺序梳理一边基本概念，之后结合傅老师的讲解，**串联**所有概念和步骤。\n\n# OpenGL的图形渲染管线（Graphics Pipline）\n\n![](/article_img/2022-10-24-14-28-44.png)\n\n图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。\n\n1. 顶点着色器（Vertex Shader）：顶点着色器主要的目的是把3D坐标转为另一种3D坐标；\n2. 图元装配（Primitive Assembly）：将顶点着色器输出的所有顶点装配成指定图元的形状；\n3. 几何着色器（Geometry Shader）：几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状；\n4. 光栅化（Rasterization Stage）：把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)；\n5. 片段着色器（Fragment Shader）：计算一个像素的最终颜色；\n6. 测试和混合（Test and Blending）：检测深度决定哪些片段被舍弃，以及检查alpha值对物体进行混合；\n\n# 顶点输入\n\n![](/article_img/2022-10-24-14-47-45.png)\n\n定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。\n\n## VBO（顶点缓冲对象）\n\nVBO用来储存输入的一大堆顶点数据，可以一次性将一大批数据发送到显卡上。\n\n以下代码就是VBO的基本定义和使用方法。\n```C++\nunsigned int VBO;\nglGenBuffers(1, &VBO); // 生成\nglBindBudder(GL_ARRAY_BUFFER, VBO);  // 绑定到状态机\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);  // 加数据\n```\n\n## EBO（元素缓冲对象）\n\n这个本来是在教程最后讲解的，但是EBO也是对输入的顶点数据进行处理的对象。\n\nEBO简单来说就是用来解决顶点重复定义的问题。\n\n假如现在要通过绘制两个三角形的方法绘制一个矩形，如果没有EBO，需要定义如下顶点集合：\n```c++\nfloat vertices[] = {\n    // 第一个三角形\n    0.5f, 0.5f, 0.0f,   // 右上角\n    0.5f, -0.5f, 0.0f,  // 右下角\n    -0.5f, 0.5f, 0.0f,  // 左上角\n    // 第二个三角形\n    0.5f, -0.5f, 0.0f,  // 右下角\n    -0.5f, -0.5f, 0.0f, // 左下角\n    -0.5f, 0.5f, 0.0f   // 左上角\n};\n```\n可以看到有一些相同的顶点被重复定义了，而EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。\n```c++\nfloat vertices[] = {\n    0.5f, 0.5f, 0.0f,   // 右上角\n    0.5f, -0.5f, 0.0f,  // 右下角\n    -0.5f, -0.5f, 0.0f, // 左下角\n    -0.5f, 0.5f, 0.0f   // 左上角\n};\n\nunsigned int indices[] = {\n    // 注意索引从0开始! \n    // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，\n    // 这样可以由下标代表顶点组合成矩形\n\n    0, 1, 3, // 第一个三角形\n    1, 2, 3  // 第二个三角形\n};\n```\n之后EBO的使用也和VBO类似，之后在渲染循环中，将glDrawArrays()替换成glDrawElements()\n```C++\nunsigned int EBO;\nglGenBuffers(1, &EBO); // 生成\nglBindBudder(GL_ELEMENT_ARRAY_BUFFER, EBO);  // 绑定到状态机\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);  // 加数据\n/*\n...\n*/\n// 渲染循环中\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\n```\n\n# 着色器\n\n## 顶点着色器\nshader语法和编写在下一节具体展开，这里只简单介绍shader如何配置。\n\n和之前的VBO和EBO类似，也需要先定义一个shader编号，之后生成shader，告诉生成的shader源码是哪些，最后编译shader\n\n```c++\nunsigned int vertexShader;\nvertexShader = glCreateShader(GL_VERTEX_SHADER);\n\nglShaderSource(vertexShader, 1, &vertexShaderSource, NULL);\nglCompileShader(vertexShader);\n```\n\n## 片段着色器\n\n和顶点着色器完全一样的用法\n```c++\nunsigned int fragmentShader;\nfragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n\nglShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);\nglCompileShader(fragmentShader);\n```\n\n## 着色器程序对象\n\n之前编译好的两个着色器并不能直接使用，需要将其合并（代码上体现出来就是将之前两个shader附加到着色器程序上），之后链接成一个着色器程序对象，在渲染时激活这个着色器程序。\n\n```c++\nunsigned int shaderProgram;\nshaderProgram = glCreateProgram(); // 经典创建对象\n\n// 附加（合并）shader到shaderProgram上\nglAttachShader(shaderProgram, vertexShader);\nglAttachShader(shaderProgram, fragmentShader);\nglLinkProgram(shaderProgram); // 链接shader\n\n// 渲染循环中\nglUseProgram(shaderProgram);\n```\n\n在把着色器对象链接到程序对象之后，就可以删除着色器对象了\n\n# 链接顶点属性\n\n这部分在第一次读的时候较难理解，之后结合[傅老師/OpenGL教學 第一章](https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20)才理解。\n\n我们之前定义了VBO来将一堆顶点数据输入GPU，但是GPU其实并不知道这些顶点数据的含义，glVertexAttribPointer函数就是为了告知GPU如何正确理解这些“杂乱”的顶点信息的。\n\n\n```c++\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);\n```\n\n# 顶点数组对象(VAO)\n\nVAO使得当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。\n\n![](/article_img/2022-10-27-14-16-43.png)\n\n![](/article_img/2022-10-27-14-21-46.png)\n\n由以上图可以看出VAO包含很多attribute pointer和一个EBO，且可以看出真正储存顶点信息的是一个个的VBO，VAO中存储着如何去解释VBO中数据的顶点属性指针和EBO。\n\n## 深入理解VAO和VBO\n\n[如何正确理解OpenGL的VAO?](https://www.zhihu.com/question/30095978/answer/2362612406)\n\n可以使用一个VAO绑定多个VBO但是要**注意**：  \n多个VBO中的顶点信息不能重复，如VBO1中存储所有的顶点位置信息，VBO2中存储所有的颜色信息，不能VBO1和VBO2都存储位置信息。\n\n如果混合存储，如下图，绑定VBO2的时候会覆盖掉之前绑定的VBO1；\n```c++\nfloat triangle[] = { // VBO1的data\n   // 位置              // 颜色\n   0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下\n   -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下\n   0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部\n};\nfloat triangle2[] = { // VBO2的data\n   // 位置              // 颜色\n   0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f, \n   0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f, \n   0.5f, 0.5f, 0.0f,  0.0f, 1.0f, 0.0f   \n};\n```\n![](/article_img/2022-10-28-19-32-16.png)\n\n\n将顶点信息和颜色信息分别存入到VBO1和VBO2中，再将VBO1和VBO2绑定在VAO上就可以正常显示两个三角形；\n\n```c++\nfloat triangles[] = {  // VBO1的data\n   0.5f, -0.5f, 0.0f,\n   -0.5f, -0.5f, 0.0f,\n   0.0f,  0.5f, 0.0f,\n   0.5f, -0.5f, 0.0f,\n   0.0f,  0.5f, 0.0f,\n   0.5f, 0.5f, 0.0f\n};\nfloat colors[] = {   // VBO2的data\n   1.0f, 0.0f, 0.0f,\n   0.0f, 1.0f, 0.0f,\n   0.0f, 0.0f, 1.0f,\n   1.0f, 0.0f, 0.0f,\n   0.0f, 0.0f, 1.0f,\n   0.0f, 1.0f, 0.0f\n};\n```\n\n![](/article_img/2022-10-28-19-37-42.png)\n\n要先绑定VAO，再绑定EBO，否则会出错。\n\n```c++\nunsigned int VAO;\nglGenVertexArrays(1, &VAO);\nglBindVertexArray(VAO);\n```\n\n# 总结\n\n![](/article_img/2022-10-27-15-12-46.png)\n\n首先要理解OpenGL采用状态机架构，所以绑定就意味着使用。\n\n![](/article_img/2022-10-27-14-53-13.png)\n\n# 练习\n\n1. 添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形\n   ![](/article_img/2022-10-27-15-32-33.png)\n\n   关键代码：\n   ```c++\n   float triangle[] = {\n      -1.0f, -0.5f, 0.0f,\n      0.0f, -0.5f, 0.0f,\n      -0.5f, 0.5f, 0.0f,\n      0.0f, -0.5f, 0.0f,\n      1.0f, -0.5f, 0.0f,\n      0.5f, 0.5f, 0.0f\n   };\n\n   // 渲染循环\n   glDrawArrays(GL_TRIANGLES, 0, 6);\n   ```\n2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO\n   ![](/article_img/2022-10-27-15-54-08.png)\n\n   关键代码：  \n   这里要注意要分别为两个VAO设置顶点属性，两个VAO该怎样处理VBO中的数据都要分别告知。\n   ```c++\n   unsigned int VAO[2], VBO[2];\n   glGenBuffers(2, VBO);\n   glGenVertexArrays(2, VAO);\n\n   glBindVertexArray(VAO[0]);\n   glBindBuffer(GL_ARRAY_BUFFER, VBO[0]);\n   glBufferData(GL_ARRAY_BUFFER, sizeof(triangle1), triangle1, GL_STATIC_DRAW);\n   // 为VAO[0]设置顶点属性\n   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n   glEnableVertexAttribArray(0);\n\n\n   glBindVertexArray(VAO[1]);\n   glBindBuffer(GL_ARRAY_BUFFER, VBO[1]);\n   glBufferData(GL_ARRAY_BUFFER, sizeof(triangle2), triangle2, GL_STATIC_DRAW);\n   // 为VAO[1]设置顶点属性\n   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n   glEnableVertexAttribArray(0);\n\n   // 渲染循环\n   glBindVertexArray(VAO[0]);\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n\n   glBindVertexArray(VAO[1]);\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n   ```\n3. 创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色\n   ![](/article_img/2022-10-27-16-10-17.png)\n   关键代码：  \n   ```c++\n   // 渲染循环\n   glUseProgram(shaderProgram1);\n   glBindVertexArray(VAO[0]);\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n\n   glUseProgram(shaderProgram2);\n   glBindVertexArray(VAO[1]);\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n   ```","source":"_posts/learnopengl-1-你好三角形.md","raw":"---\ntitle: learnopengl-1-你好三角形\ndate: 2022-10-27\nindex_img: \"/img/bg/opengl.jpg\"\ntags: [OpenGL]\ncategories: \n   -[OpenGL笔记]\n---\n\nlearnopengl-1-你好三角形\n<!-- more -->\n\n[你好，三角形-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_7)\n\n[傅老師/OpenGL教學 第一章](https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n环境的搭建和窗口的生成有时间之后补上。\n\n本篇笔记先按照网站的顺序梳理一边基本概念，之后结合傅老师的讲解，**串联**所有概念和步骤。\n\n# OpenGL的图形渲染管线（Graphics Pipline）\n\n![](/article_img/2022-10-24-14-28-44.png)\n\n图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。\n\n1. 顶点着色器（Vertex Shader）：顶点着色器主要的目的是把3D坐标转为另一种3D坐标；\n2. 图元装配（Primitive Assembly）：将顶点着色器输出的所有顶点装配成指定图元的形状；\n3. 几何着色器（Geometry Shader）：几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状；\n4. 光栅化（Rasterization Stage）：把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)；\n5. 片段着色器（Fragment Shader）：计算一个像素的最终颜色；\n6. 测试和混合（Test and Blending）：检测深度决定哪些片段被舍弃，以及检查alpha值对物体进行混合；\n\n# 顶点输入\n\n![](/article_img/2022-10-24-14-47-45.png)\n\n定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。\n\n## VBO（顶点缓冲对象）\n\nVBO用来储存输入的一大堆顶点数据，可以一次性将一大批数据发送到显卡上。\n\n以下代码就是VBO的基本定义和使用方法。\n```C++\nunsigned int VBO;\nglGenBuffers(1, &VBO); // 生成\nglBindBudder(GL_ARRAY_BUFFER, VBO);  // 绑定到状态机\nglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);  // 加数据\n```\n\n## EBO（元素缓冲对象）\n\n这个本来是在教程最后讲解的，但是EBO也是对输入的顶点数据进行处理的对象。\n\nEBO简单来说就是用来解决顶点重复定义的问题。\n\n假如现在要通过绘制两个三角形的方法绘制一个矩形，如果没有EBO，需要定义如下顶点集合：\n```c++\nfloat vertices[] = {\n    // 第一个三角形\n    0.5f, 0.5f, 0.0f,   // 右上角\n    0.5f, -0.5f, 0.0f,  // 右下角\n    -0.5f, 0.5f, 0.0f,  // 左上角\n    // 第二个三角形\n    0.5f, -0.5f, 0.0f,  // 右下角\n    -0.5f, -0.5f, 0.0f, // 左下角\n    -0.5f, 0.5f, 0.0f   // 左上角\n};\n```\n可以看到有一些相同的顶点被重复定义了，而EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。\n```c++\nfloat vertices[] = {\n    0.5f, 0.5f, 0.0f,   // 右上角\n    0.5f, -0.5f, 0.0f,  // 右下角\n    -0.5f, -0.5f, 0.0f, // 左下角\n    -0.5f, 0.5f, 0.0f   // 左上角\n};\n\nunsigned int indices[] = {\n    // 注意索引从0开始! \n    // 此例的索引(0,1,2,3)就是顶点数组vertices的下标，\n    // 这样可以由下标代表顶点组合成矩形\n\n    0, 1, 3, // 第一个三角形\n    1, 2, 3  // 第二个三角形\n};\n```\n之后EBO的使用也和VBO类似，之后在渲染循环中，将glDrawArrays()替换成glDrawElements()\n```C++\nunsigned int EBO;\nglGenBuffers(1, &EBO); // 生成\nglBindBudder(GL_ELEMENT_ARRAY_BUFFER, EBO);  // 绑定到状态机\nglBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);  // 加数据\n/*\n...\n*/\n// 渲染循环中\nglBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\n```\n\n# 着色器\n\n## 顶点着色器\nshader语法和编写在下一节具体展开，这里只简单介绍shader如何配置。\n\n和之前的VBO和EBO类似，也需要先定义一个shader编号，之后生成shader，告诉生成的shader源码是哪些，最后编译shader\n\n```c++\nunsigned int vertexShader;\nvertexShader = glCreateShader(GL_VERTEX_SHADER);\n\nglShaderSource(vertexShader, 1, &vertexShaderSource, NULL);\nglCompileShader(vertexShader);\n```\n\n## 片段着色器\n\n和顶点着色器完全一样的用法\n```c++\nunsigned int fragmentShader;\nfragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n\nglShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);\nglCompileShader(fragmentShader);\n```\n\n## 着色器程序对象\n\n之前编译好的两个着色器并不能直接使用，需要将其合并（代码上体现出来就是将之前两个shader附加到着色器程序上），之后链接成一个着色器程序对象，在渲染时激活这个着色器程序。\n\n```c++\nunsigned int shaderProgram;\nshaderProgram = glCreateProgram(); // 经典创建对象\n\n// 附加（合并）shader到shaderProgram上\nglAttachShader(shaderProgram, vertexShader);\nglAttachShader(shaderProgram, fragmentShader);\nglLinkProgram(shaderProgram); // 链接shader\n\n// 渲染循环中\nglUseProgram(shaderProgram);\n```\n\n在把着色器对象链接到程序对象之后，就可以删除着色器对象了\n\n# 链接顶点属性\n\n这部分在第一次读的时候较难理解，之后结合[傅老師/OpenGL教學 第一章](https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20)才理解。\n\n我们之前定义了VBO来将一堆顶点数据输入GPU，但是GPU其实并不知道这些顶点数据的含义，glVertexAttribPointer函数就是为了告知GPU如何正确理解这些“杂乱”的顶点信息的。\n\n\n```c++\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\nglEnableVertexAttribArray(0);\n```\n\n# 顶点数组对象(VAO)\n\nVAO使得当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。\n\n![](/article_img/2022-10-27-14-16-43.png)\n\n![](/article_img/2022-10-27-14-21-46.png)\n\n由以上图可以看出VAO包含很多attribute pointer和一个EBO，且可以看出真正储存顶点信息的是一个个的VBO，VAO中存储着如何去解释VBO中数据的顶点属性指针和EBO。\n\n## 深入理解VAO和VBO\n\n[如何正确理解OpenGL的VAO?](https://www.zhihu.com/question/30095978/answer/2362612406)\n\n可以使用一个VAO绑定多个VBO但是要**注意**：  \n多个VBO中的顶点信息不能重复，如VBO1中存储所有的顶点位置信息，VBO2中存储所有的颜色信息，不能VBO1和VBO2都存储位置信息。\n\n如果混合存储，如下图，绑定VBO2的时候会覆盖掉之前绑定的VBO1；\n```c++\nfloat triangle[] = { // VBO1的data\n   // 位置              // 颜色\n   0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f,   // 右下\n   -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,   // 左下\n   0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f    // 顶部\n};\nfloat triangle2[] = { // VBO2的data\n   // 位置              // 颜色\n   0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f, \n   0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f, \n   0.5f, 0.5f, 0.0f,  0.0f, 1.0f, 0.0f   \n};\n```\n![](/article_img/2022-10-28-19-32-16.png)\n\n\n将顶点信息和颜色信息分别存入到VBO1和VBO2中，再将VBO1和VBO2绑定在VAO上就可以正常显示两个三角形；\n\n```c++\nfloat triangles[] = {  // VBO1的data\n   0.5f, -0.5f, 0.0f,\n   -0.5f, -0.5f, 0.0f,\n   0.0f,  0.5f, 0.0f,\n   0.5f, -0.5f, 0.0f,\n   0.0f,  0.5f, 0.0f,\n   0.5f, 0.5f, 0.0f\n};\nfloat colors[] = {   // VBO2的data\n   1.0f, 0.0f, 0.0f,\n   0.0f, 1.0f, 0.0f,\n   0.0f, 0.0f, 1.0f,\n   1.0f, 0.0f, 0.0f,\n   0.0f, 0.0f, 1.0f,\n   0.0f, 1.0f, 0.0f\n};\n```\n\n![](/article_img/2022-10-28-19-37-42.png)\n\n要先绑定VAO，再绑定EBO，否则会出错。\n\n```c++\nunsigned int VAO;\nglGenVertexArrays(1, &VAO);\nglBindVertexArray(VAO);\n```\n\n# 总结\n\n![](/article_img/2022-10-27-15-12-46.png)\n\n首先要理解OpenGL采用状态机架构，所以绑定就意味着使用。\n\n![](/article_img/2022-10-27-14-53-13.png)\n\n# 练习\n\n1. 添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形\n   ![](/article_img/2022-10-27-15-32-33.png)\n\n   关键代码：\n   ```c++\n   float triangle[] = {\n      -1.0f, -0.5f, 0.0f,\n      0.0f, -0.5f, 0.0f,\n      -0.5f, 0.5f, 0.0f,\n      0.0f, -0.5f, 0.0f,\n      1.0f, -0.5f, 0.0f,\n      0.5f, 0.5f, 0.0f\n   };\n\n   // 渲染循环\n   glDrawArrays(GL_TRIANGLES, 0, 6);\n   ```\n2. 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO\n   ![](/article_img/2022-10-27-15-54-08.png)\n\n   关键代码：  \n   这里要注意要分别为两个VAO设置顶点属性，两个VAO该怎样处理VBO中的数据都要分别告知。\n   ```c++\n   unsigned int VAO[2], VBO[2];\n   glGenBuffers(2, VBO);\n   glGenVertexArrays(2, VAO);\n\n   glBindVertexArray(VAO[0]);\n   glBindBuffer(GL_ARRAY_BUFFER, VBO[0]);\n   glBufferData(GL_ARRAY_BUFFER, sizeof(triangle1), triangle1, GL_STATIC_DRAW);\n   // 为VAO[0]设置顶点属性\n   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n   glEnableVertexAttribArray(0);\n\n\n   glBindVertexArray(VAO[1]);\n   glBindBuffer(GL_ARRAY_BUFFER, VBO[1]);\n   glBufferData(GL_ARRAY_BUFFER, sizeof(triangle2), triangle2, GL_STATIC_DRAW);\n   // 为VAO[1]设置顶点属性\n   glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\n   glEnableVertexAttribArray(0);\n\n   // 渲染循环\n   glBindVertexArray(VAO[0]);\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n\n   glBindVertexArray(VAO[1]);\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n   ```\n3. 创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色\n   ![](/article_img/2022-10-27-16-10-17.png)\n   关键代码：  \n   ```c++\n   // 渲染循环\n   glUseProgram(shaderProgram1);\n   glBindVertexArray(VAO[0]);\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n\n   glUseProgram(shaderProgram2);\n   glBindVertexArray(VAO[1]);\n   glDrawArrays(GL_TRIANGLES, 0, 3);\n   ```","slug":"learnopengl-1-你好三角形","published":1,"updated":"2023-01-17T04:05:42.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigm6001vw0je7iqi1ucu","content":"<p>learnopengl-1-你好三角形</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_7\">你好，三角形-LearnOpenGL CN</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20\">傅老師&#x2F;OpenGL教學 第一章</a></p>\n<p>环境的搭建和窗口的生成有时间之后补上。</p>\n<p>本篇笔记先按照网站的顺序梳理一边基本概念，之后结合傅老师的讲解，<strong>串联</strong>所有概念和步骤。</p>\n<h1 id=\"OpenGL的图形渲染管线（Graphics-Pipline）\"><a href=\"#OpenGL的图形渲染管线（Graphics-Pipline）\" class=\"headerlink\" title=\"OpenGL的图形渲染管线（Graphics Pipline）\"></a>OpenGL的图形渲染管线（Graphics Pipline）</h1><p><img src=\"/article_img/2022-10-24-14-28-44.png\"></p>\n<p>图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>\n<ol>\n<li>顶点着色器（Vertex Shader）：顶点着色器主要的目的是把3D坐标转为另一种3D坐标；</li>\n<li>图元装配（Primitive Assembly）：将顶点着色器输出的所有顶点装配成指定图元的形状；</li>\n<li>几何着色器（Geometry Shader）：几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状；</li>\n<li>光栅化（Rasterization Stage）：把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)；</li>\n<li>片段着色器（Fragment Shader）：计算一个像素的最终颜色；</li>\n<li>测试和混合（Test and Blending）：检测深度决定哪些片段被舍弃，以及检查alpha值对物体进行混合；</li>\n</ol>\n<h1 id=\"顶点输入\"><a href=\"#顶点输入\" class=\"headerlink\" title=\"顶点输入\"></a>顶点输入</h1><p><img src=\"/article_img/2022-10-24-14-47-45.png\"></p>\n<p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。</p>\n<h2 id=\"VBO（顶点缓冲对象）\"><a href=\"#VBO（顶点缓冲对象）\" class=\"headerlink\" title=\"VBO（顶点缓冲对象）\"></a>VBO（顶点缓冲对象）</h2><p>VBO用来储存输入的一大堆顶点数据，可以一次性将一大批数据发送到显卡上。</p>\n<p>以下代码就是VBO的基本定义和使用方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> VBO;<br><span class=\"hljs-built_in\">glGenBuffers</span>(<span class=\"hljs-number\">1</span>, &amp;VBO); <span class=\"hljs-comment\">// 生成</span><br><span class=\"hljs-built_in\">glBindBudder</span>(GL_ARRAY_BUFFER, VBO);  <span class=\"hljs-comment\">// 绑定到状态机</span><br><span class=\"hljs-built_in\">glBufferData</span>(GL_ARRAY_BUFFER, <span class=\"hljs-built_in\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);  <span class=\"hljs-comment\">// 加数据</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"EBO（元素缓冲对象）\"><a href=\"#EBO（元素缓冲对象）\" class=\"headerlink\" title=\"EBO（元素缓冲对象）\"></a>EBO（元素缓冲对象）</h2><p>这个本来是在教程最后讲解的，但是EBO也是对输入的顶点数据进行处理的对象。</p>\n<p>EBO简单来说就是用来解决顶点重复定义的问题。</p>\n<p>假如现在要通过绘制两个三角形的方法绘制一个矩形，如果没有EBO，需要定义如下顶点集合：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> vertices[] = &#123;<br>    <span class=\"hljs-comment\">// 第一个三角形</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-comment\">// 右上角</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-comment\">// 右下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-comment\">// 左上角</span><br>    <span class=\"hljs-comment\">// 第二个三角形</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-comment\">// 右下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-comment\">// 左下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>   <span class=\"hljs-comment\">// 左上角</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以看到有一些相同的顶点被重复定义了，而EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> vertices[] = &#123;<br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-comment\">// 右上角</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-comment\">// 右下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-comment\">// 左下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>   <span class=\"hljs-comment\">// 左上角</span><br>&#125;;<br><br><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> indices[] = &#123;<br>    <span class=\"hljs-comment\">// 注意索引从0开始! </span><br>    <span class=\"hljs-comment\">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span><br>    <span class=\"hljs-comment\">// 这样可以由下标代表顶点组合成矩形</span><br><br>    <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-comment\">// 第一个三角形</span><br>    <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>  <span class=\"hljs-comment\">// 第二个三角形</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>之后EBO的使用也和VBO类似，之后在渲染循环中，将glDrawArrays()替换成glDrawElements()</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> EBO;<br><span class=\"hljs-built_in\">glGenBuffers</span>(<span class=\"hljs-number\">1</span>, &amp;EBO); <span class=\"hljs-comment\">// 生成</span><br><span class=\"hljs-built_in\">glBindBudder</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);  <span class=\"hljs-comment\">// 绑定到状态机</span><br><span class=\"hljs-built_in\">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class=\"hljs-built_in\">sizeof</span>(indices), indices, GL_STATIC_DRAW);  <span class=\"hljs-comment\">// 加数据</span><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">...</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-comment\">// 渲染循环中</span><br><span class=\"hljs-built_in\">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br><span class=\"hljs-built_in\">glDrawElements</span>(GL_TRIANGLES, <span class=\"hljs-number\">6</span>, GL_UNSIGNED_INT, <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"着色器\"><a href=\"#着色器\" class=\"headerlink\" title=\"着色器\"></a>着色器</h1><h2 id=\"顶点着色器\"><a href=\"#顶点着色器\" class=\"headerlink\" title=\"顶点着色器\"></a>顶点着色器</h2><p>shader语法和编写在下一节具体展开，这里只简单介绍shader如何配置。</p>\n<p>和之前的VBO和EBO类似，也需要先定义一个shader编号，之后生成shader，告诉生成的shader源码是哪些，最后编译shader</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> vertexShader;<br>vertexShader = <span class=\"hljs-built_in\">glCreateShader</span>(GL_VERTEX_SHADER);<br><br><span class=\"hljs-built_in\">glShaderSource</span>(vertexShader, <span class=\"hljs-number\">1</span>, &amp;vertexShaderSource, <span class=\"hljs-literal\">NULL</span>);<br><span class=\"hljs-built_in\">glCompileShader</span>(vertexShader);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"片段着色器\"><a href=\"#片段着色器\" class=\"headerlink\" title=\"片段着色器\"></a>片段着色器</h2><p>和顶点着色器完全一样的用法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> fragmentShader;<br>fragmentShader = <span class=\"hljs-built_in\">glCreateShader</span>(GL_FRAGMENT_SHADER);<br><br><span class=\"hljs-built_in\">glShaderSource</span>(fragmentShader, <span class=\"hljs-number\">1</span>, &amp;fragmentShaderSource, <span class=\"hljs-literal\">NULL</span>);<br><span class=\"hljs-built_in\">glCompileShader</span>(fragmentShader);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"着色器程序对象\"><a href=\"#着色器程序对象\" class=\"headerlink\" title=\"着色器程序对象\"></a>着色器程序对象</h2><p>之前编译好的两个着色器并不能直接使用，需要将其合并（代码上体现出来就是将之前两个shader附加到着色器程序上），之后链接成一个着色器程序对象，在渲染时激活这个着色器程序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> shaderProgram;<br>shaderProgram = <span class=\"hljs-built_in\">glCreateProgram</span>(); <span class=\"hljs-comment\">// 经典创建对象</span><br><br><span class=\"hljs-comment\">// 附加（合并）shader到shaderProgram上</span><br><span class=\"hljs-built_in\">glAttachShader</span>(shaderProgram, vertexShader);<br><span class=\"hljs-built_in\">glAttachShader</span>(shaderProgram, fragmentShader);<br><span class=\"hljs-built_in\">glLinkProgram</span>(shaderProgram); <span class=\"hljs-comment\">// 链接shader</span><br><br><span class=\"hljs-comment\">// 渲染循环中</span><br><span class=\"hljs-built_in\">glUseProgram</span>(shaderProgram);<br></code></pre></td></tr></table></figure>\n\n<p>在把着色器对象链接到程序对象之后，就可以删除着色器对象了</p>\n<h1 id=\"链接顶点属性\"><a href=\"#链接顶点属性\" class=\"headerlink\" title=\"链接顶点属性\"></a>链接顶点属性</h1><p>这部分在第一次读的时候较难理解，之后结合<a href=\"https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20\">傅老師&#x2F;OpenGL教學 第一章</a>才理解。</p>\n<p>我们之前定义了VBO来将一堆顶点数据输入GPU，但是GPU其实并不知道这些顶点数据的含义，glVertexAttribPointer函数就是为了告知GPU如何正确理解这些“杂乱”的顶点信息的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">glVertexAttribPointer</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"hljs-number\">3</span> * <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-type\">float</span>), (<span class=\"hljs-type\">void</span>*)<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-built_in\">glEnableVertexAttribArray</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"顶点数组对象-VAO\"><a href=\"#顶点数组对象-VAO\" class=\"headerlink\" title=\"顶点数组对象(VAO)\"></a>顶点数组对象(VAO)</h1><p>VAO使得当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。</p>\n<p><img src=\"/article_img/2022-10-27-14-16-43.png\"></p>\n<p><img src=\"/article_img/2022-10-27-14-21-46.png\"></p>\n<p>由以上图可以看出VAO包含很多attribute pointer和一个EBO，且可以看出真正储存顶点信息的是一个个的VBO，VAO中存储着如何去解释VBO中数据的顶点属性指针和EBO。</p>\n<h2 id=\"深入理解VAO和VBO\"><a href=\"#深入理解VAO和VBO\" class=\"headerlink\" title=\"深入理解VAO和VBO\"></a>深入理解VAO和VBO</h2><p><a href=\"https://www.zhihu.com/question/30095978/answer/2362612406\">如何正确理解OpenGL的VAO?</a></p>\n<p>可以使用一个VAO绑定多个VBO但是要<strong>注意</strong>：<br>多个VBO中的顶点信息不能重复，如VBO1中存储所有的顶点位置信息，VBO2中存储所有的颜色信息，不能VBO1和VBO2都存储位置信息。</p>\n<p>如果混合存储，如下图，绑定VBO2的时候会覆盖掉之前绑定的VBO1；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> triangle[] = &#123; <span class=\"hljs-comment\">// VBO1的data</span><br>   <span class=\"hljs-comment\">// 位置              // 颜色</span><br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-comment\">// 右下</span><br>   <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-comment\">// 左下</span><br>   <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>    <span class=\"hljs-comment\">// 顶部</span><br>&#125;;<br><span class=\"hljs-type\">float</span> triangle2[] = &#123; <span class=\"hljs-comment\">// VBO2的data</span><br>   <span class=\"hljs-comment\">// 位置              // 颜色</span><br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <br>   <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>   <br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article_img/2022-10-28-19-32-16.png\"></p>\n<p>将顶点信息和颜色信息分别存入到VBO1和VBO2中，再将VBO1和VBO2绑定在VAO上就可以正常显示两个三角形；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> triangles[] = &#123;  <span class=\"hljs-comment\">// VBO1的data</span><br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span><br>&#125;;<br><span class=\"hljs-type\">float</span> colors[] = &#123;   <span class=\"hljs-comment\">// VBO2的data</span><br>   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>,<br>   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-10-28-19-37-42.png\"></p>\n<p>要先绑定VAO，再绑定EBO，否则会出错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> VAO;<br><span class=\"hljs-built_in\">glGenVertexArrays</span>(<span class=\"hljs-number\">1</span>, &amp;VAO);<br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><img src=\"/article_img/2022-10-27-15-12-46.png\"></p>\n<p>首先要理解OpenGL采用状态机架构，所以绑定就意味着使用。</p>\n<p><img src=\"/article_img/2022-10-27-14-53-13.png\"></p>\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><ol>\n<li><p>添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形<br><img src=\"/article_img/2022-10-27-15-32-33.png\"></p>\n<p>关键代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> triangle[] = &#123;<br>   <span class=\"hljs-number\">-1.0f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 渲染循环</span><br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p>创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO<br><img src=\"/article_img/2022-10-27-15-54-08.png\"></p>\n<p>关键代码：<br>这里要注意要分别为两个VAO设置顶点属性，两个VAO该怎样处理VBO中的数据都要分别告知。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> VAO[<span class=\"hljs-number\">2</span>], VBO[<span class=\"hljs-number\">2</span>];<br><span class=\"hljs-built_in\">glGenBuffers</span>(<span class=\"hljs-number\">2</span>, VBO);<br><span class=\"hljs-built_in\">glGenVertexArrays</span>(<span class=\"hljs-number\">2</span>, VAO);<br><br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-built_in\">glBufferData</span>(GL_ARRAY_BUFFER, <span class=\"hljs-built_in\">sizeof</span>(triangle1), triangle1, GL_STATIC_DRAW);<br><span class=\"hljs-comment\">// 为VAO[0]设置顶点属性</span><br><span class=\"hljs-built_in\">glVertexAttribPointer</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"hljs-number\">3</span> * <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-type\">float</span>), (<span class=\"hljs-type\">void</span>*)<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-built_in\">glEnableVertexAttribArray</span>(<span class=\"hljs-number\">0</span>);<br><br><br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-built_in\">glBufferData</span>(GL_ARRAY_BUFFER, <span class=\"hljs-built_in\">sizeof</span>(triangle2), triangle2, GL_STATIC_DRAW);<br><span class=\"hljs-comment\">// 为VAO[1]设置顶点属性</span><br><span class=\"hljs-built_in\">glVertexAttribPointer</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"hljs-number\">3</span> * <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-type\">float</span>), (<span class=\"hljs-type\">void</span>*)<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-built_in\">glEnableVertexAttribArray</span>(<span class=\"hljs-number\">0</span>);<br><br><span class=\"hljs-comment\">// 渲染循环</span><br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);<br><br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p>创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色<br><img src=\"/article_img/2022-10-27-16-10-17.png\"><br>关键代码：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 渲染循环</span><br><span class=\"hljs-built_in\">glUseProgram</span>(shaderProgram1);<br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);<br><br><span class=\"hljs-built_in\">glUseProgram</span>(shaderProgram2);<br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);<br></code></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":5273,"excerpt":"<p>learnopengl-1-你好三角形</p>","more":"<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/04%20Hello%20Triangle/#_7\">你好，三角形-LearnOpenGL CN</a></p>\n<p><a href=\"https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20\">傅老師&#x2F;OpenGL教學 第一章</a></p>\n<p>环境的搭建和窗口的生成有时间之后补上。</p>\n<p>本篇笔记先按照网站的顺序梳理一边基本概念，之后结合傅老师的讲解，<strong>串联</strong>所有概念和步骤。</p>\n<h1 id=\"OpenGL的图形渲染管线（Graphics-Pipline）\"><a href=\"#OpenGL的图形渲染管线（Graphics-Pipline）\" class=\"headerlink\" title=\"OpenGL的图形渲染管线（Graphics Pipline）\"></a>OpenGL的图形渲染管线（Graphics Pipline）</h1><p><img src=\"/article_img/2022-10-24-14-28-44.png\"></p>\n<p>图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p>\n<ol>\n<li>顶点着色器（Vertex Shader）：顶点着色器主要的目的是把3D坐标转为另一种3D坐标；</li>\n<li>图元装配（Primitive Assembly）：将顶点着色器输出的所有顶点装配成指定图元的形状；</li>\n<li>几何着色器（Geometry Shader）：几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状；</li>\n<li>光栅化（Rasterization Stage）：把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)；</li>\n<li>片段着色器（Fragment Shader）：计算一个像素的最终颜色；</li>\n<li>测试和混合（Test and Blending）：检测深度决定哪些片段被舍弃，以及检查alpha值对物体进行混合；</li>\n</ol>\n<h1 id=\"顶点输入\"><a href=\"#顶点输入\" class=\"headerlink\" title=\"顶点输入\"></a>顶点输入</h1><p><img src=\"/article_img/2022-10-24-14-47-45.png\"></p>\n<p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。</p>\n<h2 id=\"VBO（顶点缓冲对象）\"><a href=\"#VBO（顶点缓冲对象）\" class=\"headerlink\" title=\"VBO（顶点缓冲对象）\"></a>VBO（顶点缓冲对象）</h2><p>VBO用来储存输入的一大堆顶点数据，可以一次性将一大批数据发送到显卡上。</p>\n<p>以下代码就是VBO的基本定义和使用方法。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> VBO;<br><span class=\"hljs-built_in\">glGenBuffers</span>(<span class=\"hljs-number\">1</span>, &amp;VBO); <span class=\"hljs-comment\">// 生成</span><br><span class=\"hljs-built_in\">glBindBudder</span>(GL_ARRAY_BUFFER, VBO);  <span class=\"hljs-comment\">// 绑定到状态机</span><br><span class=\"hljs-built_in\">glBufferData</span>(GL_ARRAY_BUFFER, <span class=\"hljs-built_in\">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);  <span class=\"hljs-comment\">// 加数据</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"EBO（元素缓冲对象）\"><a href=\"#EBO（元素缓冲对象）\" class=\"headerlink\" title=\"EBO（元素缓冲对象）\"></a>EBO（元素缓冲对象）</h2><p>这个本来是在教程最后讲解的，但是EBO也是对输入的顶点数据进行处理的对象。</p>\n<p>EBO简单来说就是用来解决顶点重复定义的问题。</p>\n<p>假如现在要通过绘制两个三角形的方法绘制一个矩形，如果没有EBO，需要定义如下顶点集合：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> vertices[] = &#123;<br>    <span class=\"hljs-comment\">// 第一个三角形</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-comment\">// 右上角</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-comment\">// 右下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-comment\">// 左上角</span><br>    <span class=\"hljs-comment\">// 第二个三角形</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-comment\">// 右下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-comment\">// 左下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>   <span class=\"hljs-comment\">// 左上角</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>可以看到有一些相同的顶点被重复定义了，而EBO是一个缓冲区，就像一个顶点缓冲区对象一样，它存储 OpenGL 用来决定要绘制哪些顶点的索引。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> vertices[] = &#123;<br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-comment\">// 右上角</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-comment\">// 右下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-comment\">// 左下角</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>   <span class=\"hljs-comment\">// 左上角</span><br>&#125;;<br><br><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> indices[] = &#123;<br>    <span class=\"hljs-comment\">// 注意索引从0开始! </span><br>    <span class=\"hljs-comment\">// 此例的索引(0,1,2,3)就是顶点数组vertices的下标，</span><br>    <span class=\"hljs-comment\">// 这样可以由下标代表顶点组合成矩形</span><br><br>    <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-comment\">// 第一个三角形</span><br>    <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>  <span class=\"hljs-comment\">// 第二个三角形</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>之后EBO的使用也和VBO类似，之后在渲染循环中，将glDrawArrays()替换成glDrawElements()</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> EBO;<br><span class=\"hljs-built_in\">glGenBuffers</span>(<span class=\"hljs-number\">1</span>, &amp;EBO); <span class=\"hljs-comment\">// 生成</span><br><span class=\"hljs-built_in\">glBindBudder</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);  <span class=\"hljs-comment\">// 绑定到状态机</span><br><span class=\"hljs-built_in\">glBufferData</span>(GL_ELEMENT_ARRAY_BUFFER, <span class=\"hljs-built_in\">sizeof</span>(indices), indices, GL_STATIC_DRAW);  <span class=\"hljs-comment\">// 加数据</span><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">...</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-comment\">// 渲染循环中</span><br><span class=\"hljs-built_in\">glBindBuffer</span>(GL_ELEMENT_ARRAY_BUFFER, EBO);<br><span class=\"hljs-built_in\">glDrawElements</span>(GL_TRIANGLES, <span class=\"hljs-number\">6</span>, GL_UNSIGNED_INT, <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"着色器\"><a href=\"#着色器\" class=\"headerlink\" title=\"着色器\"></a>着色器</h1><h2 id=\"顶点着色器\"><a href=\"#顶点着色器\" class=\"headerlink\" title=\"顶点着色器\"></a>顶点着色器</h2><p>shader语法和编写在下一节具体展开，这里只简单介绍shader如何配置。</p>\n<p>和之前的VBO和EBO类似，也需要先定义一个shader编号，之后生成shader，告诉生成的shader源码是哪些，最后编译shader</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> vertexShader;<br>vertexShader = <span class=\"hljs-built_in\">glCreateShader</span>(GL_VERTEX_SHADER);<br><br><span class=\"hljs-built_in\">glShaderSource</span>(vertexShader, <span class=\"hljs-number\">1</span>, &amp;vertexShaderSource, <span class=\"hljs-literal\">NULL</span>);<br><span class=\"hljs-built_in\">glCompileShader</span>(vertexShader);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"片段着色器\"><a href=\"#片段着色器\" class=\"headerlink\" title=\"片段着色器\"></a>片段着色器</h2><p>和顶点着色器完全一样的用法</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> fragmentShader;<br>fragmentShader = <span class=\"hljs-built_in\">glCreateShader</span>(GL_FRAGMENT_SHADER);<br><br><span class=\"hljs-built_in\">glShaderSource</span>(fragmentShader, <span class=\"hljs-number\">1</span>, &amp;fragmentShaderSource, <span class=\"hljs-literal\">NULL</span>);<br><span class=\"hljs-built_in\">glCompileShader</span>(fragmentShader);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"着色器程序对象\"><a href=\"#着色器程序对象\" class=\"headerlink\" title=\"着色器程序对象\"></a>着色器程序对象</h2><p>之前编译好的两个着色器并不能直接使用，需要将其合并（代码上体现出来就是将之前两个shader附加到着色器程序上），之后链接成一个着色器程序对象，在渲染时激活这个着色器程序。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> shaderProgram;<br>shaderProgram = <span class=\"hljs-built_in\">glCreateProgram</span>(); <span class=\"hljs-comment\">// 经典创建对象</span><br><br><span class=\"hljs-comment\">// 附加（合并）shader到shaderProgram上</span><br><span class=\"hljs-built_in\">glAttachShader</span>(shaderProgram, vertexShader);<br><span class=\"hljs-built_in\">glAttachShader</span>(shaderProgram, fragmentShader);<br><span class=\"hljs-built_in\">glLinkProgram</span>(shaderProgram); <span class=\"hljs-comment\">// 链接shader</span><br><br><span class=\"hljs-comment\">// 渲染循环中</span><br><span class=\"hljs-built_in\">glUseProgram</span>(shaderProgram);<br></code></pre></td></tr></table></figure>\n\n<p>在把着色器对象链接到程序对象之后，就可以删除着色器对象了</p>\n<h1 id=\"链接顶点属性\"><a href=\"#链接顶点属性\" class=\"headerlink\" title=\"链接顶点属性\"></a>链接顶点属性</h1><p>这部分在第一次读的时候较难理解，之后结合<a href=\"https://www.bilibili.com/video/BV11W411N7b9?p=10&vd_source=93b215eab72b2548f75d0772e28f8b20\">傅老師&#x2F;OpenGL教學 第一章</a>才理解。</p>\n<p>我们之前定义了VBO来将一堆顶点数据输入GPU，但是GPU其实并不知道这些顶点数据的含义，glVertexAttribPointer函数就是为了告知GPU如何正确理解这些“杂乱”的顶点信息的。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">glVertexAttribPointer</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"hljs-number\">3</span> * <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-type\">float</span>), (<span class=\"hljs-type\">void</span>*)<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-built_in\">glEnableVertexAttribArray</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"顶点数组对象-VAO\"><a href=\"#顶点数组对象-VAO\" class=\"headerlink\" title=\"顶点数组对象(VAO)\"></a>顶点数组对象(VAO)</h1><p>VAO使得当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。</p>\n<p><img src=\"/article_img/2022-10-27-14-16-43.png\"></p>\n<p><img src=\"/article_img/2022-10-27-14-21-46.png\"></p>\n<p>由以上图可以看出VAO包含很多attribute pointer和一个EBO，且可以看出真正储存顶点信息的是一个个的VBO，VAO中存储着如何去解释VBO中数据的顶点属性指针和EBO。</p>\n<h2 id=\"深入理解VAO和VBO\"><a href=\"#深入理解VAO和VBO\" class=\"headerlink\" title=\"深入理解VAO和VBO\"></a>深入理解VAO和VBO</h2><p><a href=\"https://www.zhihu.com/question/30095978/answer/2362612406\">如何正确理解OpenGL的VAO?</a></p>\n<p>可以使用一个VAO绑定多个VBO但是要<strong>注意</strong>：<br>多个VBO中的顶点信息不能重复，如VBO1中存储所有的顶点位置信息，VBO2中存储所有的颜色信息，不能VBO1和VBO2都存储位置信息。</p>\n<p>如果混合存储，如下图，绑定VBO2的时候会覆盖掉之前绑定的VBO1；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> triangle[] = &#123; <span class=\"hljs-comment\">// VBO1的data</span><br>   <span class=\"hljs-comment\">// 位置              // 颜色</span><br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-comment\">// 右下</span><br>   <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-comment\">// 左下</span><br>   <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>    <span class=\"hljs-comment\">// 顶部</span><br>&#125;;<br><span class=\"hljs-type\">float</span> triangle2[] = &#123; <span class=\"hljs-comment\">// VBO2的data</span><br>   <span class=\"hljs-comment\">// 位置              // 颜色</span><br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <br>   <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>   <br>&#125;;<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article_img/2022-10-28-19-32-16.png\"></p>\n<p>将顶点信息和颜色信息分别存入到VBO1和VBO2中，再将VBO1和VBO2绑定在VAO上就可以正常显示两个三角形；</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> triangles[] = &#123;  <span class=\"hljs-comment\">// VBO1的data</span><br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span><br>&#125;;<br><span class=\"hljs-type\">float</span> colors[] = &#123;   <span class=\"hljs-comment\">// VBO2的data</span><br>   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>,<br>   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"/article_img/2022-10-28-19-37-42.png\"></p>\n<p>要先绑定VAO，再绑定EBO，否则会出错。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> VAO;<br><span class=\"hljs-built_in\">glGenVertexArrays</span>(<span class=\"hljs-number\">1</span>, &amp;VAO);<br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><img src=\"/article_img/2022-10-27-15-12-46.png\"></p>\n<p>首先要理解OpenGL采用状态机架构，所以绑定就意味着使用。</p>\n<p><img src=\"/article_img/2022-10-27-14-53-13.png\"></p>\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><ol>\n<li><p>添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形<br><img src=\"/article_img/2022-10-27-15-32-33.png\"></p>\n<p>关键代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> triangle[] = &#123;<br>   <span class=\"hljs-number\">-1.0f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,<br>   <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 渲染循环</span><br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p>创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO<br><img src=\"/article_img/2022-10-27-15-54-08.png\"></p>\n<p>关键代码：<br>这里要注意要分别为两个VAO设置顶点属性，两个VAO该怎样处理VBO中的数据都要分别告知。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> VAO[<span class=\"hljs-number\">2</span>], VBO[<span class=\"hljs-number\">2</span>];<br><span class=\"hljs-built_in\">glGenBuffers</span>(<span class=\"hljs-number\">2</span>, VBO);<br><span class=\"hljs-built_in\">glGenVertexArrays</span>(<span class=\"hljs-number\">2</span>, VAO);<br><br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-built_in\">glBufferData</span>(GL_ARRAY_BUFFER, <span class=\"hljs-built_in\">sizeof</span>(triangle1), triangle1, GL_STATIC_DRAW);<br><span class=\"hljs-comment\">// 为VAO[0]设置顶点属性</span><br><span class=\"hljs-built_in\">glVertexAttribPointer</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"hljs-number\">3</span> * <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-type\">float</span>), (<span class=\"hljs-type\">void</span>*)<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-built_in\">glEnableVertexAttribArray</span>(<span class=\"hljs-number\">0</span>);<br><br><br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-built_in\">glBindBuffer</span>(GL_ARRAY_BUFFER, VBO[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-built_in\">glBufferData</span>(GL_ARRAY_BUFFER, <span class=\"hljs-built_in\">sizeof</span>(triangle2), triangle2, GL_STATIC_DRAW);<br><span class=\"hljs-comment\">// 为VAO[1]设置顶点属性</span><br><span class=\"hljs-built_in\">glVertexAttribPointer</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, GL_FLOAT, GL_FALSE, <span class=\"hljs-number\">3</span> * <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-type\">float</span>), (<span class=\"hljs-type\">void</span>*)<span class=\"hljs-number\">0</span>);<br><span class=\"hljs-built_in\">glEnableVertexAttribArray</span>(<span class=\"hljs-number\">0</span>);<br><br><span class=\"hljs-comment\">// 渲染循环</span><br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);<br><br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p>创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色<br><img src=\"/article_img/2022-10-27-16-10-17.png\"><br>关键代码：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 渲染循环</span><br><span class=\"hljs-built_in\">glUseProgram</span>(shaderProgram1);<br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">0</span>]);<br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);<br><br><span class=\"hljs-built_in\">glUseProgram</span>(shaderProgram2);<br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO[<span class=\"hljs-number\">1</span>]);<br><span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);<br></code></pre></td></tr></table></figure></li>\n</ol>"},{"title":"learnopengl-2-着色器","date":"2022-10-27T16:00:00.000Z","index_img":"/img/bg/opengl.jpg","_content":"\nlearnopengl-2-着色器\n<!-- more -->\n\n[着色器-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/)\n\n# GLSL\n\n着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。\n\nShader的典型结构\n\n```C++\n#version version_number\nin type in_variable_name;\nin type in_variable_name;\n\nout type out_variable_name;\n\nuniform type uniform_name;\n\nint main()\n{\n  // 处理输入并进行一些图形操作\n  ...\n  // 输出处理过的结果到输出变量\n  out_variable_name = weird_stuff_we_processed;\n}\n```\n\n# 数据类型\n\nGLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。\n\n还有两种容器类型，分别是向量（Vector）和矩阵（Matrix）\n\n## 向量\n\n| 类型  |             含义              |\n| :---: | :---------------------------: |\n| vecn  |  包含n个float分量的默认向量   |\n| bvecn |     包含n个bool分量的向量     |\n| ivecn |   包含n个int分量的默认向量    |\n| uvecn | 包含n个unsigned int分量的向量 |\n| dvecn |  包含n个double分量的默认向量  |\n\n向量的使用十分灵活，如下所示：\n```C++\nvec2 someVec;\nvec4 differentVec = someVec.xyxx;\nvec3 anotherVec = differentVec.zyw;\nvec4 otherVec = someVec.xxxx + anotherVec.yxzy;\n\nvec2 vect = vec2(0.5, 0.7);\nvec4 result = vec4(vect, 0.0, 0.0);\nvec4 otherResult = vec4(result.xyz, 1.0);\n```\n\n# 输入与输出\n\nGLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但有两个特例：顶点着色器和片段着色器。\n\n## 顶点着色器\n\n顶点着色器需要一种特殊的输入，从顶点数据中直接接收输入。使用**location**这一元数据指定输入变量\n\n```C++\n#version 330 core\nlayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0\n\nout vec4 vertexColor; // 为片段着色器指定一个颜色输出\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数\n    vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色\n}\n```\n\n## 片段着色器\n\n片段着色器需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。\n\n```C++\n#version 330 core\nout vec4 FragColor;\n\nin vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）\n\nvoid main()\n{\n    FragColor = vertexColor;\n}\n```\n\n# Uniform\n\nUniform是一种从CPU中的应用向GPU中的着色器发送数据的方式, 具体使用时就是在shader（GPU）中定义uniform变量，该变量可以在main函数（CPU）中被赋值和改变。\n\nuniform是全局的(Global)，必须在每个着色器中都是独一无二的。\n\n在程序中改变uniform的值需要先找到着色器中uniform属性的位置，用**glGetUniformLocation**函数查询，使用方法如下：\n\n```C++\nint vertexColorLocation = glGetUniformLocation(shader_name, \"uniform_name\");\n```\n\n之后使用**glUniform**函数改变uniform的值：\n```C++\nglUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n```\n![](/article_img/2022-10-28-17-09-17.png)\n\n# 自己的着色器类\n\n定义一个着色器类实现从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测。\n\n## 从文件读取shader\n\n之前我们都使用硬编码shader代码的方式使用shader，在这里尝试从外部文件中读取shader代码。\n\n![](/article_img/2022-10-29-12-19-29.png)\n\n# 练习\n\n1. 修改顶点着色器让三角形上下颠倒：\n    ```C++\n    #version 330 core\n    layout (location = 0) in vec3 aPos;\n    layout (location = 1) in vec3 aColor;\n\n    out vec3 ourColor;\n\n    void main()\n    {\n        gl_Position = vec4(aPos.x, -aPos.y, aPos.z, 1.0); // 将y坐标取反即可\n        ourColor = ourColor;\n    }\n    ```\n    ![](/article_img/2022-10-28-19-52-39.png)\n2. 使用uniform定义一个水平偏移量，在顶点着色器中使用这个偏移量把三角形移动到屏幕右侧：\n    ```C++\n    #version 330 core\n    layout (location = 0) in vec3 aPos;\n    layout (location = 1) in vec3 aColor;\n\n    out vec3 ourColor;\n    uniform float hori_offset; // 在程序中修改即可\n\n    void main()\n    {\n        gl_Position = vec4(aPos.x-hori_offset, aPos.y, aPos.z, 1.0);\n        ourColor = ourColor;\n    }\n    ```\n    ![](/article_img/2022-10-28-19-53-14.png)\n3. 使用out关键字把顶点位置输出到片段着色器，并将片段的颜色设置为与顶点位置相等（来看看连顶点位置值都在三角形中被插值的结果）。做完这些后，尝试回答下面的问题：为什么在三角形的左下角是黑的?：\n    ```C++\n    #version 330 core\n    layout (location = 0) in vec3 aPos;\n    layout (location = 1) in vec3 aColor;\n\n    void main()\n    {\n        gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n        ourColor = aPos;\n    }\n    ```\n    ![](/article_img/2022-10-28-19-11-33.png)\n    左下角是黑色是因为左下角的坐标是（-0.5f, -0.5f, 0.0f）是负值，而负值在颜色计算时会转换成0，并且插值后的结果也仍然是负值，故直到三角形中心才开始有颜色的渐变。\n","source":"_posts/learnopengl-2-着色器.md","raw":"---\ntitle: learnopengl-2-着色器\ndate: 2022-10-28\nindex_img: \"/img/bg/opengl.jpg\"\ntags: [OpenGL]\ncategories: \n   -[OpenGL笔记]\n---\n\nlearnopengl-2-着色器\n<!-- more -->\n\n[着色器-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/)\n\n# GLSL\n\n着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。\n\nShader的典型结构\n\n```C++\n#version version_number\nin type in_variable_name;\nin type in_variable_name;\n\nout type out_variable_name;\n\nuniform type uniform_name;\n\nint main()\n{\n  // 处理输入并进行一些图形操作\n  ...\n  // 输出处理过的结果到输出变量\n  out_variable_name = weird_stuff_we_processed;\n}\n```\n\n# 数据类型\n\nGLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。\n\n还有两种容器类型，分别是向量（Vector）和矩阵（Matrix）\n\n## 向量\n\n| 类型  |             含义              |\n| :---: | :---------------------------: |\n| vecn  |  包含n个float分量的默认向量   |\n| bvecn |     包含n个bool分量的向量     |\n| ivecn |   包含n个int分量的默认向量    |\n| uvecn | 包含n个unsigned int分量的向量 |\n| dvecn |  包含n个double分量的默认向量  |\n\n向量的使用十分灵活，如下所示：\n```C++\nvec2 someVec;\nvec4 differentVec = someVec.xyxx;\nvec3 anotherVec = differentVec.zyw;\nvec4 otherVec = someVec.xxxx + anotherVec.yxzy;\n\nvec2 vect = vec2(0.5, 0.7);\nvec4 result = vec4(vect, 0.0, 0.0);\nvec4 otherResult = vec4(result.xyz, 1.0);\n```\n\n# 输入与输出\n\nGLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但有两个特例：顶点着色器和片段着色器。\n\n## 顶点着色器\n\n顶点着色器需要一种特殊的输入，从顶点数据中直接接收输入。使用**location**这一元数据指定输入变量\n\n```C++\n#version 330 core\nlayout (location = 0) in vec3 aPos; // 位置变量的属性位置值为0\n\nout vec4 vertexColor; // 为片段着色器指定一个颜色输出\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 1.0); // 注意我们如何把一个vec3作为vec4的构造器的参数\n    vertexColor = vec4(0.5, 0.0, 0.0, 1.0); // 把输出变量设置为暗红色\n}\n```\n\n## 片段着色器\n\n片段着色器需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。\n\n```C++\n#version 330 core\nout vec4 FragColor;\n\nin vec4 vertexColor; // 从顶点着色器传来的输入变量（名称相同、类型相同）\n\nvoid main()\n{\n    FragColor = vertexColor;\n}\n```\n\n# Uniform\n\nUniform是一种从CPU中的应用向GPU中的着色器发送数据的方式, 具体使用时就是在shader（GPU）中定义uniform变量，该变量可以在main函数（CPU）中被赋值和改变。\n\nuniform是全局的(Global)，必须在每个着色器中都是独一无二的。\n\n在程序中改变uniform的值需要先找到着色器中uniform属性的位置，用**glGetUniformLocation**函数查询，使用方法如下：\n\n```C++\nint vertexColorLocation = glGetUniformLocation(shader_name, \"uniform_name\");\n```\n\n之后使用**glUniform**函数改变uniform的值：\n```C++\nglUniform4f(vertexColorLocation, 0.0f, greenValue, 0.0f, 1.0f);\n```\n![](/article_img/2022-10-28-17-09-17.png)\n\n# 自己的着色器类\n\n定义一个着色器类实现从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测。\n\n## 从文件读取shader\n\n之前我们都使用硬编码shader代码的方式使用shader，在这里尝试从外部文件中读取shader代码。\n\n![](/article_img/2022-10-29-12-19-29.png)\n\n# 练习\n\n1. 修改顶点着色器让三角形上下颠倒：\n    ```C++\n    #version 330 core\n    layout (location = 0) in vec3 aPos;\n    layout (location = 1) in vec3 aColor;\n\n    out vec3 ourColor;\n\n    void main()\n    {\n        gl_Position = vec4(aPos.x, -aPos.y, aPos.z, 1.0); // 将y坐标取反即可\n        ourColor = ourColor;\n    }\n    ```\n    ![](/article_img/2022-10-28-19-52-39.png)\n2. 使用uniform定义一个水平偏移量，在顶点着色器中使用这个偏移量把三角形移动到屏幕右侧：\n    ```C++\n    #version 330 core\n    layout (location = 0) in vec3 aPos;\n    layout (location = 1) in vec3 aColor;\n\n    out vec3 ourColor;\n    uniform float hori_offset; // 在程序中修改即可\n\n    void main()\n    {\n        gl_Position = vec4(aPos.x-hori_offset, aPos.y, aPos.z, 1.0);\n        ourColor = ourColor;\n    }\n    ```\n    ![](/article_img/2022-10-28-19-53-14.png)\n3. 使用out关键字把顶点位置输出到片段着色器，并将片段的颜色设置为与顶点位置相等（来看看连顶点位置值都在三角形中被插值的结果）。做完这些后，尝试回答下面的问题：为什么在三角形的左下角是黑的?：\n    ```C++\n    #version 330 core\n    layout (location = 0) in vec3 aPos;\n    layout (location = 1) in vec3 aColor;\n\n    void main()\n    {\n        gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n        ourColor = aPos;\n    }\n    ```\n    ![](/article_img/2022-10-28-19-11-33.png)\n    左下角是黑色是因为左下角的坐标是（-0.5f, -0.5f, 0.0f）是负值，而负值在颜色计算时会转换成0，并且插值后的结果也仍然是负值，故直到三角形中心才开始有颜色的渐变。\n","slug":"learnopengl-2-着色器","published":1,"updated":"2022-11-01T08:51:10.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigm7001zw0je25pdgfgf","content":"<p>learnopengl-2-着色器</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/\">着色器-LearnOpenGL CN</a></p>\n<h1 id=\"GLSL\"><a href=\"#GLSL\" class=\"headerlink\" title=\"GLSL\"></a>GLSL</h1><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p>\n<p>Shader的典型结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version version_number</span><br>in type in_variable_name;<br>in type in_variable_name;<br><br>out type out_variable_name;<br><br>uniform type uniform_name;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-comment\">// 处理输入并进行一些图形操作</span><br>  ...<br>  <span class=\"hljs-comment\">// 输出处理过的结果到输出变量</span><br>  out_variable_name = weird_stuff_we_processed;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p>GLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。</p>\n<p>还有两种容器类型，分别是向量（Vector）和矩阵（Matrix）</p>\n<h2 id=\"向量\"><a href=\"#向量\" class=\"headerlink\" title=\"向量\"></a>向量</h2><table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">vecn</td>\n<td align=\"center\">包含n个float分量的默认向量</td>\n</tr>\n<tr>\n<td align=\"center\">bvecn</td>\n<td align=\"center\">包含n个bool分量的向量</td>\n</tr>\n<tr>\n<td align=\"center\">ivecn</td>\n<td align=\"center\">包含n个int分量的默认向量</td>\n</tr>\n<tr>\n<td align=\"center\">uvecn</td>\n<td align=\"center\">包含n个unsigned int分量的向量</td>\n</tr>\n<tr>\n<td align=\"center\">dvecn</td>\n<td align=\"center\">包含n个double分量的默认向量</td>\n</tr>\n</tbody></table>\n<p>向量的使用十分灵活，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">vec2 someVec;<br>vec4 differentVec = someVec.xyxx;<br>vec3 anotherVec = differentVec.zyw;<br>vec4 otherVec = someVec.xxxx + anotherVec.yxzy;<br><br>vec2 vect = <span class=\"hljs-built_in\">vec2</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.7</span>);<br>vec4 result = <span class=\"hljs-built_in\">vec4</span>(vect, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">0.0</span>);<br>vec4 otherResult = <span class=\"hljs-built_in\">vec4</span>(result.xyz, <span class=\"hljs-number\">1.0</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"输入与输出\"><a href=\"#输入与输出\" class=\"headerlink\" title=\"输入与输出\"></a>输入与输出</h1><p>GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但有两个特例：顶点着色器和片段着色器。</p>\n<h2 id=\"顶点着色器\"><a href=\"#顶点着色器\" class=\"headerlink\" title=\"顶点着色器\"></a>顶点着色器</h2><p>顶点着色器需要一种特殊的输入，从顶点数据中直接接收输入。使用<strong>location</strong>这一元数据指定输入变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos; <span class=\"hljs-comment\">// 位置变量的属性位置值为0</span><br><br>out vec4 vertexColor; <span class=\"hljs-comment\">// 为片段着色器指定一个颜色输出</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos, <span class=\"hljs-number\">1.0</span>); <span class=\"hljs-comment\">// 注意我们如何把一个vec3作为vec4的构造器的参数</span><br>    vertexColor = <span class=\"hljs-built_in\">vec4</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">1.0</span>); <span class=\"hljs-comment\">// 把输出变量设置为暗红色</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"片段着色器\"><a href=\"#片段着色器\" class=\"headerlink\" title=\"片段着色器\"></a>片段着色器</h2><p>片段着色器需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec4 vertexColor; <span class=\"hljs-comment\">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    FragColor = vertexColor;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Uniform\"><a href=\"#Uniform\" class=\"headerlink\" title=\"Uniform\"></a>Uniform</h1><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式, 具体使用时就是在shader（GPU）中定义uniform变量，该变量可以在main函数（CPU）中被赋值和改变。</p>\n<p>uniform是全局的(Global)，必须在每个着色器中都是独一无二的。</p>\n<p>在程序中改变uniform的值需要先找到着色器中uniform属性的位置，用<strong>glGetUniformLocation</strong>函数查询，使用方法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">int</span> vertexColorLocation = <span class=\"hljs-built_in\">glGetUniformLocation</span>(shader_name, <span class=\"hljs-string\">&quot;uniform_name&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>之后使用<strong>glUniform</strong>函数改变uniform的值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glUniform4f</span>(vertexColorLocation, <span class=\"hljs-number\">0.0f</span>, greenValue, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>);<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article_img/2022-10-28-17-09-17.png\"></p>\n<h1 id=\"自己的着色器类\"><a href=\"#自己的着色器类\" class=\"headerlink\" title=\"自己的着色器类\"></a>自己的着色器类</h1><p>定义一个着色器类实现从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测。</p>\n<h2 id=\"从文件读取shader\"><a href=\"#从文件读取shader\" class=\"headerlink\" title=\"从文件读取shader\"></a>从文件读取shader</h2><p>之前我们都使用硬编码shader代码的方式使用shader，在这里尝试从外部文件中读取shader代码。</p>\n<p><img src=\"/article_img/2022-10-29-12-19-29.png\"></p>\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><ol>\n<li>修改顶点着色器让三角形上下颠倒： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec3 aColor;<br><br>out vec3 ourColor;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos.x, -aPos.y, aPos.z, <span class=\"hljs-number\">1.0</span>); <span class=\"hljs-comment\">// 将y坐标取反即可</span><br>    ourColor = ourColor;<br>&#125;<br></code></pre></td></tr></table></figure>\n <img src=\"/article_img/2022-10-28-19-52-39.png\"></li>\n<li>使用uniform定义一个水平偏移量，在顶点着色器中使用这个偏移量把三角形移动到屏幕右侧： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec3 aColor;<br><br>out vec3 ourColor;<br>uniform <span class=\"hljs-type\">float</span> hori_offset; <span class=\"hljs-comment\">// 在程序中修改即可</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos.x-hori_offset, aPos.y, aPos.z, <span class=\"hljs-number\">1.0</span>);<br>    ourColor = ourColor;<br>&#125;<br></code></pre></td></tr></table></figure>\n <img src=\"/article_img/2022-10-28-19-53-14.png\"></li>\n<li>使用out关键字把顶点位置输出到片段着色器，并将片段的颜色设置为与顶点位置相等（来看看连顶点位置值都在三角形中被插值的结果）。做完这些后，尝试回答下面的问题：为什么在三角形的左下角是黑的?： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec3 aColor;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos.x, aPos.y, aPos.z, <span class=\"hljs-number\">1.0</span>);<br>    ourColor = aPos;<br>&#125;<br></code></pre></td></tr></table></figure>\n <img src=\"/article_img/2022-10-28-19-11-33.png\"><br> 左下角是黑色是因为左下角的坐标是（-0.5f, -0.5f, 0.0f）是负值，而负值在颜色计算时会转换成0，并且插值后的结果也仍然是负值，故直到三角形中心才开始有颜色的渐变。</li>\n</ol>\n","site":{"data":{}},"wordcount":2656,"excerpt":"<p>learnopengl-2-着色器</p>","more":"<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/\">着色器-LearnOpenGL CN</a></p>\n<h1 id=\"GLSL\"><a href=\"#GLSL\" class=\"headerlink\" title=\"GLSL\"></a>GLSL</h1><p>着色器是使用一种叫GLSL的类C语言写成的。GLSL是为图形计算量身定制的，它包含一些针对向量和矩阵操作的有用特性。</p>\n<p>Shader的典型结构</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version version_number</span><br>in type in_variable_name;<br>in type in_variable_name;<br><br>out type out_variable_name;<br><br>uniform type uniform_name;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-comment\">// 处理输入并进行一些图形操作</span><br>  ...<br>  <span class=\"hljs-comment\">// 输出处理过的结果到输出变量</span><br>  out_variable_name = weird_stuff_we_processed;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h1><p>GLSL中包含C等其它语言大部分的默认基础数据类型：int、float、double、uint和bool。</p>\n<p>还有两种容器类型，分别是向量（Vector）和矩阵（Matrix）</p>\n<h2 id=\"向量\"><a href=\"#向量\" class=\"headerlink\" title=\"向量\"></a>向量</h2><table>\n<thead>\n<tr>\n<th align=\"center\">类型</th>\n<th align=\"center\">含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">vecn</td>\n<td align=\"center\">包含n个float分量的默认向量</td>\n</tr>\n<tr>\n<td align=\"center\">bvecn</td>\n<td align=\"center\">包含n个bool分量的向量</td>\n</tr>\n<tr>\n<td align=\"center\">ivecn</td>\n<td align=\"center\">包含n个int分量的默认向量</td>\n</tr>\n<tr>\n<td align=\"center\">uvecn</td>\n<td align=\"center\">包含n个unsigned int分量的向量</td>\n</tr>\n<tr>\n<td align=\"center\">dvecn</td>\n<td align=\"center\">包含n个double分量的默认向量</td>\n</tr>\n</tbody></table>\n<p>向量的使用十分灵活，如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">vec2 someVec;<br>vec4 differentVec = someVec.xyxx;<br>vec3 anotherVec = differentVec.zyw;<br>vec4 otherVec = someVec.xxxx + anotherVec.yxzy;<br><br>vec2 vect = <span class=\"hljs-built_in\">vec2</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.7</span>);<br>vec4 result = <span class=\"hljs-built_in\">vec4</span>(vect, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">0.0</span>);<br>vec4 otherResult = <span class=\"hljs-built_in\">vec4</span>(result.xyz, <span class=\"hljs-number\">1.0</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"输入与输出\"><a href=\"#输入与输出\" class=\"headerlink\" title=\"输入与输出\"></a>输入与输出</h1><p>GLSL定义了in和out关键字专门来实现这个目的。每个着色器使用这两个关键字设定输入和输出，只要一个输出变量与下一个着色器阶段的输入匹配，它就会传递下去。但有两个特例：顶点着色器和片段着色器。</p>\n<h2 id=\"顶点着色器\"><a href=\"#顶点着色器\" class=\"headerlink\" title=\"顶点着色器\"></a>顶点着色器</h2><p>顶点着色器需要一种特殊的输入，从顶点数据中直接接收输入。使用<strong>location</strong>这一元数据指定输入变量</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos; <span class=\"hljs-comment\">// 位置变量的属性位置值为0</span><br><br>out vec4 vertexColor; <span class=\"hljs-comment\">// 为片段着色器指定一个颜色输出</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos, <span class=\"hljs-number\">1.0</span>); <span class=\"hljs-comment\">// 注意我们如何把一个vec3作为vec4的构造器的参数</span><br>    vertexColor = <span class=\"hljs-built_in\">vec4</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">1.0</span>); <span class=\"hljs-comment\">// 把输出变量设置为暗红色</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"片段着色器\"><a href=\"#片段着色器\" class=\"headerlink\" title=\"片段着色器\"></a>片段着色器</h2><p>片段着色器需要一个vec4颜色输出变量，因为片段着色器需要生成一个最终输出的颜色。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec4 vertexColor; <span class=\"hljs-comment\">// 从顶点着色器传来的输入变量（名称相同、类型相同）</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    FragColor = vertexColor;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Uniform\"><a href=\"#Uniform\" class=\"headerlink\" title=\"Uniform\"></a>Uniform</h1><p>Uniform是一种从CPU中的应用向GPU中的着色器发送数据的方式, 具体使用时就是在shader（GPU）中定义uniform变量，该变量可以在main函数（CPU）中被赋值和改变。</p>\n<p>uniform是全局的(Global)，必须在每个着色器中都是独一无二的。</p>\n<p>在程序中改变uniform的值需要先找到着色器中uniform属性的位置，用<strong>glGetUniformLocation</strong>函数查询，使用方法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">int</span> vertexColorLocation = <span class=\"hljs-built_in\">glGetUniformLocation</span>(shader_name, <span class=\"hljs-string\">&quot;uniform_name&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>之后使用<strong>glUniform</strong>函数改变uniform的值：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glUniform4f</span>(vertexColorLocation, <span class=\"hljs-number\">0.0f</span>, greenValue, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>);<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article_img/2022-10-28-17-09-17.png\"></p>\n<h1 id=\"自己的着色器类\"><a href=\"#自己的着色器类\" class=\"headerlink\" title=\"自己的着色器类\"></a>自己的着色器类</h1><p>定义一个着色器类实现从硬盘读取着色器，然后编译并链接它们，并对它们进行错误检测。</p>\n<h2 id=\"从文件读取shader\"><a href=\"#从文件读取shader\" class=\"headerlink\" title=\"从文件读取shader\"></a>从文件读取shader</h2><p>之前我们都使用硬编码shader代码的方式使用shader，在这里尝试从外部文件中读取shader代码。</p>\n<p><img src=\"/article_img/2022-10-29-12-19-29.png\"></p>\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><ol>\n<li>修改顶点着色器让三角形上下颠倒： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec3 aColor;<br><br>out vec3 ourColor;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos.x, -aPos.y, aPos.z, <span class=\"hljs-number\">1.0</span>); <span class=\"hljs-comment\">// 将y坐标取反即可</span><br>    ourColor = ourColor;<br>&#125;<br></code></pre></td></tr></table></figure>\n <img src=\"/article_img/2022-10-28-19-52-39.png\"></li>\n<li>使用uniform定义一个水平偏移量，在顶点着色器中使用这个偏移量把三角形移动到屏幕右侧： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec3 aColor;<br><br>out vec3 ourColor;<br>uniform <span class=\"hljs-type\">float</span> hori_offset; <span class=\"hljs-comment\">// 在程序中修改即可</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos.x-hori_offset, aPos.y, aPos.z, <span class=\"hljs-number\">1.0</span>);<br>    ourColor = ourColor;<br>&#125;<br></code></pre></td></tr></table></figure>\n <img src=\"/article_img/2022-10-28-19-53-14.png\"></li>\n<li>使用out关键字把顶点位置输出到片段着色器，并将片段的颜色设置为与顶点位置相等（来看看连顶点位置值都在三角形中被插值的结果）。做完这些后，尝试回答下面的问题：为什么在三角形的左下角是黑的?： <figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec3 aColor;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos.x, aPos.y, aPos.z, <span class=\"hljs-number\">1.0</span>);<br>    ourColor = aPos;<br>&#125;<br></code></pre></td></tr></table></figure>\n <img src=\"/article_img/2022-10-28-19-11-33.png\"><br> 左下角是黑色是因为左下角的坐标是（-0.5f, -0.5f, 0.0f）是负值，而负值在颜色计算时会转换成0，并且插值后的结果也仍然是负值，故直到三角形中心才开始有颜色的渐变。</li>\n</ol>"},{"title":"learnopengl-4-变换和坐标系","date":"2022-11-01T16:00:00.000Z","index_img":"/img/bg/opengl.jpg","_content":"\nlearnopengl-4-变换和坐标系\n<!-- more -->\n\n[坐标系统-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/)\n\n[变换-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/)\n\n# 变换\n\n这一部分设计线性代数的知识，以及在[games101](Games101-2-变换.md)中有过详细介绍，因此这一部分主要记录在OpenGL中的实践，原理不过多解释（如果之后看了[线性代数的本质](https://www.bilibili.com/video/BV1ys411472E/?spm_id_from=333.999.0.0)再进行补充）\n\n## GLM\n\nGLM是OpenGL Mathematics的缩写，它是一个只有头文件的库,把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。\n\n```C++\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n```\n这个库使用方法有些独特，定义变换矩阵十分方便：\n```C++\nglm::mat4 trans; // 定义单位矩阵\ntrans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));  // 定义位移矩阵调用tranlate函数，参数是位移向量\ntrans = glm::rotation(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0)); // 定义旋转矩阵调用rotation函数，参数是旋转角度和旋转轴\ntrans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5)); // 定义缩放矩阵调用scale函数，参数是x,y,z方向上的缩放值\n```\n\n这些矩阵都是在trans的基础上生成的，相当于和trans右乘，按上面的代码就是先做缩放变换，之后旋转变换，最后位移变换。\n\n## 实践\n\n只需要在顶点着色器中定义一个uniform，将变换矩阵传递进shader，和原来的顶点坐标相乘:\n```C++\n#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec2 aTexCoord;\n\nout vec2 TexCoord;\n\nuniform mat4 transform;\n\nvoid main()\n{\n    gl_Position = transform * vec4(aPos, 1.0f);\n    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);\n}\n```\n在程序中将变换矩阵传递给uniform:\n```C++\nunsigned int transformLoc = glGetUniformLocation(ourShader.ID, \"transform\");\nglUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));\n```\n## 练习\n\n1. 使用应用在箱子上的最后一个变换，尝试将其改变为先旋转，后位移。看看发生了什么，试着想想为什么会发生这样的事情：\n   ![](/article_img/2022-11-02-15-31-22.png)\n   会绕着原点旋转，这里是因为旋转操作都是默认绕原点的，代码中的先旋转后位移在实际变换时是先位移后旋转；\n   如果希望绕任意一点旋转，需要再加一个位移矩阵。\n   ```C++\n    glm::mat4 trans; \n    trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));\n    trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));\n    trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));\n   ```\n   ![](/article_img/2022-11-02-15-34-54.png)\n2. 尝试再次调用glDrawElements画出第二个箱子，只使用变换将其摆放在不同的位置。让这个箱子被摆放在窗口的左上角，并且会不断的缩放（而不是旋转）。（sin函数在这里会很有用，不过注意使用sin函数时应用负值会导致物体被翻转）\n   ![](/article_img/2022-11-02-15-36-15.png)\n   这里注意调用glDrawElements画出第二个箱子时不需要再绑定别的VAO，但是在画之前要重置变换矩阵，否则就是在同一个位置画了两次，完全看不出。\n\n\n# 坐标系统\n\n![](/article_img/2022-11-10-16-13-36.png)\n\n\"我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。\"\n\n## 局部空间（Local Space）\n\n就像在Blender中创建了一个立方体，原点有可能位于(0, 0, 0)\n\n## 世界空间（World Space）\n\n世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。就是将不同的模型摆放在世界的不同位置，该变换由模型矩阵（Model Matrix）实现。\n\n模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。\n\n## 观察空间（View Space）\n\n观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)），由视图矩阵（View Matrix）实现。\n\n## 裁剪空间（Clip Space）\n\n在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。\n\n投影矩阵分为透视投影（Perspective Projection Matrix）和正交投影（Orthographic Projection Matrix）\n\n正交投影视锥（Frustum）  \n![](/article_img/2022-11-10-16-26-15.png)  \n透视投影视锥（Frustum）  \n![](/article_img/2022-11-10-16-25-36.png)\n\n两种投影方法的对比：\n![](/article_img/2022-11-10-16-24-26.png)\n\n在OpenGL中的用法：\n```C++\n// 正交投影\nglm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);\n// 透视投影\nglm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);\n```\n\n## MVP变换\n\n![](/article_img/2022-11-10-16-28-11.png)\n\n经过Model-View-Projection变换，物体坐标就被变换到了裁剪坐标，之后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标，最后进行视口变换，将坐标映射到屏幕上的每一个像素。\n\n## Z缓冲（Z-Buffer）\n\nOpenGL自动进行深度测试，判断物体的遮挡关系。\n\n```C++\nglEnable(GL_DEPTH_TEST);\n\n// 清理深度缓冲\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n```\n\n## 练习\n\n1. 使用模型矩阵只让是3倍数的箱子旋转（以及第1个箱子），而让剩下的箱子保持静止\n   ```C++\n   for (unsigned int i = 0; i < 10; i++)\n   {\n      glm::mat4 model;\n      model = glm::translate(model, cubePositions[i]);\n      if (i % 3 == 0) {\n            model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), cubePositions[i] + glm::vec3(1.0f, 0.3f, 0.5f));\n      }\n      unsigned int modelLoc = glGetUniformLocation(ourShader.ID, \"model\");\n      glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));\n\n      glDrawArrays(GL_TRIANGLES, 0, 36);\n   }\n   ```\n   ![](/article_img/2022-11-10-16-34-14.png)","source":"_posts/learnopengl-4-变换和坐标系.md","raw":"---\ntitle: learnopengl-4-变换和坐标系\ndate: 2022-11-02\nindex_img: \"/img/bg/opengl.jpg\"\ntags: [OpenGL]\ncategories: \n   -[OpenGL笔记]\n---\n\nlearnopengl-4-变换和坐标系\n<!-- more -->\n\n[坐标系统-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/)\n\n[变换-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/)\n\n# 变换\n\n这一部分设计线性代数的知识，以及在[games101](Games101-2-变换.md)中有过详细介绍，因此这一部分主要记录在OpenGL中的实践，原理不过多解释（如果之后看了[线性代数的本质](https://www.bilibili.com/video/BV1ys411472E/?spm_id_from=333.999.0.0)再进行补充）\n\n## GLM\n\nGLM是OpenGL Mathematics的缩写，它是一个只有头文件的库,把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。\n\n```C++\n#include <glm/glm.hpp>\n#include <glm/gtc/matrix_transform.hpp>\n#include <glm/gtc/type_ptr.hpp>\n```\n这个库使用方法有些独特，定义变换矩阵十分方便：\n```C++\nglm::mat4 trans; // 定义单位矩阵\ntrans = glm::translate(trans, glm::vec3(1.0f, 1.0f, 0.0f));  // 定义位移矩阵调用tranlate函数，参数是位移向量\ntrans = glm::rotation(trans, glm::radians(90.0f), glm::vec3(0.0, 0.0, 1.0)); // 定义旋转矩阵调用rotation函数，参数是旋转角度和旋转轴\ntrans = glm::scale(trans, glm::vec3(0.5, 0.5, 0.5)); // 定义缩放矩阵调用scale函数，参数是x,y,z方向上的缩放值\n```\n\n这些矩阵都是在trans的基础上生成的，相当于和trans右乘，按上面的代码就是先做缩放变换，之后旋转变换，最后位移变换。\n\n## 实践\n\n只需要在顶点着色器中定义一个uniform，将变换矩阵传递进shader，和原来的顶点坐标相乘:\n```C++\n#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec2 aTexCoord;\n\nout vec2 TexCoord;\n\nuniform mat4 transform;\n\nvoid main()\n{\n    gl_Position = transform * vec4(aPos, 1.0f);\n    TexCoord = vec2(aTexCoord.x, 1.0 - aTexCoord.y);\n}\n```\n在程序中将变换矩阵传递给uniform:\n```C++\nunsigned int transformLoc = glGetUniformLocation(ourShader.ID, \"transform\");\nglUniformMatrix4fv(transformLoc, 1, GL_FALSE, glm::value_ptr(trans));\n```\n## 练习\n\n1. 使用应用在箱子上的最后一个变换，尝试将其改变为先旋转，后位移。看看发生了什么，试着想想为什么会发生这样的事情：\n   ![](/article_img/2022-11-02-15-31-22.png)\n   会绕着原点旋转，这里是因为旋转操作都是默认绕原点的，代码中的先旋转后位移在实际变换时是先位移后旋转；\n   如果希望绕任意一点旋转，需要再加一个位移矩阵。\n   ```C++\n    glm::mat4 trans; \n    trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));\n    trans = glm::rotate(trans, (float)glfwGetTime(), glm::vec3(0.0f, 0.0f, 1.0f));\n    trans = glm::translate(trans, glm::vec3(0.5f, -0.5f, 0.0f));\n   ```\n   ![](/article_img/2022-11-02-15-34-54.png)\n2. 尝试再次调用glDrawElements画出第二个箱子，只使用变换将其摆放在不同的位置。让这个箱子被摆放在窗口的左上角，并且会不断的缩放（而不是旋转）。（sin函数在这里会很有用，不过注意使用sin函数时应用负值会导致物体被翻转）\n   ![](/article_img/2022-11-02-15-36-15.png)\n   这里注意调用glDrawElements画出第二个箱子时不需要再绑定别的VAO，但是在画之前要重置变换矩阵，否则就是在同一个位置画了两次，完全看不出。\n\n\n# 坐标系统\n\n![](/article_img/2022-11-10-16-13-36.png)\n\n\"我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。\"\n\n## 局部空间（Local Space）\n\n就像在Blender中创建了一个立方体，原点有可能位于(0, 0, 0)\n\n## 世界空间（World Space）\n\n世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。就是将不同的模型摆放在世界的不同位置，该变换由模型矩阵（Model Matrix）实现。\n\n模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。\n\n## 观察空间（View Space）\n\n观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)），由视图矩阵（View Matrix）实现。\n\n## 裁剪空间（Clip Space）\n\n在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。\n\n投影矩阵分为透视投影（Perspective Projection Matrix）和正交投影（Orthographic Projection Matrix）\n\n正交投影视锥（Frustum）  \n![](/article_img/2022-11-10-16-26-15.png)  \n透视投影视锥（Frustum）  \n![](/article_img/2022-11-10-16-25-36.png)\n\n两种投影方法的对比：\n![](/article_img/2022-11-10-16-24-26.png)\n\n在OpenGL中的用法：\n```C++\n// 正交投影\nglm::ortho(0.0f, 800.0f, 0.0f, 600.0f, 0.1f, 100.0f);\n// 透视投影\nglm::mat4 proj = glm::perspective(glm::radians(45.0f), (float)width/(float)height, 0.1f, 100.0f);\n```\n\n## MVP变换\n\n![](/article_img/2022-11-10-16-28-11.png)\n\n经过Model-View-Projection变换，物体坐标就被变换到了裁剪坐标，之后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标，最后进行视口变换，将坐标映射到屏幕上的每一个像素。\n\n## Z缓冲（Z-Buffer）\n\nOpenGL自动进行深度测试，判断物体的遮挡关系。\n\n```C++\nglEnable(GL_DEPTH_TEST);\n\n// 清理深度缓冲\nglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n```\n\n## 练习\n\n1. 使用模型矩阵只让是3倍数的箱子旋转（以及第1个箱子），而让剩下的箱子保持静止\n   ```C++\n   for (unsigned int i = 0; i < 10; i++)\n   {\n      glm::mat4 model;\n      model = glm::translate(model, cubePositions[i]);\n      if (i % 3 == 0) {\n            model = glm::rotate(model, (float)glfwGetTime() * glm::radians(50.0f), cubePositions[i] + glm::vec3(1.0f, 0.3f, 0.5f));\n      }\n      unsigned int modelLoc = glGetUniformLocation(ourShader.ID, \"model\");\n      glUniformMatrix4fv(modelLoc, 1, GL_FALSE, glm::value_ptr(model));\n\n      glDrawArrays(GL_TRIANGLES, 0, 36);\n   }\n   ```\n   ![](/article_img/2022-11-10-16-34-14.png)","slug":"learnopengl-4-变换和坐标系","published":1,"updated":"2022-11-10T08:38:21.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigm80022w0je2jyzhr07","content":"<p>learnopengl-4-变换和坐标系</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/\">坐标系统-LearnOpenGL CN</a></p>\n<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/\">变换-LearnOpenGL CN</a></p>\n<h1 id=\"变换\"><a href=\"#变换\" class=\"headerlink\" title=\"变换\"></a>变换</h1><p>这一部分设计线性代数的知识，以及在<a href=\"Games101-2-%E5%8F%98%E6%8D%A2.md\">games101</a>中有过详细介绍，因此这一部分主要记录在OpenGL中的实践，原理不过多解释（如果之后看了<a href=\"https://www.bilibili.com/video/BV1ys411472E/?spm_id_from=333.999.0.0\">线性代数的本质</a>再进行补充）</p>\n<h2 id=\"GLM\"><a href=\"#GLM\" class=\"headerlink\" title=\"GLM\"></a>GLM</h2><p>GLM是OpenGL Mathematics的缩写，它是一个只有头文件的库,把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;glm/glm.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;glm/gtc/type_ptr.hpp&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>这个库使用方法有些独特，定义变换矩阵十分方便：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::mat4 trans; <span class=\"hljs-comment\">// 定义单位矩阵</span><br>trans = glm::<span class=\"hljs-built_in\">translate</span>(trans, glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>));  <span class=\"hljs-comment\">// 定义位移矩阵调用tranlate函数，参数是位移向量</span><br>trans = glm::<span class=\"hljs-built_in\">rotation</span>(trans, glm::<span class=\"hljs-built_in\">radians</span>(<span class=\"hljs-number\">90.0f</span>), glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">1.0</span>)); <span class=\"hljs-comment\">// 定义旋转矩阵调用rotation函数，参数是旋转角度和旋转轴</span><br>trans = glm::<span class=\"hljs-built_in\">scale</span>(trans, glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.5</span>)); <span class=\"hljs-comment\">// 定义缩放矩阵调用scale函数，参数是x,y,z方向上的缩放值</span><br></code></pre></td></tr></table></figure>\n\n<p>这些矩阵都是在trans的基础上生成的，相当于和trans右乘，按上面的代码就是先做缩放变换，之后旋转变换，最后位移变换。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>只需要在顶点着色器中定义一个uniform，将变换矩阵传递进shader，和原来的顶点坐标相乘:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec2 aTexCoord;<br><br>out vec2 TexCoord;<br><br>uniform mat4 transform;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = transform * <span class=\"hljs-built_in\">vec4</span>(aPos, <span class=\"hljs-number\">1.0f</span>);<br>    TexCoord = <span class=\"hljs-built_in\">vec2</span>(aTexCoord.x, <span class=\"hljs-number\">1.0</span> - aTexCoord.y);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在程序中将变换矩阵传递给uniform:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> transformLoc = <span class=\"hljs-built_in\">glGetUniformLocation</span>(ourShader.ID, <span class=\"hljs-string\">&quot;transform&quot;</span>);<br><span class=\"hljs-built_in\">glUniformMatrix4fv</span>(transformLoc, <span class=\"hljs-number\">1</span>, GL_FALSE, glm::<span class=\"hljs-built_in\">value_ptr</span>(trans));<br></code></pre></td></tr></table></figure>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><ol>\n<li>使用应用在箱子上的最后一个变换，尝试将其改变为先旋转，后位移。看看发生了什么，试着想想为什么会发生这样的事情：<br><img src=\"/article_img/2022-11-02-15-31-22.png\"><br>会绕着原点旋转，这里是因为旋转操作都是默认绕原点的，代码中的先旋转后位移在实际变换时是先位移后旋转；<br>如果希望绕任意一点旋转，需要再加一个位移矩阵。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::mat4 trans; <br>trans = glm::<span class=\"hljs-built_in\">translate</span>(trans, glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>));<br>trans = glm::<span class=\"hljs-built_in\">rotate</span>(trans, (<span class=\"hljs-type\">float</span>)<span class=\"hljs-built_in\">glfwGetTime</span>(), glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>));<br>trans = glm::<span class=\"hljs-built_in\">translate</span>(trans, glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>));<br></code></pre></td></tr></table></figure>\n<img src=\"/article_img/2022-11-02-15-34-54.png\"></li>\n<li>尝试再次调用glDrawElements画出第二个箱子，只使用变换将其摆放在不同的位置。让这个箱子被摆放在窗口的左上角，并且会不断的缩放（而不是旋转）。（sin函数在这里会很有用，不过注意使用sin函数时应用负值会导致物体被翻转）<br><img src=\"/article_img/2022-11-02-15-36-15.png\"><br>这里注意调用glDrawElements画出第二个箱子时不需要再绑定别的VAO，但是在画之前要重置变换矩阵，否则就是在同一个位置画了两次，完全看不出。</li>\n</ol>\n<h1 id=\"坐标系统\"><a href=\"#坐标系统\" class=\"headerlink\" title=\"坐标系统\"></a>坐标系统</h1><p><img src=\"/article_img/2022-11-10-16-13-36.png\"></p>\n<p>“我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。”</p>\n<h2 id=\"局部空间（Local-Space）\"><a href=\"#局部空间（Local-Space）\" class=\"headerlink\" title=\"局部空间（Local Space）\"></a>局部空间（Local Space）</h2><p>就像在Blender中创建了一个立方体，原点有可能位于(0, 0, 0)</p>\n<h2 id=\"世界空间（World-Space）\"><a href=\"#世界空间（World-Space）\" class=\"headerlink\" title=\"世界空间（World Space）\"></a>世界空间（World Space）</h2><p>世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。就是将不同的模型摆放在世界的不同位置，该变换由模型矩阵（Model Matrix）实现。</p>\n<p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。</p>\n<h2 id=\"观察空间（View-Space）\"><a href=\"#观察空间（View-Space）\" class=\"headerlink\" title=\"观察空间（View Space）\"></a>观察空间（View Space）</h2><p>观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)），由视图矩阵（View Matrix）实现。</p>\n<h2 id=\"裁剪空间（Clip-Space）\"><a href=\"#裁剪空间（Clip-Space）\" class=\"headerlink\" title=\"裁剪空间（Clip Space）\"></a>裁剪空间（Clip Space）</h2><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。</p>\n<p>投影矩阵分为透视投影（Perspective Projection Matrix）和正交投影（Orthographic Projection Matrix）</p>\n<p>正交投影视锥（Frustum）<br><img src=\"/article_img/2022-11-10-16-26-15.png\"><br>透视投影视锥（Frustum）<br><img src=\"/article_img/2022-11-10-16-25-36.png\"></p>\n<p>两种投影方法的对比：<br><img src=\"/article_img/2022-11-10-16-24-26.png\"></p>\n<p>在OpenGL中的用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 正交投影</span><br>glm::<span class=\"hljs-built_in\">ortho</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">800.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">600.0f</span>, <span class=\"hljs-number\">0.1f</span>, <span class=\"hljs-number\">100.0f</span>);<br><span class=\"hljs-comment\">// 透视投影</span><br>glm::mat4 proj = glm::<span class=\"hljs-built_in\">perspective</span>(glm::<span class=\"hljs-built_in\">radians</span>(<span class=\"hljs-number\">45.0f</span>), (<span class=\"hljs-type\">float</span>)width/(<span class=\"hljs-type\">float</span>)height, <span class=\"hljs-number\">0.1f</span>, <span class=\"hljs-number\">100.0f</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"MVP变换\"><a href=\"#MVP变换\" class=\"headerlink\" title=\"MVP变换\"></a>MVP变换</h2><p><img src=\"/article_img/2022-11-10-16-28-11.png\"></p>\n<p>经过Model-View-Projection变换，物体坐标就被变换到了裁剪坐标，之后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标，最后进行视口变换，将坐标映射到屏幕上的每一个像素。</p>\n<h2 id=\"Z缓冲（Z-Buffer）\"><a href=\"#Z缓冲（Z-Buffer）\" class=\"headerlink\" title=\"Z缓冲（Z-Buffer）\"></a>Z缓冲（Z-Buffer）</h2><p>OpenGL自动进行深度测试，判断物体的遮挡关系。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glEnable</span>(GL_DEPTH_TEST);<br><br><span class=\"hljs-comment\">// 清理深度缓冲</span><br><span class=\"hljs-built_in\">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h2><ol>\n<li>使用模型矩阵只让是3倍数的箱子旋转（以及第1个箱子），而让剩下的箱子保持静止<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>&#123;<br>   glm::mat4 model;<br>   model = glm::<span class=\"hljs-built_in\">translate</span>(model, cubePositions[i]);<br>   <span class=\"hljs-keyword\">if</span> (i % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>) &#123;<br>         model = glm::<span class=\"hljs-built_in\">rotate</span>(model, (<span class=\"hljs-type\">float</span>)<span class=\"hljs-built_in\">glfwGetTime</span>() * glm::<span class=\"hljs-built_in\">radians</span>(<span class=\"hljs-number\">50.0f</span>), cubePositions[i] + glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.3f</span>, <span class=\"hljs-number\">0.5f</span>));<br>   &#125;<br>   <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> modelLoc = <span class=\"hljs-built_in\">glGetUniformLocation</span>(ourShader.ID, <span class=\"hljs-string\">&quot;model&quot;</span>);<br>   <span class=\"hljs-built_in\">glUniformMatrix4fv</span>(modelLoc, <span class=\"hljs-number\">1</span>, GL_FALSE, glm::<span class=\"hljs-built_in\">value_ptr</span>(model));<br><br>   <span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">36</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article_img/2022-11-10-16-34-14.png\"></li>\n</ol>\n","site":{"data":{}},"wordcount":3313,"excerpt":"<p>learnopengl-4-变换和坐标系</p>","more":"<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/08%20Coordinate%20Systems/\">坐标系统-LearnOpenGL CN</a></p>\n<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/\">变换-LearnOpenGL CN</a></p>\n<h1 id=\"变换\"><a href=\"#变换\" class=\"headerlink\" title=\"变换\"></a>变换</h1><p>这一部分设计线性代数的知识，以及在<a href=\"Games101-2-%E5%8F%98%E6%8D%A2.md\">games101</a>中有过详细介绍，因此这一部分主要记录在OpenGL中的实践，原理不过多解释（如果之后看了<a href=\"https://www.bilibili.com/video/BV1ys411472E/?spm_id_from=333.999.0.0\">线性代数的本质</a>再进行补充）</p>\n<h2 id=\"GLM\"><a href=\"#GLM\" class=\"headerlink\" title=\"GLM\"></a>GLM</h2><p>GLM是OpenGL Mathematics的缩写，它是一个只有头文件的库,把头文件的根目录复制到你的includes文件夹，然后你就可以使用这个库了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;glm/glm.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;glm/gtc/matrix_transform.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;glm/gtc/type_ptr.hpp&gt;</span></span><br></code></pre></td></tr></table></figure>\n<p>这个库使用方法有些独特，定义变换矩阵十分方便：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::mat4 trans; <span class=\"hljs-comment\">// 定义单位矩阵</span><br>trans = glm::<span class=\"hljs-built_in\">translate</span>(trans, glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>));  <span class=\"hljs-comment\">// 定义位移矩阵调用tranlate函数，参数是位移向量</span><br>trans = glm::<span class=\"hljs-built_in\">rotation</span>(trans, glm::<span class=\"hljs-built_in\">radians</span>(<span class=\"hljs-number\">90.0f</span>), glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">1.0</span>)); <span class=\"hljs-comment\">// 定义旋转矩阵调用rotation函数，参数是旋转角度和旋转轴</span><br>trans = glm::<span class=\"hljs-built_in\">scale</span>(trans, glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.5</span>, <span class=\"hljs-number\">0.5</span>)); <span class=\"hljs-comment\">// 定义缩放矩阵调用scale函数，参数是x,y,z方向上的缩放值</span><br></code></pre></td></tr></table></figure>\n\n<p>这些矩阵都是在trans的基础上生成的，相当于和trans右乘，按上面的代码就是先做缩放变换，之后旋转变换，最后位移变换。</p>\n<h2 id=\"实践\"><a href=\"#实践\" class=\"headerlink\" title=\"实践\"></a>实践</h2><p>只需要在顶点着色器中定义一个uniform，将变换矩阵传递进shader，和原来的顶点坐标相乘:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec2 aTexCoord;<br><br>out vec2 TexCoord;<br><br>uniform mat4 transform;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = transform * <span class=\"hljs-built_in\">vec4</span>(aPos, <span class=\"hljs-number\">1.0f</span>);<br>    TexCoord = <span class=\"hljs-built_in\">vec2</span>(aTexCoord.x, <span class=\"hljs-number\">1.0</span> - aTexCoord.y);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在程序中将变换矩阵传递给uniform:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> transformLoc = <span class=\"hljs-built_in\">glGetUniformLocation</span>(ourShader.ID, <span class=\"hljs-string\">&quot;transform&quot;</span>);<br><span class=\"hljs-built_in\">glUniformMatrix4fv</span>(transformLoc, <span class=\"hljs-number\">1</span>, GL_FALSE, glm::<span class=\"hljs-built_in\">value_ptr</span>(trans));<br></code></pre></td></tr></table></figure>\n<h2 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h2><ol>\n<li>使用应用在箱子上的最后一个变换，尝试将其改变为先旋转，后位移。看看发生了什么，试着想想为什么会发生这样的事情：<br><img src=\"/article_img/2022-11-02-15-31-22.png\"><br>会绕着原点旋转，这里是因为旋转操作都是默认绕原点的，代码中的先旋转后位移在实际变换时是先位移后旋转；<br>如果希望绕任意一点旋转，需要再加一个位移矩阵。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::mat4 trans; <br>trans = glm::<span class=\"hljs-built_in\">translate</span>(trans, glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>));<br>trans = glm::<span class=\"hljs-built_in\">rotate</span>(trans, (<span class=\"hljs-type\">float</span>)<span class=\"hljs-built_in\">glfwGetTime</span>(), glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>));<br>trans = glm::<span class=\"hljs-built_in\">translate</span>(trans, glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>));<br></code></pre></td></tr></table></figure>\n<img src=\"/article_img/2022-11-02-15-34-54.png\"></li>\n<li>尝试再次调用glDrawElements画出第二个箱子，只使用变换将其摆放在不同的位置。让这个箱子被摆放在窗口的左上角，并且会不断的缩放（而不是旋转）。（sin函数在这里会很有用，不过注意使用sin函数时应用负值会导致物体被翻转）<br><img src=\"/article_img/2022-11-02-15-36-15.png\"><br>这里注意调用glDrawElements画出第二个箱子时不需要再绑定别的VAO，但是在画之前要重置变换矩阵，否则就是在同一个位置画了两次，完全看不出。</li>\n</ol>\n<h1 id=\"坐标系统\"><a href=\"#坐标系统\" class=\"headerlink\" title=\"坐标系统\"></a>坐标系统</h1><p><img src=\"/article_img/2022-11-10-16-13-36.png\"></p>\n<p>“我们之所以将顶点变换到各个不同的空间的原因是有些操作在特定的坐标系统中才有意义且更方便。例如，当需要对物体进行修改的时候，在局部空间中来操作会更说得通；如果要对一个物体做出一个相对于其它物体位置的操作时，在世界坐标系中来做这个才更说得通，等等。如果我们愿意，我们也可以定义一个直接从局部空间变换到裁剪空间的变换矩阵，但那样会失去很多灵活性。”</p>\n<h2 id=\"局部空间（Local-Space）\"><a href=\"#局部空间（Local-Space）\" class=\"headerlink\" title=\"局部空间（Local Space）\"></a>局部空间（Local Space）</h2><p>就像在Blender中创建了一个立方体，原点有可能位于(0, 0, 0)</p>\n<h2 id=\"世界空间（World-Space）\"><a href=\"#世界空间（World-Space）\" class=\"headerlink\" title=\"世界空间（World Space）\"></a>世界空间（World Space）</h2><p>世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。就是将不同的模型摆放在世界的不同位置，该变换由模型矩阵（Model Matrix）实现。</p>\n<p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。</p>\n<h2 id=\"观察空间（View-Space）\"><a href=\"#观察空间（View-Space）\" class=\"headerlink\" title=\"观察空间（View Space）\"></a>观察空间（View Space）</h2><p>观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)），由视图矩阵（View Matrix）实现。</p>\n<h2 id=\"裁剪空间（Clip-Space）\"><a href=\"#裁剪空间（Clip-Space）\" class=\"headerlink\" title=\"裁剪空间（Clip Space）\"></a>裁剪空间（Clip Space）</h2><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。</p>\n<p>投影矩阵分为透视投影（Perspective Projection Matrix）和正交投影（Orthographic Projection Matrix）</p>\n<p>正交投影视锥（Frustum）<br><img src=\"/article_img/2022-11-10-16-26-15.png\"><br>透视投影视锥（Frustum）<br><img src=\"/article_img/2022-11-10-16-25-36.png\"></p>\n<p>两种投影方法的对比：<br><img src=\"/article_img/2022-11-10-16-24-26.png\"></p>\n<p>在OpenGL中的用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 正交投影</span><br>glm::<span class=\"hljs-built_in\">ortho</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">800.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">600.0f</span>, <span class=\"hljs-number\">0.1f</span>, <span class=\"hljs-number\">100.0f</span>);<br><span class=\"hljs-comment\">// 透视投影</span><br>glm::mat4 proj = glm::<span class=\"hljs-built_in\">perspective</span>(glm::<span class=\"hljs-built_in\">radians</span>(<span class=\"hljs-number\">45.0f</span>), (<span class=\"hljs-type\">float</span>)width/(<span class=\"hljs-type\">float</span>)height, <span class=\"hljs-number\">0.1f</span>, <span class=\"hljs-number\">100.0f</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"MVP变换\"><a href=\"#MVP变换\" class=\"headerlink\" title=\"MVP变换\"></a>MVP变换</h2><p><img src=\"/article_img/2022-11-10-16-28-11.png\"></p>\n<p>经过Model-View-Projection变换，物体坐标就被变换到了裁剪坐标，之后对裁剪坐标执行透视除法从而将它们变换到标准化设备坐标，最后进行视口变换，将坐标映射到屏幕上的每一个像素。</p>\n<h2 id=\"Z缓冲（Z-Buffer）\"><a href=\"#Z缓冲（Z-Buffer）\" class=\"headerlink\" title=\"Z缓冲（Z-Buffer）\"></a>Z缓冲（Z-Buffer）</h2><p>OpenGL自动进行深度测试，判断物体的遮挡关系。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glEnable</span>(GL_DEPTH_TEST);<br><br><span class=\"hljs-comment\">// 清理深度缓冲</span><br><span class=\"hljs-built_in\">glClear</span>(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h2><ol>\n<li>使用模型矩阵只让是3倍数的箱子旋转（以及第1个箱子），而让剩下的箱子保持静止<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>&#123;<br>   glm::mat4 model;<br>   model = glm::<span class=\"hljs-built_in\">translate</span>(model, cubePositions[i]);<br>   <span class=\"hljs-keyword\">if</span> (i % <span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>) &#123;<br>         model = glm::<span class=\"hljs-built_in\">rotate</span>(model, (<span class=\"hljs-type\">float</span>)<span class=\"hljs-built_in\">glfwGetTime</span>() * glm::<span class=\"hljs-built_in\">radians</span>(<span class=\"hljs-number\">50.0f</span>), cubePositions[i] + glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.3f</span>, <span class=\"hljs-number\">0.5f</span>));<br>   &#125;<br>   <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> modelLoc = <span class=\"hljs-built_in\">glGetUniformLocation</span>(ourShader.ID, <span class=\"hljs-string\">&quot;model&quot;</span>);<br>   <span class=\"hljs-built_in\">glUniformMatrix4fv</span>(modelLoc, <span class=\"hljs-number\">1</span>, GL_FALSE, glm::<span class=\"hljs-built_in\">value_ptr</span>(model));<br><br>   <span class=\"hljs-built_in\">glDrawArrays</span>(GL_TRIANGLES, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">36</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n<img src=\"/article_img/2022-11-10-16-34-14.png\"></li>\n</ol>"},{"title":"learnopengl-3-纹理","date":"2022-10-31T16:00:00.000Z","index_img":"/img/bg/opengl.jpg","_content":"\nlearnopengl-3-纹理\n<!-- more -->\n\n[纹理-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/)\n\n纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。\n\n# 纹理坐标\n\n用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。\n\n![](/article_img/2022-11-01-16-58-12.png)\n\n纹理坐标格式：\n\n```c++\nfloat texCoords[] = {\n    0.0f, 0.0f, // 左下角\n    1.0f, 0.0f, // 右下角\n    0.5f, 1.0f // 上中\n};\n```\n\n# 纹理环绕方式\n\n| 环绕方式  | 描述  |\n| :---: | :---: |\n|   GL_REPEAT   |   对纹理的默认行为。重复纹理图像。   |\n|   GL_MIRRORED_REPEAT   |   和GL_REPEAT一样，但每次重复图片是镜像放置的。   |\n|   GL_CLAMP_TO_EDGE  | 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。 |\n|   GL_CLAMP_TO_BORDER | 超出的坐标为用户指定的边缘颜色 |\n\n![](/article_img/2022-11-01-17-15-23.png)\n\n用法：  \n\n```C++\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);\n```\n可以单独对坐标轴设置纹理环绕方式。\n\nGL_CLAMP_TO_BORDER 方式由于是用户指定的边缘颜色，因此要再指定一个边缘的颜色，同时也不需要再指定坐标轴了。\n```C++\nfloat borderColor[] = {1.0f, 1.0f, 0.0f, 1.0f};\nglTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);\n```\n\n# 纹理过滤\n\n## 纹理像素（Texture Pixel）\n\nTexture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素，其实就是**纹理的分辨率**。\n\n如果要将一个分辨率较低的纹理加在一个很大的物体上，看上去物体的分辨率就很低，为了减轻这种现象，需要纹理过滤。\n\n## 纹理过滤\n\n这一部分在[Games101-着色](Games101-4-着色.md)中有过详细介绍\n\n1. 邻近过滤（GL_NEAREST）  \n   ![](/article_img/2022-11-01-17-16-23.png)\n2. 线性过滤（GL_LINEAR）  \n   ![](/article_img/2022-11-01-17-16-55.png)  \n   使用的算法就是双线性插值，由周围几个像素的颜色算出最终应该采用的颜色。  \n   ![](/article_img/2022-08-29-18-33-20.png)\n\n下图是两种过滤方法的效果对比\n![](/article_img/2022-11-01-17-17-08.png)\n\n用法：\n```C++\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER， GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER， GL_LINEAR);\n```\n\n# 多级渐远纹理\n\n这一部分也在[Games101-着色](Games101-4-着色.md)中有过详细介绍\n\n当物体很小，而纹理分辨率很大的时候难以决定最终真正显示的像素的颜色，因为最终可见的像素很可能覆盖了纹理贴图上的很大一部分，同时还会产生很多浪费。\n\nOpenGL中使用Mipmap解决这个问题。\n\n![](/article_img/2022-08-29-18-41-41.png)\n\n可以使用glGenerateMipmaps函数来自动生成Mipmap\n\n![](/article_img/2022-11-01-17-30-18.png)\n\n在切换Mipmap时，在两个层之间会产生生硬的边界，因此在切换时也需要过滤。\n\n| 过滤方式  | 描述  |\n| :---: | :---: |\n|   GL_NEAREST_MIPMAP_NEAREST   |   使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样   |\n|   GL_LINEAR_MIPMAP_NEAREST   |   使用最邻近的多级渐远纹理级别，并使用线性插值进行采样   |\n|   GL_NEAREST_MIPMAP_LINEAR | 在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样 |\n|   GL_LINEAR_MIPMAP_LINEAR | 在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样 |\n\n![](/article_img/2022-08-29-18-52-05.png)\n\n这里看这个三线性插值（GL_LINEAR_MIPMAP_LINEAR）的原理图就很容易理解，GL_**A**\\_MIPMAP_**B** 中**A**是指不同层级之间的切换方式，**B**指每个层级内部的选择方式。\n\n使用：\n```C++\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n```\n\n注意：  \n函数的第二个参数，是分别设置纹理缩小时过滤和纹理放大时过滤的参数。**Mipmap只在纹理被缩小时有效。**\n\n# 加载与创建纹理\n\n## stb_image.h\n\n加载纹理使用stb_image.h头文件，这个头文件中就包含了函数的实现，因此只需要将其添加到工程中，再创建一个C++文件输入：\n```C++\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"\n```\n即可调用**stbi_load**函数进行图片的加载。\n\n## 生成纹理\n\n生成一个纹理的过程：\n```C++\nunsigned int texture;\nglGenTextures(1, &texture);\nglBindTexture(GL_TEXTURE_2D, texture);\n// 为当前绑定的纹理对象设置环绕、过滤方式\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n// 加载并生成纹理\nint width, height, nrChannels;\nunsigned char *data = stbi_load(\"container.jpg\", &width, &height, &nrChannels, 0);\nif (data)\n{   \n    // 生成纹理\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\n    glGenerateMipmap(GL_TEXTURE_2D);\n}\nelse\n{\n    std::cout << \"Failed to load texture\" << std::endl;\n}\nstbi_image_free(data);\n```\n\n# 应用纹理\n\n## 基本应用\n\n纹理的应用需要相应的改变着色器代码，在顶点着色器中设定一个输出向量将纹理坐标传给片段着色器，在片段着色器中定义一个类型是sampler2D的uniform用来接收纹理图片，最后调用GLSL中的texture函数来采样纹理的颜色。\n\nsampler2D是一个GLSL的数据类型，叫做采样器，还有sampler1D, sampler3D, 用来把纹理对象传给片段着色器。\n\n顶点着色器：\n```C++\n#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aColor;\nlayout (location = 2) in vec2 aTexCoord;\n\nout vec3 ourColor;\nout vec2 TexCoord;\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 1.0);\n    ourColor = aColor;\n    TexCoord = aTexCoord;\n}\n```\n\n片段着色器：\n```C++\n#version 330 core\nout vec4 FragColor;\n\nin vec3 ourColor;\nin vec2 TexCoord;\n\nuniform sampler2D ourTexture;\n\nvoid main()\n{\n    FragColor = texture(ourTexture, TexCoord);\n}\n```\n\n渲染循环：\n```C++\nglBindTexture(GL_TEXTURE_2D, texture);\nglBindVertexArray(VAO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\n```\n\n## 纹理单元\n\n![](/article_img/2022-11-02-15-10-07.png)\n\n纹理单元的目的是为了让我们可以使用多个纹理，通过把纹理单元**赋值**给采样器，我们可以一次绑定多个纹理，只要我们首先**激活**对应的纹理单元；\n\nOpenGL保证有16个纹理单元供使用，且GL_TEXTRUE0默认被激活，所以只用一个纹理时可以不激活纹理单元0。\n\n使用方法：\n```C++\n\n\n// 激活纹理单元并将纹理绑定到相应的纹理单元\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, texture1);\nglTexImage2D(..., data1);\nglGenerateMipmap(GL_TEXTURE_2D);\nglActiveTexture(GL_TEXTURE1);\nglBindTexture(GL_TEXTURE_2D, texture2);\nglTexImage2D(..., data2);\nglGenerateMipmap(GL_TEXTURE_2D)\n\n// 设置uniform的值\nourShader.setInt(\"texture1\", 0);\nourShader.setInt(\"texture2\", 1);\n```\n\n# 练习\n\n1. 修改片段着色器，仅让笑脸图案朝另一个方向看\n   ```C++\n   FragColor = mix(texture(texture1, TexCoord), texture(texture2, vec2(1.0 - TexCoord.x, TexCoord.y)), 0.2);\n   ```\n2. 尝试用不同的纹理环绕方式，设定一个从0.0f到2.0f范围内的（而不是原来的0.0f到1.0f）纹理坐标。试试看能不能在箱子的角落放置4个笑脸。记得一定要试试其它的环绕方式。\n\n    环绕方式和过滤方式需要对不同的纹理分别设置\n   ```C++\n    unsigned int texture1, texture2;\n    glGenTextures(1, &texture1);\n    glActiveTexture(GL_TEXTURE0);\n    glBindTexture(GL_TEXTURE_2D, texture1);\n    // 设置环绕，过滤方式\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data1);\n    glGenerateMipmap(GL_TEXTURE_2D);\n    // 释放图像内存\n    stbi_image_free(data1);\n\n    glGenTextures(1, &texture2);\n    glActiveTexture(GL_TEXTURE2);\n    glBindTexture(GL_TEXTURE_2D, texture2);\n    // 设置环绕，过滤方式\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data2);\n    glGenerateMipmap(GL_TEXTURE_2D);\n   ```\n   ![](/article_img/2022-11-01-19-04-15.png)\n3. 尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰\n   ```C++\n    float offset = 0.03;\n\n    float vertices[] = {\n        //     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -\n         0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   0.5f + offset, 0.5f + offset,   // 右上\n         0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   0.5f + offset, 0.5f - offset,   // 右下\n        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.5f - offset, 0.5f - offset,   // 左下\n        -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.5f - offset, 0.5f + offset    // 左上\n    };\n   ```\n   将纹理放大后的效果：\n   ![](/article_img/2022-11-01-19-10-25.png)\n   ```C++\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n   ```\n   可以明显看出使用GL_LINEAR过滤方法锯齿感更弱\n   ![](/article_img/2022-11-01-19-12-45.png)\n4. 使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度\n   ![](/article_img/2022-11-01-19-40-30.png)\n   ![](/article_img/2022-11-01-19-40-57.png)\n   ```C++\n   // 输入函数，让所有输入代码保持整洁\n    void processInput(GLFWwindow* window, float &mix_ratio) {\n        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {\n            std::cout << \"ESCAPE PRESSED!\" << std::endl;\n            glfwSetWindowShouldClose(window, true);\n        }\n            \n        if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS) {\n            mix_ratio += 0.1f;\n            if (mix_ratio > 1.0f)\n                mix_ratio = 1.0f;\n            std::cout << \"UP PRESSED!\" << std::endl;\n        }\n        if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS) {\n            mix_ratio -= 0.1f;\n            if (mix_ratio < 0.0f)\n                mix_ratio = 0.0f;\n            std::cout << \"DOWN PRESSED!\" << std::endl;\n        }\n    }\n\n    // 渲染循环\n    ourShader.setFloat(\"mix_ratio\", mix_ratio);\n\n   ```","source":"_posts/learnopengl-3-纹理.md","raw":"---\ntitle: learnopengl-3-纹理\ndate: 2022-11-01\nindex_img: \"/img/bg/opengl.jpg\"\ntags: [OpenGL]\ncategories: \n   -[OpenGL笔记]\n---\n\nlearnopengl-3-纹理\n<!-- more -->\n\n[纹理-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/)\n\n纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。\n\n# 纹理坐标\n\n用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。\n\n![](/article_img/2022-11-01-16-58-12.png)\n\n纹理坐标格式：\n\n```c++\nfloat texCoords[] = {\n    0.0f, 0.0f, // 左下角\n    1.0f, 0.0f, // 右下角\n    0.5f, 1.0f // 上中\n};\n```\n\n# 纹理环绕方式\n\n| 环绕方式  | 描述  |\n| :---: | :---: |\n|   GL_REPEAT   |   对纹理的默认行为。重复纹理图像。   |\n|   GL_MIRRORED_REPEAT   |   和GL_REPEAT一样，但每次重复图片是镜像放置的。   |\n|   GL_CLAMP_TO_EDGE  | 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。 |\n|   GL_CLAMP_TO_BORDER | 超出的坐标为用户指定的边缘颜色 |\n\n![](/article_img/2022-11-01-17-15-23.png)\n\n用法：  \n\n```C++\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);\n```\n可以单独对坐标轴设置纹理环绕方式。\n\nGL_CLAMP_TO_BORDER 方式由于是用户指定的边缘颜色，因此要再指定一个边缘的颜色，同时也不需要再指定坐标轴了。\n```C++\nfloat borderColor[] = {1.0f, 1.0f, 0.0f, 1.0f};\nglTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);\n```\n\n# 纹理过滤\n\n## 纹理像素（Texture Pixel）\n\nTexture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素，其实就是**纹理的分辨率**。\n\n如果要将一个分辨率较低的纹理加在一个很大的物体上，看上去物体的分辨率就很低，为了减轻这种现象，需要纹理过滤。\n\n## 纹理过滤\n\n这一部分在[Games101-着色](Games101-4-着色.md)中有过详细介绍\n\n1. 邻近过滤（GL_NEAREST）  \n   ![](/article_img/2022-11-01-17-16-23.png)\n2. 线性过滤（GL_LINEAR）  \n   ![](/article_img/2022-11-01-17-16-55.png)  \n   使用的算法就是双线性插值，由周围几个像素的颜色算出最终应该采用的颜色。  \n   ![](/article_img/2022-08-29-18-33-20.png)\n\n下图是两种过滤方法的效果对比\n![](/article_img/2022-11-01-17-17-08.png)\n\n用法：\n```C++\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER， GL_NEAREST);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER， GL_LINEAR);\n```\n\n# 多级渐远纹理\n\n这一部分也在[Games101-着色](Games101-4-着色.md)中有过详细介绍\n\n当物体很小，而纹理分辨率很大的时候难以决定最终真正显示的像素的颜色，因为最终可见的像素很可能覆盖了纹理贴图上的很大一部分，同时还会产生很多浪费。\n\nOpenGL中使用Mipmap解决这个问题。\n\n![](/article_img/2022-08-29-18-41-41.png)\n\n可以使用glGenerateMipmaps函数来自动生成Mipmap\n\n![](/article_img/2022-11-01-17-30-18.png)\n\n在切换Mipmap时，在两个层之间会产生生硬的边界，因此在切换时也需要过滤。\n\n| 过滤方式  | 描述  |\n| :---: | :---: |\n|   GL_NEAREST_MIPMAP_NEAREST   |   使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样   |\n|   GL_LINEAR_MIPMAP_NEAREST   |   使用最邻近的多级渐远纹理级别，并使用线性插值进行采样   |\n|   GL_NEAREST_MIPMAP_LINEAR | 在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样 |\n|   GL_LINEAR_MIPMAP_LINEAR | 在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样 |\n\n![](/article_img/2022-08-29-18-52-05.png)\n\n这里看这个三线性插值（GL_LINEAR_MIPMAP_LINEAR）的原理图就很容易理解，GL_**A**\\_MIPMAP_**B** 中**A**是指不同层级之间的切换方式，**B**指每个层级内部的选择方式。\n\n使用：\n```C++\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n```\n\n注意：  \n函数的第二个参数，是分别设置纹理缩小时过滤和纹理放大时过滤的参数。**Mipmap只在纹理被缩小时有效。**\n\n# 加载与创建纹理\n\n## stb_image.h\n\n加载纹理使用stb_image.h头文件，这个头文件中就包含了函数的实现，因此只需要将其添加到工程中，再创建一个C++文件输入：\n```C++\n#define STB_IMAGE_IMPLEMENTATION\n#include \"stb_image.h\"\n```\n即可调用**stbi_load**函数进行图片的加载。\n\n## 生成纹理\n\n生成一个纹理的过程：\n```C++\nunsigned int texture;\nglGenTextures(1, &texture);\nglBindTexture(GL_TEXTURE_2D, texture);\n// 为当前绑定的纹理对象设置环绕、过滤方式\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   \nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\nglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n// 加载并生成纹理\nint width, height, nrChannels;\nunsigned char *data = stbi_load(\"container.jpg\", &width, &height, &nrChannels, 0);\nif (data)\n{   \n    // 生成纹理\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data);\n    glGenerateMipmap(GL_TEXTURE_2D);\n}\nelse\n{\n    std::cout << \"Failed to load texture\" << std::endl;\n}\nstbi_image_free(data);\n```\n\n# 应用纹理\n\n## 基本应用\n\n纹理的应用需要相应的改变着色器代码，在顶点着色器中设定一个输出向量将纹理坐标传给片段着色器，在片段着色器中定义一个类型是sampler2D的uniform用来接收纹理图片，最后调用GLSL中的texture函数来采样纹理的颜色。\n\nsampler2D是一个GLSL的数据类型，叫做采样器，还有sampler1D, sampler3D, 用来把纹理对象传给片段着色器。\n\n顶点着色器：\n```C++\n#version 330 core\nlayout (location = 0) in vec3 aPos;\nlayout (location = 1) in vec3 aColor;\nlayout (location = 2) in vec2 aTexCoord;\n\nout vec3 ourColor;\nout vec2 TexCoord;\n\nvoid main()\n{\n    gl_Position = vec4(aPos, 1.0);\n    ourColor = aColor;\n    TexCoord = aTexCoord;\n}\n```\n\n片段着色器：\n```C++\n#version 330 core\nout vec4 FragColor;\n\nin vec3 ourColor;\nin vec2 TexCoord;\n\nuniform sampler2D ourTexture;\n\nvoid main()\n{\n    FragColor = texture(ourTexture, TexCoord);\n}\n```\n\n渲染循环：\n```C++\nglBindTexture(GL_TEXTURE_2D, texture);\nglBindVertexArray(VAO);\nglDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);\n```\n\n## 纹理单元\n\n![](/article_img/2022-11-02-15-10-07.png)\n\n纹理单元的目的是为了让我们可以使用多个纹理，通过把纹理单元**赋值**给采样器，我们可以一次绑定多个纹理，只要我们首先**激活**对应的纹理单元；\n\nOpenGL保证有16个纹理单元供使用，且GL_TEXTRUE0默认被激活，所以只用一个纹理时可以不激活纹理单元0。\n\n使用方法：\n```C++\n\n\n// 激活纹理单元并将纹理绑定到相应的纹理单元\nglActiveTexture(GL_TEXTURE0);\nglBindTexture(GL_TEXTURE_2D, texture1);\nglTexImage2D(..., data1);\nglGenerateMipmap(GL_TEXTURE_2D);\nglActiveTexture(GL_TEXTURE1);\nglBindTexture(GL_TEXTURE_2D, texture2);\nglTexImage2D(..., data2);\nglGenerateMipmap(GL_TEXTURE_2D)\n\n// 设置uniform的值\nourShader.setInt(\"texture1\", 0);\nourShader.setInt(\"texture2\", 1);\n```\n\n# 练习\n\n1. 修改片段着色器，仅让笑脸图案朝另一个方向看\n   ```C++\n   FragColor = mix(texture(texture1, TexCoord), texture(texture2, vec2(1.0 - TexCoord.x, TexCoord.y)), 0.2);\n   ```\n2. 尝试用不同的纹理环绕方式，设定一个从0.0f到2.0f范围内的（而不是原来的0.0f到1.0f）纹理坐标。试试看能不能在箱子的角落放置4个笑脸。记得一定要试试其它的环绕方式。\n\n    环绕方式和过滤方式需要对不同的纹理分别设置\n   ```C++\n    unsigned int texture1, texture2;\n    glGenTextures(1, &texture1);\n    glActiveTexture(GL_TEXTURE0);\n    glBindTexture(GL_TEXTURE_2D, texture1);\n    // 设置环绕，过滤方式\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_BYTE, data1);\n    glGenerateMipmap(GL_TEXTURE_2D);\n    // 释放图像内存\n    stbi_image_free(data1);\n\n    glGenTextures(1, &texture2);\n    glActiveTexture(GL_TEXTURE2);\n    glBindTexture(GL_TEXTURE_2D, texture2);\n    // 设置环绕，过滤方式\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);\n\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data2);\n    glGenerateMipmap(GL_TEXTURE_2D);\n   ```\n   ![](/article_img/2022-11-01-19-04-15.png)\n3. 尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰\n   ```C++\n    float offset = 0.03;\n\n    float vertices[] = {\n        //     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -\n         0.5f,  0.5f, 0.0f,   1.0f, 0.0f, 0.0f,   0.5f + offset, 0.5f + offset,   // 右上\n         0.5f, -0.5f, 0.0f,   0.0f, 1.0f, 0.0f,   0.5f + offset, 0.5f - offset,   // 右下\n        -0.5f, -0.5f, 0.0f,   0.0f, 0.0f, 1.0f,   0.5f - offset, 0.5f - offset,   // 左下\n        -0.5f,  0.5f, 0.0f,   1.0f, 1.0f, 0.0f,   0.5f - offset, 0.5f + offset    // 左上\n    };\n   ```\n   将纹理放大后的效果：\n   ![](/article_img/2022-11-01-19-10-25.png)\n   ```C++\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n   ```\n   可以明显看出使用GL_LINEAR过滤方法锯齿感更弱\n   ![](/article_img/2022-11-01-19-12-45.png)\n4. 使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度\n   ![](/article_img/2022-11-01-19-40-30.png)\n   ![](/article_img/2022-11-01-19-40-57.png)\n   ```C++\n   // 输入函数，让所有输入代码保持整洁\n    void processInput(GLFWwindow* window, float &mix_ratio) {\n        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {\n            std::cout << \"ESCAPE PRESSED!\" << std::endl;\n            glfwSetWindowShouldClose(window, true);\n        }\n            \n        if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS) {\n            mix_ratio += 0.1f;\n            if (mix_ratio > 1.0f)\n                mix_ratio = 1.0f;\n            std::cout << \"UP PRESSED!\" << std::endl;\n        }\n        if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS) {\n            mix_ratio -= 0.1f;\n            if (mix_ratio < 0.0f)\n                mix_ratio = 0.0f;\n            std::cout << \"DOWN PRESSED!\" << std::endl;\n        }\n    }\n\n    // 渲染循环\n    ourShader.setFloat(\"mix_ratio\", mix_ratio);\n\n   ```","slug":"learnopengl-3-纹理","published":1,"updated":"2022-11-10T06:12:52.989Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigm90026w0je86zd3fy2","content":"<p>learnopengl-3-纹理</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/\">纹理-LearnOpenGL CN</a></p>\n<p>纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。</p>\n<h1 id=\"纹理坐标\"><a href=\"#纹理坐标\" class=\"headerlink\" title=\"纹理坐标\"></a>纹理坐标</h1><p>用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。</p>\n<p><img src=\"/article_img/2022-11-01-16-58-12.png\"></p>\n<p>纹理坐标格式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> texCoords[] = &#123;<br>    <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-comment\">// 左下角</span><br>    <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-comment\">// 右下角</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">1.0f</span> <span class=\"hljs-comment\">// 上中</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"纹理环绕方式\"><a href=\"#纹理环绕方式\" class=\"headerlink\" title=\"纹理环绕方式\"></a>纹理环绕方式</h1><table>\n<thead>\n<tr>\n<th align=\"center\">环绕方式</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">GL_REPEAT</td>\n<td align=\"center\">对纹理的默认行为。重复纹理图像。</td>\n</tr>\n<tr>\n<td align=\"center\">GL_MIRRORED_REPEAT</td>\n<td align=\"center\">和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>\n</tr>\n<tr>\n<td align=\"center\">GL_CLAMP_TO_EDGE</td>\n<td align=\"center\">纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>\n</tr>\n<tr>\n<td align=\"center\">GL_CLAMP_TO_BORDER</td>\n<td align=\"center\">超出的坐标为用户指定的边缘颜色</td>\n</tr>\n</tbody></table>\n<p><img src=\"/article_img/2022-11-01-17-15-23.png\"></p>\n<p>用法：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);<br></code></pre></td></tr></table></figure>\n<p>可以单独对坐标轴设置纹理环绕方式。</p>\n<p>GL_CLAMP_TO_BORDER 方式由于是用户指定的边缘颜色，因此要再指定一个边缘的颜色，同时也不需要再指定坐标轴了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">float</span> borderColor[] = &#123;<span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>&#125;;<br><span class=\"hljs-built_in\">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"纹理过滤\"><a href=\"#纹理过滤\" class=\"headerlink\" title=\"纹理过滤\"></a>纹理过滤</h1><h2 id=\"纹理像素（Texture-Pixel）\"><a href=\"#纹理像素（Texture-Pixel）\" class=\"headerlink\" title=\"纹理像素（Texture Pixel）\"></a>纹理像素（Texture Pixel）</h2><p>Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素，其实就是<strong>纹理的分辨率</strong>。</p>\n<p>如果要将一个分辨率较低的纹理加在一个很大的物体上，看上去物体的分辨率就很低，为了减轻这种现象，需要纹理过滤。</p>\n<h2 id=\"纹理过滤-1\"><a href=\"#纹理过滤-1\" class=\"headerlink\" title=\"纹理过滤\"></a>纹理过滤</h2><p>这一部分在<a href=\"Games101-4-%E7%9D%80%E8%89%B2.md\">Games101-着色</a>中有过详细介绍</p>\n<ol>\n<li>邻近过滤（GL_NEAREST）<br><img src=\"/article_img/2022-11-01-17-16-23.png\"></li>\n<li>线性过滤（GL_LINEAR）<br><img src=\"/article_img/2022-11-01-17-16-55.png\"><br>使用的算法就是双线性插值，由周围几个像素的颜色算出最终应该采用的颜色。<br><img src=\"/article_img/2022-08-29-18-33-20.png\"></li>\n</ol>\n<p>下图是两种过滤方法的效果对比<br><img src=\"/article_img/2022-11-01-17-17-08.png\"></p>\n<p>用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER， GL_NEAREST);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER， GL_LINEAR);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"多级渐远纹理\"><a href=\"#多级渐远纹理\" class=\"headerlink\" title=\"多级渐远纹理\"></a>多级渐远纹理</h1><p>这一部分也在<a href=\"Games101-4-%E7%9D%80%E8%89%B2.md\">Games101-着色</a>中有过详细介绍</p>\n<p>当物体很小，而纹理分辨率很大的时候难以决定最终真正显示的像素的颜色，因为最终可见的像素很可能覆盖了纹理贴图上的很大一部分，同时还会产生很多浪费。</p>\n<p>OpenGL中使用Mipmap解决这个问题。</p>\n<p><img src=\"/article_img/2022-08-29-18-41-41.png\"></p>\n<p>可以使用glGenerateMipmaps函数来自动生成Mipmap</p>\n<p><img src=\"/article_img/2022-11-01-17-30-18.png\"></p>\n<p>在切换Mipmap时，在两个层之间会产生生硬的边界，因此在切换时也需要过滤。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">过滤方式</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">GL_NEAREST_MIPMAP_NEAREST</td>\n<td align=\"center\">使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>\n</tr>\n<tr>\n<td align=\"center\">GL_LINEAR_MIPMAP_NEAREST</td>\n<td align=\"center\">使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>\n</tr>\n<tr>\n<td align=\"center\">GL_NEAREST_MIPMAP_LINEAR</td>\n<td align=\"center\">在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>\n</tr>\n<tr>\n<td align=\"center\">GL_LINEAR_MIPMAP_LINEAR</td>\n<td align=\"center\">在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>\n</tr>\n</tbody></table>\n<p><img src=\"/article_img/2022-08-29-18-52-05.png\"></p>\n<p>这里看这个三线性插值（GL_LINEAR_MIPMAP_LINEAR）的原理图就很容易理解，GL_<strong>A</strong>_MIPMAP_<strong>B</strong> 中<strong>A</strong>是指不同层级之间的切换方式，<strong>B</strong>指每个层级内部的选择方式。</p>\n<p>使用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br></code></pre></td></tr></table></figure>\n\n<p>注意：<br>函数的第二个参数，是分别设置纹理缩小时过滤和纹理放大时过滤的参数。<strong>Mipmap只在纹理被缩小时有效。</strong></p>\n<h1 id=\"加载与创建纹理\"><a href=\"#加载与创建纹理\" class=\"headerlink\" title=\"加载与创建纹理\"></a>加载与创建纹理</h1><h2 id=\"stb-image-h\"><a href=\"#stb-image-h\" class=\"headerlink\" title=\"stb_image.h\"></a>stb_image.h</h2><p>加载纹理使用stb_image.h头文件，这个头文件中就包含了函数的实现，因此只需要将其添加到工程中，再创建一个C++文件输入：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> STB_IMAGE_IMPLEMENTATION</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stb_image.h&quot;</span></span><br></code></pre></td></tr></table></figure>\n<p>即可调用<strong>stbi_load</strong>函数进行图片的加载。</p>\n<h2 id=\"生成纹理\"><a href=\"#生成纹理\" class=\"headerlink\" title=\"生成纹理\"></a>生成纹理</h2><p>生成一个纹理的过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> texture;<br><span class=\"hljs-built_in\">glGenTextures</span>(<span class=\"hljs-number\">1</span>, &amp;texture);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture);<br><span class=\"hljs-comment\">// 为当前绑定的纹理对象设置环绕、过滤方式</span><br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   <br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><span class=\"hljs-comment\">// 加载并生成纹理</span><br><span class=\"hljs-type\">int</span> width, height, nrChannels;<br><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> *data = <span class=\"hljs-built_in\">stbi_load</span>(<span class=\"hljs-string\">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-keyword\">if</span> (data)<br>&#123;   <br>    <span class=\"hljs-comment\">// 生成纹理</span><br>    <span class=\"hljs-built_in\">glTexImage2D</span>(GL_TEXTURE_2D, <span class=\"hljs-number\">0</span>, GL_RGB, width, height, <span class=\"hljs-number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);<br>    <span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>&#125;<br><span class=\"hljs-keyword\">else</span><br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class=\"hljs-built_in\">stbi_image_free</span>(data);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"应用纹理\"><a href=\"#应用纹理\" class=\"headerlink\" title=\"应用纹理\"></a>应用纹理</h1><h2 id=\"基本应用\"><a href=\"#基本应用\" class=\"headerlink\" title=\"基本应用\"></a>基本应用</h2><p>纹理的应用需要相应的改变着色器代码，在顶点着色器中设定一个输出向量将纹理坐标传给片段着色器，在片段着色器中定义一个类型是sampler2D的uniform用来接收纹理图片，最后调用GLSL中的texture函数来采样纹理的颜色。</p>\n<p>sampler2D是一个GLSL的数据类型，叫做采样器，还有sampler1D, sampler3D, 用来把纹理对象传给片段着色器。</p>\n<p>顶点着色器：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec3 aColor;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">2</span>) in vec2 aTexCoord;<br><br>out vec3 ourColor;<br>out vec2 TexCoord;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos, <span class=\"hljs-number\">1.0</span>);<br>    ourColor = aColor;<br>    TexCoord = aTexCoord;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>片段着色器：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec3 ourColor;<br>in vec2 TexCoord;<br><br>uniform sampler2D ourTexture;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    FragColor = <span class=\"hljs-built_in\">texture</span>(ourTexture, TexCoord);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>渲染循环：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture);<br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO);<br><span class=\"hljs-built_in\">glDrawElements</span>(GL_TRIANGLES, <span class=\"hljs-number\">6</span>, GL_UNSIGNED_INT, <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"纹理单元\"><a href=\"#纹理单元\" class=\"headerlink\" title=\"纹理单元\"></a>纹理单元</h2><p><img src=\"/article_img/2022-11-02-15-10-07.png\"></p>\n<p>纹理单元的目的是为了让我们可以使用多个纹理，通过把纹理单元<strong>赋值</strong>给采样器，我们可以一次绑定多个纹理，只要我们首先<strong>激活</strong>对应的纹理单元；</p>\n<p>OpenGL保证有16个纹理单元供使用，且GL_TEXTRUE0默认被激活，所以只用一个纹理时可以不激活纹理单元0。</p>\n<p>使用方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><br><br><span class=\"hljs-comment\">// 激活纹理单元并将纹理绑定到相应的纹理单元</span><br><span class=\"hljs-built_in\">glActiveTexture</span>(GL_TEXTURE0);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture1);<br><span class=\"hljs-built_in\">glTexImage2D</span>(..., data1);<br><span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D);<br><span class=\"hljs-built_in\">glActiveTexture</span>(GL_TEXTURE1);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture2);<br><span class=\"hljs-built_in\">glTexImage2D</span>(..., data2);<br><span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D)<br><br><span class=\"hljs-comment\">// 设置uniform的值</span><br>ourShader.<span class=\"hljs-built_in\">setInt</span>(<span class=\"hljs-string\">&quot;texture1&quot;</span>, <span class=\"hljs-number\">0</span>);<br>ourShader.<span class=\"hljs-built_in\">setInt</span>(<span class=\"hljs-string\">&quot;texture2&quot;</span>, <span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><ol>\n<li><p>修改片段着色器，仅让笑脸图案朝另一个方向看</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">FragColor = <span class=\"hljs-built_in\">mix</span>(<span class=\"hljs-built_in\">texture</span>(texture1, TexCoord), <span class=\"hljs-built_in\">texture</span>(texture2, <span class=\"hljs-built_in\">vec2</span>(<span class=\"hljs-number\">1.0</span> - TexCoord.x, TexCoord.y)), <span class=\"hljs-number\">0.2</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p>尝试用不同的纹理环绕方式，设定一个从0.0f到2.0f范围内的（而不是原来的0.0f到1.0f）纹理坐标。试试看能不能在箱子的角落放置4个笑脸。记得一定要试试其它的环绕方式。</p>\n<p> 环绕方式和过滤方式需要对不同的纹理分别设置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> texture1, texture2;<br><span class=\"hljs-built_in\">glGenTextures</span>(<span class=\"hljs-number\">1</span>, &amp;texture1);<br><span class=\"hljs-built_in\">glActiveTexture</span>(GL_TEXTURE0);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture1);<br><span class=\"hljs-comment\">// 设置环绕，过滤方式</span><br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><br><span class=\"hljs-built_in\">glTexImage2D</span>(GL_TEXTURE_2D, <span class=\"hljs-number\">0</span>, GL_RGB, width, height, <span class=\"hljs-number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data1);<br><span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D);<br><span class=\"hljs-comment\">// 释放图像内存</span><br><span class=\"hljs-built_in\">stbi_image_free</span>(data1);<br><br><span class=\"hljs-built_in\">glGenTextures</span>(<span class=\"hljs-number\">1</span>, &amp;texture2);<br><span class=\"hljs-built_in\">glActiveTexture</span>(GL_TEXTURE2);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture2);<br><span class=\"hljs-comment\">// 设置环绕，过滤方式</span><br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><br><span class=\"hljs-built_in\">glTexImage2D</span>(GL_TEXTURE_2D, <span class=\"hljs-number\">0</span>, GL_RGBA, width, height, <span class=\"hljs-number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data2);<br><span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D);<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article_img/2022-11-01-19-04-15.png\"></p>\n</li>\n<li><p>尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">float</span> offset = <span class=\"hljs-number\">0.03</span>;<br><br><span class=\"hljs-type\">float</span> vertices[] = &#123;<br>    <span class=\"hljs-comment\">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span><br>     <span class=\"hljs-number\">0.5f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.5f</span> + offset, <span class=\"hljs-number\">0.5f</span> + offset,   <span class=\"hljs-comment\">// 右上</span><br>     <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.5f</span> + offset, <span class=\"hljs-number\">0.5f</span> - offset,   <span class=\"hljs-comment\">// 右下</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>,   <span class=\"hljs-number\">0.5f</span> - offset, <span class=\"hljs-number\">0.5f</span> - offset,   <span class=\"hljs-comment\">// 左下</span><br>    <span class=\"hljs-number\">-0.5f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.5f</span> - offset, <span class=\"hljs-number\">0.5f</span> + offset    <span class=\"hljs-comment\">// 左上</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>将纹理放大后的效果：<br><img src=\"/article_img/2022-11-01-19-10-25.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br></code></pre></td></tr></table></figure>\n<p>可以明显看出使用GL_LINEAR过滤方法锯齿感更弱<br><img src=\"/article_img/2022-11-01-19-12-45.png\"></p>\n</li>\n<li><p>使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度<br><img src=\"/article_img/2022-11-01-19-40-30.png\"><br><img src=\"/article_img/2022-11-01-19-40-57.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 输入函数，让所有输入代码保持整洁</span><br> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">processInput</span><span class=\"hljs-params\">(GLFWwindow* window, <span class=\"hljs-type\">float</span> &amp;mix_ratio)</span> </span>&#123;<br>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;<br>         std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ESCAPE PRESSED!&quot;</span> &lt;&lt; std::endl;<br>         <span class=\"hljs-built_in\">glfwSetWindowShouldClose</span>(window, <span class=\"hljs-literal\">true</span>);<br>     &#125;<br>         <br>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">glfwGetKey</span>(window, GLFW_KEY_UP) == GLFW_PRESS) &#123;<br>         mix_ratio += <span class=\"hljs-number\">0.1f</span>;<br>         <span class=\"hljs-keyword\">if</span> (mix_ratio &gt; <span class=\"hljs-number\">1.0f</span>)<br>             mix_ratio = <span class=\"hljs-number\">1.0f</span>;<br>         std::cout &lt;&lt; <span class=\"hljs-string\">&quot;UP PRESSED!&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">glfwGetKey</span>(window, GLFW_KEY_DOWN) == GLFW_PRESS) &#123;<br>         mix_ratio -= <span class=\"hljs-number\">0.1f</span>;<br>         <span class=\"hljs-keyword\">if</span> (mix_ratio &lt; <span class=\"hljs-number\">0.0f</span>)<br>             mix_ratio = <span class=\"hljs-number\">0.0f</span>;<br>         std::cout &lt;&lt; <span class=\"hljs-string\">&quot;DOWN PRESSED!&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class=\"hljs-comment\">// 渲染循环</span><br> ourShader.<span class=\"hljs-built_in\">setFloat</span>(<span class=\"hljs-string\">&quot;mix_ratio&quot;</span>, mix_ratio);<br><br></code></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":6661,"excerpt":"<p>learnopengl-3-纹理</p>","more":"<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/06%20Textures/\">纹理-LearnOpenGL CN</a></p>\n<p>纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。</p>\n<h1 id=\"纹理坐标\"><a href=\"#纹理坐标\" class=\"headerlink\" title=\"纹理坐标\"></a>纹理坐标</h1><p>用来标明该从纹理图像的哪个部分采样（译注：采集片段颜色）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。</p>\n<p><img src=\"/article_img/2022-11-01-16-58-12.png\"></p>\n<p>纹理坐标格式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">float</span> texCoords[] = &#123;<br>    <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-comment\">// 左下角</span><br>    <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-comment\">// 右下角</span><br>    <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">1.0f</span> <span class=\"hljs-comment\">// 上中</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"纹理环绕方式\"><a href=\"#纹理环绕方式\" class=\"headerlink\" title=\"纹理环绕方式\"></a>纹理环绕方式</h1><table>\n<thead>\n<tr>\n<th align=\"center\">环绕方式</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">GL_REPEAT</td>\n<td align=\"center\">对纹理的默认行为。重复纹理图像。</td>\n</tr>\n<tr>\n<td align=\"center\">GL_MIRRORED_REPEAT</td>\n<td align=\"center\">和GL_REPEAT一样，但每次重复图片是镜像放置的。</td>\n</tr>\n<tr>\n<td align=\"center\">GL_CLAMP_TO_EDGE</td>\n<td align=\"center\">纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td>\n</tr>\n<tr>\n<td align=\"center\">GL_CLAMP_TO_BORDER</td>\n<td align=\"center\">超出的坐标为用户指定的边缘颜色</td>\n</tr>\n</tbody></table>\n<p><img src=\"/article_img/2022-11-01-17-15-23.png\"></p>\n<p>用法：  </p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);<br></code></pre></td></tr></table></figure>\n<p>可以单独对坐标轴设置纹理环绕方式。</p>\n<p>GL_CLAMP_TO_BORDER 方式由于是用户指定的边缘颜色，因此要再指定一个边缘的颜色，同时也不需要再指定坐标轴了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">float</span> borderColor[] = &#123;<span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>&#125;;<br><span class=\"hljs-built_in\">glTexParameterfv</span>(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"纹理过滤\"><a href=\"#纹理过滤\" class=\"headerlink\" title=\"纹理过滤\"></a>纹理过滤</h1><h2 id=\"纹理像素（Texture-Pixel）\"><a href=\"#纹理像素（Texture-Pixel）\" class=\"headerlink\" title=\"纹理像素（Texture Pixel）\"></a>纹理像素（Texture Pixel）</h2><p>Texture Pixel也叫Texel，你可以想象你打开一张.jpg格式图片，不断放大你会发现它是由无数像素点组成的，这个点就是纹理像素，其实就是<strong>纹理的分辨率</strong>。</p>\n<p>如果要将一个分辨率较低的纹理加在一个很大的物体上，看上去物体的分辨率就很低，为了减轻这种现象，需要纹理过滤。</p>\n<h2 id=\"纹理过滤-1\"><a href=\"#纹理过滤-1\" class=\"headerlink\" title=\"纹理过滤\"></a>纹理过滤</h2><p>这一部分在<a href=\"Games101-4-%E7%9D%80%E8%89%B2.md\">Games101-着色</a>中有过详细介绍</p>\n<ol>\n<li>邻近过滤（GL_NEAREST）<br><img src=\"/article_img/2022-11-01-17-16-23.png\"></li>\n<li>线性过滤（GL_LINEAR）<br><img src=\"/article_img/2022-11-01-17-16-55.png\"><br>使用的算法就是双线性插值，由周围几个像素的颜色算出最终应该采用的颜色。<br><img src=\"/article_img/2022-08-29-18-33-20.png\"></li>\n</ol>\n<p>下图是两种过滤方法的效果对比<br><img src=\"/article_img/2022-11-01-17-17-08.png\"></p>\n<p>用法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER， GL_NEAREST);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER， GL_LINEAR);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"多级渐远纹理\"><a href=\"#多级渐远纹理\" class=\"headerlink\" title=\"多级渐远纹理\"></a>多级渐远纹理</h1><p>这一部分也在<a href=\"Games101-4-%E7%9D%80%E8%89%B2.md\">Games101-着色</a>中有过详细介绍</p>\n<p>当物体很小，而纹理分辨率很大的时候难以决定最终真正显示的像素的颜色，因为最终可见的像素很可能覆盖了纹理贴图上的很大一部分，同时还会产生很多浪费。</p>\n<p>OpenGL中使用Mipmap解决这个问题。</p>\n<p><img src=\"/article_img/2022-08-29-18-41-41.png\"></p>\n<p>可以使用glGenerateMipmaps函数来自动生成Mipmap</p>\n<p><img src=\"/article_img/2022-11-01-17-30-18.png\"></p>\n<p>在切换Mipmap时，在两个层之间会产生生硬的边界，因此在切换时也需要过滤。</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\">过滤方式</th>\n<th align=\"center\">描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">GL_NEAREST_MIPMAP_NEAREST</td>\n<td align=\"center\">使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>\n</tr>\n<tr>\n<td align=\"center\">GL_LINEAR_MIPMAP_NEAREST</td>\n<td align=\"center\">使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>\n</tr>\n<tr>\n<td align=\"center\">GL_NEAREST_MIPMAP_LINEAR</td>\n<td align=\"center\">在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>\n</tr>\n<tr>\n<td align=\"center\">GL_LINEAR_MIPMAP_LINEAR</td>\n<td align=\"center\">在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>\n</tr>\n</tbody></table>\n<p><img src=\"/article_img/2022-08-29-18-52-05.png\"></p>\n<p>这里看这个三线性插值（GL_LINEAR_MIPMAP_LINEAR）的原理图就很容易理解，GL_<strong>A</strong>_MIPMAP_<strong>B</strong> 中<strong>A</strong>是指不同层级之间的切换方式，<strong>B</strong>指每个层级内部的选择方式。</p>\n<p>使用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br></code></pre></td></tr></table></figure>\n\n<p>注意：<br>函数的第二个参数，是分别设置纹理缩小时过滤和纹理放大时过滤的参数。<strong>Mipmap只在纹理被缩小时有效。</strong></p>\n<h1 id=\"加载与创建纹理\"><a href=\"#加载与创建纹理\" class=\"headerlink\" title=\"加载与创建纹理\"></a>加载与创建纹理</h1><h2 id=\"stb-image-h\"><a href=\"#stb-image-h\" class=\"headerlink\" title=\"stb_image.h\"></a>stb_image.h</h2><p>加载纹理使用stb_image.h头文件，这个头文件中就包含了函数的实现，因此只需要将其添加到工程中，再创建一个C++文件输入：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> STB_IMAGE_IMPLEMENTATION</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stb_image.h&quot;</span></span><br></code></pre></td></tr></table></figure>\n<p>即可调用<strong>stbi_load</strong>函数进行图片的加载。</p>\n<h2 id=\"生成纹理\"><a href=\"#生成纹理\" class=\"headerlink\" title=\"生成纹理\"></a>生成纹理</h2><p>生成一个纹理的过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> texture;<br><span class=\"hljs-built_in\">glGenTextures</span>(<span class=\"hljs-number\">1</span>, &amp;texture);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture);<br><span class=\"hljs-comment\">// 为当前绑定的纹理对象设置环绕、过滤方式</span><br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   <br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><span class=\"hljs-comment\">// 加载并生成纹理</span><br><span class=\"hljs-type\">int</span> width, height, nrChannels;<br><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">char</span> *data = <span class=\"hljs-built_in\">stbi_load</span>(<span class=\"hljs-string\">&quot;container.jpg&quot;</span>, &amp;width, &amp;height, &amp;nrChannels, <span class=\"hljs-number\">0</span>);<br><span class=\"hljs-keyword\">if</span> (data)<br>&#123;   <br>    <span class=\"hljs-comment\">// 生成纹理</span><br>    <span class=\"hljs-built_in\">glTexImage2D</span>(GL_TEXTURE_2D, <span class=\"hljs-number\">0</span>, GL_RGB, width, height, <span class=\"hljs-number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);<br>    <span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D);<br>&#125;<br><span class=\"hljs-keyword\">else</span><br>&#123;<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Failed to load texture&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><span class=\"hljs-built_in\">stbi_image_free</span>(data);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"应用纹理\"><a href=\"#应用纹理\" class=\"headerlink\" title=\"应用纹理\"></a>应用纹理</h1><h2 id=\"基本应用\"><a href=\"#基本应用\" class=\"headerlink\" title=\"基本应用\"></a>基本应用</h2><p>纹理的应用需要相应的改变着色器代码，在顶点着色器中设定一个输出向量将纹理坐标传给片段着色器，在片段着色器中定义一个类型是sampler2D的uniform用来接收纹理图片，最后调用GLSL中的texture函数来采样纹理的颜色。</p>\n<p>sampler2D是一个GLSL的数据类型，叫做采样器，还有sampler1D, sampler3D, 用来把纹理对象传给片段着色器。</p>\n<p>顶点着色器：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">0</span>) in vec3 aPos;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">1</span>) in vec3 aColor;<br><span class=\"hljs-built_in\">layout</span> (location = <span class=\"hljs-number\">2</span>) in vec2 aTexCoord;<br><br>out vec3 ourColor;<br>out vec2 TexCoord;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    gl_Position = <span class=\"hljs-built_in\">vec4</span>(aPos, <span class=\"hljs-number\">1.0</span>);<br>    ourColor = aColor;<br>    TexCoord = aTexCoord;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>片段着色器：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-meta\">#version 330 core</span><br>out vec4 FragColor;<br><br>in vec3 ourColor;<br>in vec2 TexCoord;<br><br>uniform sampler2D ourTexture;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    FragColor = <span class=\"hljs-built_in\">texture</span>(ourTexture, TexCoord);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>渲染循环：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture);<br><span class=\"hljs-built_in\">glBindVertexArray</span>(VAO);<br><span class=\"hljs-built_in\">glDrawElements</span>(GL_TRIANGLES, <span class=\"hljs-number\">6</span>, GL_UNSIGNED_INT, <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"纹理单元\"><a href=\"#纹理单元\" class=\"headerlink\" title=\"纹理单元\"></a>纹理单元</h2><p><img src=\"/article_img/2022-11-02-15-10-07.png\"></p>\n<p>纹理单元的目的是为了让我们可以使用多个纹理，通过把纹理单元<strong>赋值</strong>给采样器，我们可以一次绑定多个纹理，只要我们首先<strong>激活</strong>对应的纹理单元；</p>\n<p>OpenGL保证有16个纹理单元供使用，且GL_TEXTRUE0默认被激活，所以只用一个纹理时可以不激活纹理单元0。</p>\n<p>使用方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><br><br><span class=\"hljs-comment\">// 激活纹理单元并将纹理绑定到相应的纹理单元</span><br><span class=\"hljs-built_in\">glActiveTexture</span>(GL_TEXTURE0);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture1);<br><span class=\"hljs-built_in\">glTexImage2D</span>(..., data1);<br><span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D);<br><span class=\"hljs-built_in\">glActiveTexture</span>(GL_TEXTURE1);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture2);<br><span class=\"hljs-built_in\">glTexImage2D</span>(..., data2);<br><span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D)<br><br><span class=\"hljs-comment\">// 设置uniform的值</span><br>ourShader.<span class=\"hljs-built_in\">setInt</span>(<span class=\"hljs-string\">&quot;texture1&quot;</span>, <span class=\"hljs-number\">0</span>);<br>ourShader.<span class=\"hljs-built_in\">setInt</span>(<span class=\"hljs-string\">&quot;texture2&quot;</span>, <span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><ol>\n<li><p>修改片段着色器，仅让笑脸图案朝另一个方向看</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">FragColor = <span class=\"hljs-built_in\">mix</span>(<span class=\"hljs-built_in\">texture</span>(texture1, TexCoord), <span class=\"hljs-built_in\">texture</span>(texture2, <span class=\"hljs-built_in\">vec2</span>(<span class=\"hljs-number\">1.0</span> - TexCoord.x, TexCoord.y)), <span class=\"hljs-number\">0.2</span>);<br></code></pre></td></tr></table></figure></li>\n<li><p>尝试用不同的纹理环绕方式，设定一个从0.0f到2.0f范围内的（而不是原来的0.0f到1.0f）纹理坐标。试试看能不能在箱子的角落放置4个笑脸。记得一定要试试其它的环绕方式。</p>\n<p> 环绕方式和过滤方式需要对不同的纹理分别设置</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> texture1, texture2;<br><span class=\"hljs-built_in\">glGenTextures</span>(<span class=\"hljs-number\">1</span>, &amp;texture1);<br><span class=\"hljs-built_in\">glActiveTexture</span>(GL_TEXTURE0);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture1);<br><span class=\"hljs-comment\">// 设置环绕，过滤方式</span><br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><br><span class=\"hljs-built_in\">glTexImage2D</span>(GL_TEXTURE_2D, <span class=\"hljs-number\">0</span>, GL_RGB, width, height, <span class=\"hljs-number\">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data1);<br><span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D);<br><span class=\"hljs-comment\">// 释放图像内存</span><br><span class=\"hljs-built_in\">stbi_image_free</span>(data1);<br><br><span class=\"hljs-built_in\">glGenTextures</span>(<span class=\"hljs-number\">1</span>, &amp;texture2);<br><span class=\"hljs-built_in\">glActiveTexture</span>(GL_TEXTURE2);<br><span class=\"hljs-built_in\">glBindTexture</span>(GL_TEXTURE_2D, texture2);<br><span class=\"hljs-comment\">// 设置环绕，过滤方式</span><br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);<br><br><span class=\"hljs-built_in\">glTexImage2D</span>(GL_TEXTURE_2D, <span class=\"hljs-number\">0</span>, GL_RGBA, width, height, <span class=\"hljs-number\">0</span>, GL_RGBA, GL_UNSIGNED_BYTE, data2);<br><span class=\"hljs-built_in\">glGenerateMipmap</span>(GL_TEXTURE_2D);<br></code></pre></td></tr></table></figure>\n<p><img src=\"/article_img/2022-11-01-19-04-15.png\"></p>\n</li>\n<li><p>尝试在矩形上只显示纹理图像的中间一部分，修改纹理坐标，达到能看见单个的像素的效果。尝试使用GL_NEAREST的纹理过滤方式让像素显示得更清晰</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">float</span> offset = <span class=\"hljs-number\">0.03</span>;<br><br><span class=\"hljs-type\">float</span> vertices[] = &#123;<br>    <span class=\"hljs-comment\">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -</span><br>     <span class=\"hljs-number\">0.5f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.5f</span> + offset, <span class=\"hljs-number\">0.5f</span> + offset,   <span class=\"hljs-comment\">// 右上</span><br>     <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.5f</span> + offset, <span class=\"hljs-number\">0.5f</span> - offset,   <span class=\"hljs-comment\">// 右下</span><br>    <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">-0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>,   <span class=\"hljs-number\">0.5f</span> - offset, <span class=\"hljs-number\">0.5f</span> - offset,   <span class=\"hljs-comment\">// 左下</span><br>    <span class=\"hljs-number\">-0.5f</span>,  <span class=\"hljs-number\">0.5f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>,   <span class=\"hljs-number\">0.5f</span> - offset, <span class=\"hljs-number\">0.5f</span> + offset    <span class=\"hljs-comment\">// 左上</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n<p>将纹理放大后的效果：<br><img src=\"/article_img/2022-11-01-19-10-25.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br><span class=\"hljs-built_in\">glTexParameteri</span>(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br></code></pre></td></tr></table></figure>\n<p>可以明显看出使用GL_LINEAR过滤方法锯齿感更弱<br><img src=\"/article_img/2022-11-01-19-12-45.png\"></p>\n</li>\n<li><p>使用一个uniform变量作为mix函数的第三个参数来改变两个纹理可见度，使用上和下键来改变箱子或笑脸的可见度<br><img src=\"/article_img/2022-11-01-19-40-30.png\"><br><img src=\"/article_img/2022-11-01-19-40-57.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-comment\">// 输入函数，让所有输入代码保持整洁</span><br> <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">processInput</span><span class=\"hljs-params\">(GLFWwindow* window, <span class=\"hljs-type\">float</span> &amp;mix_ratio)</span> </span>&#123;<br>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">glfwGetKey</span>(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) &#123;<br>         std::cout &lt;&lt; <span class=\"hljs-string\">&quot;ESCAPE PRESSED!&quot;</span> &lt;&lt; std::endl;<br>         <span class=\"hljs-built_in\">glfwSetWindowShouldClose</span>(window, <span class=\"hljs-literal\">true</span>);<br>     &#125;<br>         <br>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">glfwGetKey</span>(window, GLFW_KEY_UP) == GLFW_PRESS) &#123;<br>         mix_ratio += <span class=\"hljs-number\">0.1f</span>;<br>         <span class=\"hljs-keyword\">if</span> (mix_ratio &gt; <span class=\"hljs-number\">1.0f</span>)<br>             mix_ratio = <span class=\"hljs-number\">1.0f</span>;<br>         std::cout &lt;&lt; <span class=\"hljs-string\">&quot;UP PRESSED!&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">glfwGetKey</span>(window, GLFW_KEY_DOWN) == GLFW_PRESS) &#123;<br>         mix_ratio -= <span class=\"hljs-number\">0.1f</span>;<br>         <span class=\"hljs-keyword\">if</span> (mix_ratio &lt; <span class=\"hljs-number\">0.0f</span>)<br>             mix_ratio = <span class=\"hljs-number\">0.0f</span>;<br>         std::cout &lt;&lt; <span class=\"hljs-string\">&quot;DOWN PRESSED!&quot;</span> &lt;&lt; std::endl;<br>     &#125;<br> &#125;<br><br> <span class=\"hljs-comment\">// 渲染循环</span><br> ourShader.<span class=\"hljs-built_in\">setFloat</span>(<span class=\"hljs-string\">&quot;mix_ratio&quot;</span>, mix_ratio);<br><br></code></pre></td></tr></table></figure></li>\n</ol>"},{"title":"learnopengl-5-摄像机","date":"2022-11-11T16:00:00.000Z","index_img":"/img/bg/opengl.jpg","_content":"\nlearnopengl-5-摄像机\n<!-- more -->\n\n[摄像机-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/)\n\nOpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。所以其实是根据view矩阵移动场景中的顶点。\n\n# 摄像机/观察空间\n\n观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标，定义一个摄像机需要在世界空间中的位置，摄像机看向的方向，一个指向右侧的向量和一个指向上方的向量。\n\n![](/article_img/2022-11-12-14-23-16.png)\n\n## 摄像机位置\n\n摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。\n\n```C++\nglm::vec3 cameraPos = glm::vec3(0.0f,0.0f,3.0f);\n```\n\n## 摄像机方向\n\n相机位置减看向的点，得到摄像机看向方向的**反方向**，看上面的图，相机z轴的正方向与实际观察方向相反。\n```C++\nglm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);\nglm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);\n```\n\n## 右轴\n\n先定义一个向上向量，之后将这个向量与上一步的摄像机方向向量做叉乘，得到向右向量。\n```C++\nglm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); \nglm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));\n```\n\n## 上轴\n\n将向右向量与相机方向向量做叉乘得到向上方向。\n```C++\nglm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);\n```\n\n# Look At\n\n![](/article_img/2022-11-12-14-39-20.png)\n\n三个不线性相关的向量，可以构建一个向量空间，LookAt矩阵的含义就是先将场景中的点相对于相机位置移动（右侧矩阵），再将点从世界坐标转换到摄像机空间坐标（左侧矩阵）\n\n使用GLM的lookAt函数可以方便的定义lookAt矩阵：\n```C++\nglm::mat4 view;\nview = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), \n           glm::vec3(0.0f, 0.0f, 0.0f), \n           glm::vec3(0.0f, 1.0f, 0.0f));\n```\n\n# 自由移动\n\n之前GLFW的键盘输入已经定义过一个processInput函数了，添加对WASD的检测即可，之后当对应的按键按下时，向对应方向移动（让相机位置加上对应方向的向量）即可。\n\n为了在不同的设备上的相机移动速度相同，需要跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。\n\n# 视角移动\n\n## 欧拉角\n\n1. Pitch(俯仰角)\n2. Yaw(偏航角)\n3. Row(滚转角)\n\n![](/article_img/2022-11-12-14-57-30.png)\n\n在一般的摄像机系统中，不考虑Row的影响。\n\n视角移动就是通过pitch和yaw直接得出摄像机方向。\n\n![](/article_img/2022-11-12-15-18-18.png)\n\n```C++\ndirection.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw)); // 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的\ndirection.y = sin(glm::radians(pitch));\ndirection.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));\n```\n\n## 鼠标输入\n\n```C++\nvoid mouse_callback(GLFWwindow* window, double xpos, double ypos);\n\n// 在main函数中启用\nglfwSetCursorPosCallback(window, mouse_callback);\n```\nxpos和ypos记录了鼠标的位置，用GLFW注册了回调函数之后，鼠标一移动就会调用mouse_callback函数，并且得到鼠标位置。\n\n得到鼠标位置之后，需要和上一帧的鼠标位置对比，如果鼠标上下移动就是要调整pitch，左右移动就是调整yaw\n\n```C++\nfloat xoffset = xpos - lastX;\nfloat yoffset = lastY - ypos; // 注意这里是相反的，因为y坐标是从底部往顶部依次增大的\nlastX = xpos;\nlastY = ypos;\n\nfloat sensitivity = 0.05f;\nxoffset *= sensitivity;\nyoffset *= sensitivity;\n\nyaw   += xoffset;\npitch += yoffset;\n\n// 保证用户能看到的最大范围\nif(pitch > 89.0f)\n  pitch =  89.0f;\nif(pitch < -89.0f)\n  pitch = -89.0f;\n```\n这里需要给xoffset和yoffset乘一个灵敏度（应为0到1之间），否者相当于直接将偏移值当作了角度变化值，就会导致视角移动过大。\n\n# 缩放\n\n缩放依靠fov的变化即可，fov越小，看到的图像就越大，就产生了放大的感觉。\n\n```C++\nvoid scroll_callback(GLFWwindow* window, double xoffset, double yoffset)\n{\n  if(fov >= 1.0f && fov <= 45.0f)\n    fov -= yoffset;\n  if(fov <= 1.0f)\n    fov = 1.0f;\n  if(fov >= 45.0f)\n    fov = 45.0f;\n}\n\n// 注册回调函数\nglfwSetScrollCallback(window, scroll_callback);\n\n// 在main函数中将投影矩阵的fov也相应改变\nprojection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f);\n```\n# 练习\n\n1. 看看你是否能够修改摄像机类，使得其能够变成一个真正的FPS摄像机（也就是说不能够随意飞行）；你只能够呆在xz平面上：  \n   只需要设定相机只能朝前或后移动，不能朝相机看向方向移动。\n   ```C++\n   glm::vec3 WorldFront = glm::vec3(0.0f, 0.0f, -1.0f);\n   float velocity = MovementSpeed * deltaTime;\n   if (direction == FORWARD)\n      Position += WorldFront * velocity;\n   if (direction == BACKWARD)\n      Position -= WorldFront * velocity;\n   ```\n\n\n","source":"_posts/learnopengl-5-摄像机.md","raw":"---\ntitle: learnopengl-5-摄像机\ndate: 2022-11-12\nindex_img: \"/img/bg/opengl.jpg\"\ntags: [OpenGL]\ncategories: \n   -[OpenGL笔记]\n---\n\nlearnopengl-5-摄像机\n<!-- more -->\n\n[摄像机-LearnOpenGL CN](https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/)\n\nOpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。所以其实是根据view矩阵移动场景中的顶点。\n\n# 摄像机/观察空间\n\n观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标，定义一个摄像机需要在世界空间中的位置，摄像机看向的方向，一个指向右侧的向量和一个指向上方的向量。\n\n![](/article_img/2022-11-12-14-23-16.png)\n\n## 摄像机位置\n\n摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。\n\n```C++\nglm::vec3 cameraPos = glm::vec3(0.0f,0.0f,3.0f);\n```\n\n## 摄像机方向\n\n相机位置减看向的点，得到摄像机看向方向的**反方向**，看上面的图，相机z轴的正方向与实际观察方向相反。\n```C++\nglm::vec3 cameraTarget = glm::vec3(0.0f, 0.0f, 0.0f);\nglm::vec3 cameraDirection = glm::normalize(cameraPos - cameraTarget);\n```\n\n## 右轴\n\n先定义一个向上向量，之后将这个向量与上一步的摄像机方向向量做叉乘，得到向右向量。\n```C++\nglm::vec3 up = glm::vec3(0.0f, 1.0f, 0.0f); \nglm::vec3 cameraRight = glm::normalize(glm::cross(up, cameraDirection));\n```\n\n## 上轴\n\n将向右向量与相机方向向量做叉乘得到向上方向。\n```C++\nglm::vec3 cameraUp = glm::cross(cameraDirection, cameraRight);\n```\n\n# Look At\n\n![](/article_img/2022-11-12-14-39-20.png)\n\n三个不线性相关的向量，可以构建一个向量空间，LookAt矩阵的含义就是先将场景中的点相对于相机位置移动（右侧矩阵），再将点从世界坐标转换到摄像机空间坐标（左侧矩阵）\n\n使用GLM的lookAt函数可以方便的定义lookAt矩阵：\n```C++\nglm::mat4 view;\nview = glm::lookAt(glm::vec3(0.0f, 0.0f, 3.0f), \n           glm::vec3(0.0f, 0.0f, 0.0f), \n           glm::vec3(0.0f, 1.0f, 0.0f));\n```\n\n# 自由移动\n\n之前GLFW的键盘输入已经定义过一个processInput函数了，添加对WASD的检测即可，之后当对应的按键按下时，向对应方向移动（让相机位置加上对应方向的向量）即可。\n\n为了在不同的设备上的相机移动速度相同，需要跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。\n\n# 视角移动\n\n## 欧拉角\n\n1. Pitch(俯仰角)\n2. Yaw(偏航角)\n3. Row(滚转角)\n\n![](/article_img/2022-11-12-14-57-30.png)\n\n在一般的摄像机系统中，不考虑Row的影响。\n\n视角移动就是通过pitch和yaw直接得出摄像机方向。\n\n![](/article_img/2022-11-12-15-18-18.png)\n\n```C++\ndirection.x = cos(glm::radians(pitch)) * cos(glm::radians(yaw)); // 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的\ndirection.y = sin(glm::radians(pitch));\ndirection.z = cos(glm::radians(pitch)) * sin(glm::radians(yaw));\n```\n\n## 鼠标输入\n\n```C++\nvoid mouse_callback(GLFWwindow* window, double xpos, double ypos);\n\n// 在main函数中启用\nglfwSetCursorPosCallback(window, mouse_callback);\n```\nxpos和ypos记录了鼠标的位置，用GLFW注册了回调函数之后，鼠标一移动就会调用mouse_callback函数，并且得到鼠标位置。\n\n得到鼠标位置之后，需要和上一帧的鼠标位置对比，如果鼠标上下移动就是要调整pitch，左右移动就是调整yaw\n\n```C++\nfloat xoffset = xpos - lastX;\nfloat yoffset = lastY - ypos; // 注意这里是相反的，因为y坐标是从底部往顶部依次增大的\nlastX = xpos;\nlastY = ypos;\n\nfloat sensitivity = 0.05f;\nxoffset *= sensitivity;\nyoffset *= sensitivity;\n\nyaw   += xoffset;\npitch += yoffset;\n\n// 保证用户能看到的最大范围\nif(pitch > 89.0f)\n  pitch =  89.0f;\nif(pitch < -89.0f)\n  pitch = -89.0f;\n```\n这里需要给xoffset和yoffset乘一个灵敏度（应为0到1之间），否者相当于直接将偏移值当作了角度变化值，就会导致视角移动过大。\n\n# 缩放\n\n缩放依靠fov的变化即可，fov越小，看到的图像就越大，就产生了放大的感觉。\n\n```C++\nvoid scroll_callback(GLFWwindow* window, double xoffset, double yoffset)\n{\n  if(fov >= 1.0f && fov <= 45.0f)\n    fov -= yoffset;\n  if(fov <= 1.0f)\n    fov = 1.0f;\n  if(fov >= 45.0f)\n    fov = 45.0f;\n}\n\n// 注册回调函数\nglfwSetScrollCallback(window, scroll_callback);\n\n// 在main函数中将投影矩阵的fov也相应改变\nprojection = glm::perspective(glm::radians(fov), 800.0f / 600.0f, 0.1f, 100.0f);\n```\n# 练习\n\n1. 看看你是否能够修改摄像机类，使得其能够变成一个真正的FPS摄像机（也就是说不能够随意飞行）；你只能够呆在xz平面上：  \n   只需要设定相机只能朝前或后移动，不能朝相机看向方向移动。\n   ```C++\n   glm::vec3 WorldFront = glm::vec3(0.0f, 0.0f, -1.0f);\n   float velocity = MovementSpeed * deltaTime;\n   if (direction == FORWARD)\n      Position += WorldFront * velocity;\n   if (direction == BACKWARD)\n      Position -= WorldFront * velocity;\n   ```\n\n\n","slug":"learnopengl-5-摄像机","published":1,"updated":"2022-11-12T08:10:02.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigma0029w0jebuws5iol","content":"<p>learnopengl-5-摄像机</p>\n<span id=\"more\"></span>\n\n<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/\">摄像机-LearnOpenGL CN</a></p>\n<p>OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。所以其实是根据view矩阵移动场景中的顶点。</p>\n<h1 id=\"摄像机-x2F-观察空间\"><a href=\"#摄像机-x2F-观察空间\" class=\"headerlink\" title=\"摄像机&#x2F;观察空间\"></a>摄像机&#x2F;观察空间</h1><p>观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标，定义一个摄像机需要在世界空间中的位置，摄像机看向的方向，一个指向右侧的向量和一个指向上方的向量。</p>\n<p><img src=\"/article_img/2022-11-12-14-23-16.png\"></p>\n<h2 id=\"摄像机位置\"><a href=\"#摄像机位置\" class=\"headerlink\" title=\"摄像机位置\"></a>摄像机位置</h2><p>摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 cameraPos = glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>,<span class=\"hljs-number\">0.0f</span>,<span class=\"hljs-number\">3.0f</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"摄像机方向\"><a href=\"#摄像机方向\" class=\"headerlink\" title=\"摄像机方向\"></a>摄像机方向</h2><p>相机位置减看向的点，得到摄像机看向方向的<strong>反方向</strong>，看上面的图，相机z轴的正方向与实际观察方向相反。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 cameraTarget = glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>);<br>glm::vec3 cameraDirection = glm::<span class=\"hljs-built_in\">normalize</span>(cameraPos - cameraTarget);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"右轴\"><a href=\"#右轴\" class=\"headerlink\" title=\"右轴\"></a>右轴</h2><p>先定义一个向上向量，之后将这个向量与上一步的摄像机方向向量做叉乘，得到向右向量。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 up = glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>); <br>glm::vec3 cameraRight = glm::<span class=\"hljs-built_in\">normalize</span>(glm::<span class=\"hljs-built_in\">cross</span>(up, cameraDirection));<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"上轴\"><a href=\"#上轴\" class=\"headerlink\" title=\"上轴\"></a>上轴</h2><p>将向右向量与相机方向向量做叉乘得到向上方向。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 cameraUp = glm::<span class=\"hljs-built_in\">cross</span>(cameraDirection, cameraRight);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Look-At\"><a href=\"#Look-At\" class=\"headerlink\" title=\"Look At\"></a>Look At</h1><p><img src=\"/article_img/2022-11-12-14-39-20.png\"></p>\n<p>三个不线性相关的向量，可以构建一个向量空间，LookAt矩阵的含义就是先将场景中的点相对于相机位置移动（右侧矩阵），再将点从世界坐标转换到摄像机空间坐标（左侧矩阵）</p>\n<p>使用GLM的lookAt函数可以方便的定义lookAt矩阵：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::mat4 view;<br>view = glm::<span class=\"hljs-built_in\">lookAt</span>(glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">3.0f</span>), <br>           glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>), <br>           glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>));<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"自由移动\"><a href=\"#自由移动\" class=\"headerlink\" title=\"自由移动\"></a>自由移动</h1><p>之前GLFW的键盘输入已经定义过一个processInput函数了，添加对WASD的检测即可，之后当对应的按键按下时，向对应方向移动（让相机位置加上对应方向的向量）即可。</p>\n<p>为了在不同的设备上的相机移动速度相同，需要跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。</p>\n<h1 id=\"视角移动\"><a href=\"#视角移动\" class=\"headerlink\" title=\"视角移动\"></a>视角移动</h1><h2 id=\"欧拉角\"><a href=\"#欧拉角\" class=\"headerlink\" title=\"欧拉角\"></a>欧拉角</h2><ol>\n<li>Pitch(俯仰角)</li>\n<li>Yaw(偏航角)</li>\n<li>Row(滚转角)</li>\n</ol>\n<p><img src=\"/article_img/2022-11-12-14-57-30.png\"></p>\n<p>在一般的摄像机系统中，不考虑Row的影响。</p>\n<p>视角移动就是通过pitch和yaw直接得出摄像机方向。</p>\n<p><img src=\"/article_img/2022-11-12-15-18-18.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">direction.x = <span class=\"hljs-built_in\">cos</span>(glm::<span class=\"hljs-built_in\">radians</span>(pitch)) * <span class=\"hljs-built_in\">cos</span>(glm::<span class=\"hljs-built_in\">radians</span>(yaw)); <span class=\"hljs-comment\">// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span><br>direction.y = <span class=\"hljs-built_in\">sin</span>(glm::<span class=\"hljs-built_in\">radians</span>(pitch));<br>direction.z = <span class=\"hljs-built_in\">cos</span>(glm::<span class=\"hljs-built_in\">radians</span>(pitch)) * <span class=\"hljs-built_in\">sin</span>(glm::<span class=\"hljs-built_in\">radians</span>(yaw));<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"鼠标输入\"><a href=\"#鼠标输入\" class=\"headerlink\" title=\"鼠标输入\"></a>鼠标输入</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mouse_callback</span><span class=\"hljs-params\">(GLFWwindow* window, <span class=\"hljs-type\">double</span> xpos, <span class=\"hljs-type\">double</span> ypos)</span></span>;<br><br><span class=\"hljs-comment\">// 在main函数中启用</span><br><span class=\"hljs-built_in\">glfwSetCursorPosCallback</span>(window, mouse_callback);<br></code></pre></td></tr></table></figure>\n<p>xpos和ypos记录了鼠标的位置，用GLFW注册了回调函数之后，鼠标一移动就会调用mouse_callback函数，并且得到鼠标位置。</p>\n<p>得到鼠标位置之后，需要和上一帧的鼠标位置对比，如果鼠标上下移动就是要调整pitch，左右移动就是调整yaw</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">float</span> xoffset = xpos - lastX;<br><span class=\"hljs-type\">float</span> yoffset = lastY - ypos; <span class=\"hljs-comment\">// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的</span><br>lastX = xpos;<br>lastY = ypos;<br><br><span class=\"hljs-type\">float</span> sensitivity = <span class=\"hljs-number\">0.05f</span>;<br>xoffset *= sensitivity;<br>yoffset *= sensitivity;<br><br>yaw   += xoffset;<br>pitch += yoffset;<br><br><span class=\"hljs-comment\">// 保证用户能看到的最大范围</span><br><span class=\"hljs-keyword\">if</span>(pitch &gt; <span class=\"hljs-number\">89.0f</span>)<br>  pitch =  <span class=\"hljs-number\">89.0f</span>;<br><span class=\"hljs-keyword\">if</span>(pitch &lt; <span class=\"hljs-number\">-89.0f</span>)<br>  pitch = <span class=\"hljs-number\">-89.0f</span>;<br></code></pre></td></tr></table></figure>\n<p>这里需要给xoffset和yoffset乘一个灵敏度（应为0到1之间），否者相当于直接将偏移值当作了角度变化值，就会导致视角移动过大。</p>\n<h1 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h1><p>缩放依靠fov的变化即可，fov越小，看到的图像就越大，就产生了放大的感觉。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">scroll_callback</span><span class=\"hljs-params\">(GLFWwindow* window, <span class=\"hljs-type\">double</span> xoffset, <span class=\"hljs-type\">double</span> yoffset)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span>(fov &gt;= <span class=\"hljs-number\">1.0f</span> &amp;&amp; fov &lt;= <span class=\"hljs-number\">45.0f</span>)<br>    fov -= yoffset;<br>  <span class=\"hljs-keyword\">if</span>(fov &lt;= <span class=\"hljs-number\">1.0f</span>)<br>    fov = <span class=\"hljs-number\">1.0f</span>;<br>  <span class=\"hljs-keyword\">if</span>(fov &gt;= <span class=\"hljs-number\">45.0f</span>)<br>    fov = <span class=\"hljs-number\">45.0f</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 注册回调函数</span><br><span class=\"hljs-built_in\">glfwSetScrollCallback</span>(window, scroll_callback);<br><br><span class=\"hljs-comment\">// 在main函数中将投影矩阵的fov也相应改变</span><br>projection = glm::<span class=\"hljs-built_in\">perspective</span>(glm::<span class=\"hljs-built_in\">radians</span>(fov), <span class=\"hljs-number\">800.0f</span> / <span class=\"hljs-number\">600.0f</span>, <span class=\"hljs-number\">0.1f</span>, <span class=\"hljs-number\">100.0f</span>);<br></code></pre></td></tr></table></figure>\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><ol>\n<li>看看你是否能够修改摄像机类，使得其能够变成一个真正的FPS摄像机（也就是说不能够随意飞行）；你只能够呆在xz平面上：<br>只需要设定相机只能朝前或后移动，不能朝相机看向方向移动。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 WorldFront = glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">-1.0f</span>);<br><span class=\"hljs-type\">float</span> velocity = MovementSpeed * deltaTime;<br><span class=\"hljs-keyword\">if</span> (direction == FORWARD)<br>   Position += WorldFront * velocity;<br><span class=\"hljs-keyword\">if</span> (direction == BACKWARD)<br>   Position -= WorldFront * velocity;<br></code></pre></td></tr></table></figure></li>\n</ol>\n","site":{"data":{}},"wordcount":2735,"excerpt":"<p>learnopengl-5-摄像机</p>","more":"<p><a href=\"https://learnopengl-cn.github.io/01%20Getting%20started/09%20Camera/\">摄像机-LearnOpenGL CN</a></p>\n<p>OpenGL本身没有摄像机(Camera)的概念，但我们可以通过把场景中的所有物体往相反方向移动的方式来模拟出摄像机，产生一种我们在移动的感觉，而不是场景在移动。所以其实是根据view矩阵移动场景中的顶点。</p>\n<h1 id=\"摄像机-x2F-观察空间\"><a href=\"#摄像机-x2F-观察空间\" class=\"headerlink\" title=\"摄像机&#x2F;观察空间\"></a>摄像机&#x2F;观察空间</h1><p>观察矩阵把所有的世界坐标变换为相对于摄像机位置与方向的观察坐标，定义一个摄像机需要在世界空间中的位置，摄像机看向的方向，一个指向右侧的向量和一个指向上方的向量。</p>\n<p><img src=\"/article_img/2022-11-12-14-23-16.png\"></p>\n<h2 id=\"摄像机位置\"><a href=\"#摄像机位置\" class=\"headerlink\" title=\"摄像机位置\"></a>摄像机位置</h2><p>摄像机位置简单来说就是世界空间中一个指向摄像机位置的向量。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 cameraPos = glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>,<span class=\"hljs-number\">0.0f</span>,<span class=\"hljs-number\">3.0f</span>);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"摄像机方向\"><a href=\"#摄像机方向\" class=\"headerlink\" title=\"摄像机方向\"></a>摄像机方向</h2><p>相机位置减看向的点，得到摄像机看向方向的<strong>反方向</strong>，看上面的图，相机z轴的正方向与实际观察方向相反。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 cameraTarget = glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>);<br>glm::vec3 cameraDirection = glm::<span class=\"hljs-built_in\">normalize</span>(cameraPos - cameraTarget);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"右轴\"><a href=\"#右轴\" class=\"headerlink\" title=\"右轴\"></a>右轴</h2><p>先定义一个向上向量，之后将这个向量与上一步的摄像机方向向量做叉乘，得到向右向量。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 up = glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>); <br>glm::vec3 cameraRight = glm::<span class=\"hljs-built_in\">normalize</span>(glm::<span class=\"hljs-built_in\">cross</span>(up, cameraDirection));<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"上轴\"><a href=\"#上轴\" class=\"headerlink\" title=\"上轴\"></a>上轴</h2><p>将向右向量与相机方向向量做叉乘得到向上方向。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 cameraUp = glm::<span class=\"hljs-built_in\">cross</span>(cameraDirection, cameraRight);<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"Look-At\"><a href=\"#Look-At\" class=\"headerlink\" title=\"Look At\"></a>Look At</h1><p><img src=\"/article_img/2022-11-12-14-39-20.png\"></p>\n<p>三个不线性相关的向量，可以构建一个向量空间，LookAt矩阵的含义就是先将场景中的点相对于相机位置移动（右侧矩阵），再将点从世界坐标转换到摄像机空间坐标（左侧矩阵）</p>\n<p>使用GLM的lookAt函数可以方便的定义lookAt矩阵：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::mat4 view;<br>view = glm::<span class=\"hljs-built_in\">lookAt</span>(glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">3.0f</span>), <br>           glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>), <br>           glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">1.0f</span>, <span class=\"hljs-number\">0.0f</span>));<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"自由移动\"><a href=\"#自由移动\" class=\"headerlink\" title=\"自由移动\"></a>自由移动</h1><p>之前GLFW的键盘输入已经定义过一个processInput函数了，添加对WASD的检测即可，之后当对应的按键按下时，向对应方向移动（让相机位置加上对应方向的向量）即可。</p>\n<p>为了在不同的设备上的相机移动速度相同，需要跟踪一个时间差(Deltatime)变量，它储存了渲染上一帧所用的时间。如果我们的deltaTime很大，就意味着上一帧的渲染花费了更多时间，所以这一帧的速度需要变得更高来平衡渲染所花去的时间。</p>\n<h1 id=\"视角移动\"><a href=\"#视角移动\" class=\"headerlink\" title=\"视角移动\"></a>视角移动</h1><h2 id=\"欧拉角\"><a href=\"#欧拉角\" class=\"headerlink\" title=\"欧拉角\"></a>欧拉角</h2><ol>\n<li>Pitch(俯仰角)</li>\n<li>Yaw(偏航角)</li>\n<li>Row(滚转角)</li>\n</ol>\n<p><img src=\"/article_img/2022-11-12-14-57-30.png\"></p>\n<p>在一般的摄像机系统中，不考虑Row的影响。</p>\n<p>视角移动就是通过pitch和yaw直接得出摄像机方向。</p>\n<p><img src=\"/article_img/2022-11-12-15-18-18.png\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">direction.x = <span class=\"hljs-built_in\">cos</span>(glm::<span class=\"hljs-built_in\">radians</span>(pitch)) * <span class=\"hljs-built_in\">cos</span>(glm::<span class=\"hljs-built_in\">radians</span>(yaw)); <span class=\"hljs-comment\">// 译注：direction代表摄像机的前轴(Front)，这个前轴是和本文第一幅图片的第二个摄像机的方向向量是相反的</span><br>direction.y = <span class=\"hljs-built_in\">sin</span>(glm::<span class=\"hljs-built_in\">radians</span>(pitch));<br>direction.z = <span class=\"hljs-built_in\">cos</span>(glm::<span class=\"hljs-built_in\">radians</span>(pitch)) * <span class=\"hljs-built_in\">sin</span>(glm::<span class=\"hljs-built_in\">radians</span>(yaw));<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"鼠标输入\"><a href=\"#鼠标输入\" class=\"headerlink\" title=\"鼠标输入\"></a>鼠标输入</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">mouse_callback</span><span class=\"hljs-params\">(GLFWwindow* window, <span class=\"hljs-type\">double</span> xpos, <span class=\"hljs-type\">double</span> ypos)</span></span>;<br><br><span class=\"hljs-comment\">// 在main函数中启用</span><br><span class=\"hljs-built_in\">glfwSetCursorPosCallback</span>(window, mouse_callback);<br></code></pre></td></tr></table></figure>\n<p>xpos和ypos记录了鼠标的位置，用GLFW注册了回调函数之后，鼠标一移动就会调用mouse_callback函数，并且得到鼠标位置。</p>\n<p>得到鼠标位置之后，需要和上一帧的鼠标位置对比，如果鼠标上下移动就是要调整pitch，左右移动就是调整yaw</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-type\">float</span> xoffset = xpos - lastX;<br><span class=\"hljs-type\">float</span> yoffset = lastY - ypos; <span class=\"hljs-comment\">// 注意这里是相反的，因为y坐标是从底部往顶部依次增大的</span><br>lastX = xpos;<br>lastY = ypos;<br><br><span class=\"hljs-type\">float</span> sensitivity = <span class=\"hljs-number\">0.05f</span>;<br>xoffset *= sensitivity;<br>yoffset *= sensitivity;<br><br>yaw   += xoffset;<br>pitch += yoffset;<br><br><span class=\"hljs-comment\">// 保证用户能看到的最大范围</span><br><span class=\"hljs-keyword\">if</span>(pitch &gt; <span class=\"hljs-number\">89.0f</span>)<br>  pitch =  <span class=\"hljs-number\">89.0f</span>;<br><span class=\"hljs-keyword\">if</span>(pitch &lt; <span class=\"hljs-number\">-89.0f</span>)<br>  pitch = <span class=\"hljs-number\">-89.0f</span>;<br></code></pre></td></tr></table></figure>\n<p>这里需要给xoffset和yoffset乘一个灵敏度（应为0到1之间），否者相当于直接将偏移值当作了角度变化值，就会导致视角移动过大。</p>\n<h1 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h1><p>缩放依靠fov的变化即可，fov越小，看到的图像就越大，就产生了放大的感觉。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">scroll_callback</span><span class=\"hljs-params\">(GLFWwindow* window, <span class=\"hljs-type\">double</span> xoffset, <span class=\"hljs-type\">double</span> yoffset)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>  <span class=\"hljs-keyword\">if</span>(fov &gt;= <span class=\"hljs-number\">1.0f</span> &amp;&amp; fov &lt;= <span class=\"hljs-number\">45.0f</span>)<br>    fov -= yoffset;<br>  <span class=\"hljs-keyword\">if</span>(fov &lt;= <span class=\"hljs-number\">1.0f</span>)<br>    fov = <span class=\"hljs-number\">1.0f</span>;<br>  <span class=\"hljs-keyword\">if</span>(fov &gt;= <span class=\"hljs-number\">45.0f</span>)<br>    fov = <span class=\"hljs-number\">45.0f</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 注册回调函数</span><br><span class=\"hljs-built_in\">glfwSetScrollCallback</span>(window, scroll_callback);<br><br><span class=\"hljs-comment\">// 在main函数中将投影矩阵的fov也相应改变</span><br>projection = glm::<span class=\"hljs-built_in\">perspective</span>(glm::<span class=\"hljs-built_in\">radians</span>(fov), <span class=\"hljs-number\">800.0f</span> / <span class=\"hljs-number\">600.0f</span>, <span class=\"hljs-number\">0.1f</span>, <span class=\"hljs-number\">100.0f</span>);<br></code></pre></td></tr></table></figure>\n<h1 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h1><ol>\n<li>看看你是否能够修改摄像机类，使得其能够变成一个真正的FPS摄像机（也就是说不能够随意飞行）；你只能够呆在xz平面上：<br>只需要设定相机只能朝前或后移动，不能朝相机看向方向移动。<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C++\">glm::vec3 WorldFront = glm::<span class=\"hljs-built_in\">vec3</span>(<span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">0.0f</span>, <span class=\"hljs-number\">-1.0f</span>);<br><span class=\"hljs-type\">float</span> velocity = MovementSpeed * deltaTime;<br><span class=\"hljs-keyword\">if</span> (direction == FORWARD)<br>   Position += WorldFront * velocity;<br><span class=\"hljs-keyword\">if</span> (direction == BACKWARD)<br>   Position -= WorldFront * velocity;<br></code></pre></td></tr></table></figure></li>\n</ol>"},{"title":"万向节死锁问题（Gimbal Lock）","date":"2023-03-16T16:00:00.000Z","index_img":"/img/bg/EulerAngle.jpg","_content":"\n在Game104的动画章节中，讲解了欧拉角存在的问题，其中最难理解的就是欧拉角的万向节死锁问题，特此记录一下对这个问题的理解。\n<!-- more -->\n\n参考资料：\n[bilibili_无伤理解欧拉角中的“万向死锁”现象](https://www.bilibili.com/video/BV1Nr4y1j7kn/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n# 欧拉角（Euler Angle）\n\n![](/article_img/2023-03-17-15-28-09.png)\n\n![](/article_img/2023-03-17-15-21-58.png)\n\n欧拉证明了三维空间内的任意旋转，可以由围绕三个正交轴旋转组合而来。如上图所示，旋转用旋转矩阵表示，将围绕三个轴的旋转矩阵相乘即可得到实现任意旋转的旋转矩阵。\n\n# 万向节死锁（Gimbal Lock）\n\n<video src=\"https://vdn6.vzuu.com/SD/93f34370-233c-11eb-8317-9617913ca398.mp4?pkey=AAX8hkEUPQ0v-YFkBAF1YqR0DhFvQ4RZv2tP9NOoREIY9MrOTz-L4JiEa8sBT42C0WZkwIr2AIVvXb4jkhcrnJBp&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1679045329&v=ks6\"></video>\n\n一般用上图中的平衡环解释什么是万向节死锁。在平衡环案例中可以轻易看出万向节死锁发生的原理，两个环重叠在同一个平面，导致最外圈的大环旋转和最内圈的小环旋转的结果完全一样，都是绕竖直方向旋转。\n\n产生这个现象有一个前提条件，即外圈环的旋转会带动内圈环的旋转，而内圈环的旋转不能带动外圈环的旋转。用坐标系来理解：我们规定一个旋转变换的顺序，按照绕X轴Y轴Z轴的顺序将三个旋转矩阵相乘得到最终旋转矩阵，绕X轴的旋转会带动Y轴和Z轴的旋转，Y轴的旋转只能带动Z轴的旋转，这就导致如果我们绕Y轴旋转90°，Y轴会带动Z轴也旋转90°而不会带动X轴旋转，此时Z轴就会和X轴重合，导致绕X、Z轴旋转的结果完全一样。\n\n平衡环有这个前提条件是由于其机械结构，而我们在实现欧拉角变换的时候，为什么也要遵守这个规则呢？\n\n首先明确一点：\n\n![](/article_img/2023-03-17-15-39-57.png)\n\n这一点其实就是反直觉的，我们经常下意识地将欧拉角变换理解成，先绕X轴转动一定角度，再绕Y轴，Z轴旋转一定角度，物体的旋转会带动其局部坐标系一同旋转，绕Y轴旋转90°，Y轴会带动Z轴也旋转90°并且带动X轴旋转90°。而真实的欧拉角变换是，通过一个由矩阵相乘计算出的最终旋转矩阵直接对物体进行一个变换，也就是说**欧拉角旋转是一步完成的一个变换**。\n\n当我们一旦规定绕三个正交轴旋转的先后循序，我们就确定了构成最终旋转矩阵的矩阵相乘顺序，而在矩阵乘法中没有交换律。\n\n我们规定了三个矩阵的相乘顺序是XYZ，即为：**X(0°) * Y(90°) * Z(0°)**，由线性代数知识可知，**左侧矩阵的变换会被应用到其右侧的所有矩阵**，这也就是平衡环中大环会带动小环，而小环不能带动大环的数学解释，也是为什么众多解释万向死锁的文章都用平衡环演示的原因。\n\n![](/article_img/2023-03-17-16-13-42.png)\n\n因此这个数学解释也就十分合理了。\n\n# 万向死锁造成的问题\n\n其实万向死锁之后，并不是这个物体就再也不能随心所欲的旋转了，而是如果想要旋转，就需要同时对三个轴都旋转，这就会导致其旋转的移动轨迹不在正交平面上，就会导致我们不期望的转动轨迹。\n\n同过欧拉角实现的旋转动画，其每次只是应用一个变换，只是这个变换比上一帧应用的变换更近一步，产生了物体在转动的效果，也就是说，**欧拉角旋转每次都是被作用在物体的初始状态上**，这也可以进一步解释为什么上述案例中X轴会和Z轴重合，而不会随着物体转动而转动了，换个说法也就是在我们的直观理解中的**新的X轴**从来就不存在。\n\n# 实际应用\n\n由我们上述的分析可知万向节死锁不可避免，不论怎样安排绕三个正交轴的旋转顺序，其中间的轴一旦旋转90°或-90°，均会产生万向节死锁。\n\n在实际运用中，一般会根据旋转的具体场景，将最不可能旋转到90°的轴安排在中间，比如在unity中，物体在Scene视图中的移动就是欧拉角移动，unity将x轴安排在中间，因为绕X轴的旋转即Pitch一般不会到达90°。\n\n在Unity中使用[Transform.Rotate](https://docs.unity3d.com/ScriptReference/Transform.Rotate.html)实现欧拉的旋转。","source":"_posts/万向节死锁问题.md","raw":"---\ntitle: 万向节死锁问题（Gimbal Lock）\ndate: 2023-03-17\nindex_img: \"/img/bg/EulerAngle.jpg\"\ntags: [计算机角色动画]\ncategories: \n   -[笔记]\n---\n\n在Game104的动画章节中，讲解了欧拉角存在的问题，其中最难理解的就是欧拉角的万向节死锁问题，特此记录一下对这个问题的理解。\n<!-- more -->\n\n参考资料：\n[bilibili_无伤理解欧拉角中的“万向死锁”现象](https://www.bilibili.com/video/BV1Nr4y1j7kn/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n# 欧拉角（Euler Angle）\n\n![](/article_img/2023-03-17-15-28-09.png)\n\n![](/article_img/2023-03-17-15-21-58.png)\n\n欧拉证明了三维空间内的任意旋转，可以由围绕三个正交轴旋转组合而来。如上图所示，旋转用旋转矩阵表示，将围绕三个轴的旋转矩阵相乘即可得到实现任意旋转的旋转矩阵。\n\n# 万向节死锁（Gimbal Lock）\n\n<video src=\"https://vdn6.vzuu.com/SD/93f34370-233c-11eb-8317-9617913ca398.mp4?pkey=AAX8hkEUPQ0v-YFkBAF1YqR0DhFvQ4RZv2tP9NOoREIY9MrOTz-L4JiEa8sBT42C0WZkwIr2AIVvXb4jkhcrnJBp&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1679045329&v=ks6\"></video>\n\n一般用上图中的平衡环解释什么是万向节死锁。在平衡环案例中可以轻易看出万向节死锁发生的原理，两个环重叠在同一个平面，导致最外圈的大环旋转和最内圈的小环旋转的结果完全一样，都是绕竖直方向旋转。\n\n产生这个现象有一个前提条件，即外圈环的旋转会带动内圈环的旋转，而内圈环的旋转不能带动外圈环的旋转。用坐标系来理解：我们规定一个旋转变换的顺序，按照绕X轴Y轴Z轴的顺序将三个旋转矩阵相乘得到最终旋转矩阵，绕X轴的旋转会带动Y轴和Z轴的旋转，Y轴的旋转只能带动Z轴的旋转，这就导致如果我们绕Y轴旋转90°，Y轴会带动Z轴也旋转90°而不会带动X轴旋转，此时Z轴就会和X轴重合，导致绕X、Z轴旋转的结果完全一样。\n\n平衡环有这个前提条件是由于其机械结构，而我们在实现欧拉角变换的时候，为什么也要遵守这个规则呢？\n\n首先明确一点：\n\n![](/article_img/2023-03-17-15-39-57.png)\n\n这一点其实就是反直觉的，我们经常下意识地将欧拉角变换理解成，先绕X轴转动一定角度，再绕Y轴，Z轴旋转一定角度，物体的旋转会带动其局部坐标系一同旋转，绕Y轴旋转90°，Y轴会带动Z轴也旋转90°并且带动X轴旋转90°。而真实的欧拉角变换是，通过一个由矩阵相乘计算出的最终旋转矩阵直接对物体进行一个变换，也就是说**欧拉角旋转是一步完成的一个变换**。\n\n当我们一旦规定绕三个正交轴旋转的先后循序，我们就确定了构成最终旋转矩阵的矩阵相乘顺序，而在矩阵乘法中没有交换律。\n\n我们规定了三个矩阵的相乘顺序是XYZ，即为：**X(0°) * Y(90°) * Z(0°)**，由线性代数知识可知，**左侧矩阵的变换会被应用到其右侧的所有矩阵**，这也就是平衡环中大环会带动小环，而小环不能带动大环的数学解释，也是为什么众多解释万向死锁的文章都用平衡环演示的原因。\n\n![](/article_img/2023-03-17-16-13-42.png)\n\n因此这个数学解释也就十分合理了。\n\n# 万向死锁造成的问题\n\n其实万向死锁之后，并不是这个物体就再也不能随心所欲的旋转了，而是如果想要旋转，就需要同时对三个轴都旋转，这就会导致其旋转的移动轨迹不在正交平面上，就会导致我们不期望的转动轨迹。\n\n同过欧拉角实现的旋转动画，其每次只是应用一个变换，只是这个变换比上一帧应用的变换更近一步，产生了物体在转动的效果，也就是说，**欧拉角旋转每次都是被作用在物体的初始状态上**，这也可以进一步解释为什么上述案例中X轴会和Z轴重合，而不会随着物体转动而转动了，换个说法也就是在我们的直观理解中的**新的X轴**从来就不存在。\n\n# 实际应用\n\n由我们上述的分析可知万向节死锁不可避免，不论怎样安排绕三个正交轴的旋转顺序，其中间的轴一旦旋转90°或-90°，均会产生万向节死锁。\n\n在实际运用中，一般会根据旋转的具体场景，将最不可能旋转到90°的轴安排在中间，比如在unity中，物体在Scene视图中的移动就是欧拉角移动，unity将x轴安排在中间，因为绕X轴的旋转即Pitch一般不会到达90°。\n\n在Unity中使用[Transform.Rotate](https://docs.unity3d.com/ScriptReference/Transform.Rotate.html)实现欧拉的旋转。","slug":"万向节死锁问题","published":1,"updated":"2023-03-17T10:15:24.668Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigmb002bw0jee2rf9b6d","content":"<p>在Game104的动画章节中，讲解了欧拉角存在的问题，其中最难理解的就是欧拉角的万向节死锁问题，特此记录一下对这个问题的理解。</p>\n<span id=\"more\"></span>\n\n<p>参考资料：<br><a href=\"https://www.bilibili.com/video/BV1Nr4y1j7kn/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20\">bilibili_无伤理解欧拉角中的“万向死锁”现象</a></p>\n<h1 id=\"欧拉角（Euler-Angle）\"><a href=\"#欧拉角（Euler-Angle）\" class=\"headerlink\" title=\"欧拉角（Euler Angle）\"></a>欧拉角（Euler Angle）</h1><p><img src=\"/article_img/2023-03-17-15-28-09.png\"></p>\n<p><img src=\"/article_img/2023-03-17-15-21-58.png\"></p>\n<p>欧拉证明了三维空间内的任意旋转，可以由围绕三个正交轴旋转组合而来。如上图所示，旋转用旋转矩阵表示，将围绕三个轴的旋转矩阵相乘即可得到实现任意旋转的旋转矩阵。</p>\n<h1 id=\"万向节死锁（Gimbal-Lock）\"><a href=\"#万向节死锁（Gimbal-Lock）\" class=\"headerlink\" title=\"万向节死锁（Gimbal Lock）\"></a>万向节死锁（Gimbal Lock）</h1><p><video src=\"https://vdn6.vzuu.com/SD/93f34370-233c-11eb-8317-9617913ca398.mp4?pkey=AAX8hkEUPQ0v-YFkBAF1YqR0DhFvQ4RZv2tP9NOoREIY9MrOTz-L4JiEa8sBT42C0WZkwIr2AIVvXb4jkhcrnJBp&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1679045329&v=ks6\"></video></p>\n<p>一般用上图中的平衡环解释什么是万向节死锁。在平衡环案例中可以轻易看出万向节死锁发生的原理，两个环重叠在同一个平面，导致最外圈的大环旋转和最内圈的小环旋转的结果完全一样，都是绕竖直方向旋转。</p>\n<p>产生这个现象有一个前提条件，即外圈环的旋转会带动内圈环的旋转，而内圈环的旋转不能带动外圈环的旋转。用坐标系来理解：我们规定一个旋转变换的顺序，按照绕X轴Y轴Z轴的顺序将三个旋转矩阵相乘得到最终旋转矩阵，绕X轴的旋转会带动Y轴和Z轴的旋转，Y轴的旋转只能带动Z轴的旋转，这就导致如果我们绕Y轴旋转90°，Y轴会带动Z轴也旋转90°而不会带动X轴旋转，此时Z轴就会和X轴重合，导致绕X、Z轴旋转的结果完全一样。</p>\n<p>平衡环有这个前提条件是由于其机械结构，而我们在实现欧拉角变换的时候，为什么也要遵守这个规则呢？</p>\n<p>首先明确一点：</p>\n<p><img src=\"/article_img/2023-03-17-15-39-57.png\"></p>\n<p>这一点其实就是反直觉的，我们经常下意识地将欧拉角变换理解成，先绕X轴转动一定角度，再绕Y轴，Z轴旋转一定角度，物体的旋转会带动其局部坐标系一同旋转，绕Y轴旋转90°，Y轴会带动Z轴也旋转90°并且带动X轴旋转90°。而真实的欧拉角变换是，通过一个由矩阵相乘计算出的最终旋转矩阵直接对物体进行一个变换，也就是说<strong>欧拉角旋转是一步完成的一个变换</strong>。</p>\n<p>当我们一旦规定绕三个正交轴旋转的先后循序，我们就确定了构成最终旋转矩阵的矩阵相乘顺序，而在矩阵乘法中没有交换律。</p>\n<p>我们规定了三个矩阵的相乘顺序是XYZ，即为：<strong>X(0°) * Y(90°) * Z(0°)<strong>，由线性代数知识可知，</strong>左侧矩阵的变换会被应用到其右侧的所有矩阵</strong>，这也就是平衡环中大环会带动小环，而小环不能带动大环的数学解释，也是为什么众多解释万向死锁的文章都用平衡环演示的原因。</p>\n<p><img src=\"/article_img/2023-03-17-16-13-42.png\"></p>\n<p>因此这个数学解释也就十分合理了。</p>\n<h1 id=\"万向死锁造成的问题\"><a href=\"#万向死锁造成的问题\" class=\"headerlink\" title=\"万向死锁造成的问题\"></a>万向死锁造成的问题</h1><p>其实万向死锁之后，并不是这个物体就再也不能随心所欲的旋转了，而是如果想要旋转，就需要同时对三个轴都旋转，这就会导致其旋转的移动轨迹不在正交平面上，就会导致我们不期望的转动轨迹。</p>\n<p>同过欧拉角实现的旋转动画，其每次只是应用一个变换，只是这个变换比上一帧应用的变换更近一步，产生了物体在转动的效果，也就是说，<strong>欧拉角旋转每次都是被作用在物体的初始状态上</strong>，这也可以进一步解释为什么上述案例中X轴会和Z轴重合，而不会随着物体转动而转动了，换个说法也就是在我们的直观理解中的<strong>新的X轴</strong>从来就不存在。</p>\n<h1 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h1><p>由我们上述的分析可知万向节死锁不可避免，不论怎样安排绕三个正交轴的旋转顺序，其中间的轴一旦旋转90°或-90°，均会产生万向节死锁。</p>\n<p>在实际运用中，一般会根据旋转的具体场景，将最不可能旋转到90°的轴安排在中间，比如在unity中，物体在Scene视图中的移动就是欧拉角移动，unity将x轴安排在中间，因为绕X轴的旋转即Pitch一般不会到达90°。</p>\n<p>在Unity中使用<a href=\"https://docs.unity3d.com/ScriptReference/Transform.Rotate.html\">Transform.Rotate</a>实现欧拉的旋转。</p>\n","site":{"data":{}},"wordcount":1388,"excerpt":"<p>在Game104的动画章节中，讲解了欧拉角存在的问题，其中最难理解的就是欧拉角的万向节死锁问题，特此记录一下对这个问题的理解。</p>","more":"<p>参考资料：<br><a href=\"https://www.bilibili.com/video/BV1Nr4y1j7kn/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20\">bilibili_无伤理解欧拉角中的“万向死锁”现象</a></p>\n<h1 id=\"欧拉角（Euler-Angle）\"><a href=\"#欧拉角（Euler-Angle）\" class=\"headerlink\" title=\"欧拉角（Euler Angle）\"></a>欧拉角（Euler Angle）</h1><p><img src=\"/article_img/2023-03-17-15-28-09.png\"></p>\n<p><img src=\"/article_img/2023-03-17-15-21-58.png\"></p>\n<p>欧拉证明了三维空间内的任意旋转，可以由围绕三个正交轴旋转组合而来。如上图所示，旋转用旋转矩阵表示，将围绕三个轴的旋转矩阵相乘即可得到实现任意旋转的旋转矩阵。</p>\n<h1 id=\"万向节死锁（Gimbal-Lock）\"><a href=\"#万向节死锁（Gimbal-Lock）\" class=\"headerlink\" title=\"万向节死锁（Gimbal Lock）\"></a>万向节死锁（Gimbal Lock）</h1><p><video src=\"https://vdn6.vzuu.com/SD/93f34370-233c-11eb-8317-9617913ca398.mp4?pkey=AAX8hkEUPQ0v-YFkBAF1YqR0DhFvQ4RZv2tP9NOoREIY9MrOTz-L4JiEa8sBT42C0WZkwIr2AIVvXb4jkhcrnJBp&c=avc.0.0&f=mp4&pu=078babd7&bu=078babd7&expiration=1679045329&v=ks6\"></video></p>\n<p>一般用上图中的平衡环解释什么是万向节死锁。在平衡环案例中可以轻易看出万向节死锁发生的原理，两个环重叠在同一个平面，导致最外圈的大环旋转和最内圈的小环旋转的结果完全一样，都是绕竖直方向旋转。</p>\n<p>产生这个现象有一个前提条件，即外圈环的旋转会带动内圈环的旋转，而内圈环的旋转不能带动外圈环的旋转。用坐标系来理解：我们规定一个旋转变换的顺序，按照绕X轴Y轴Z轴的顺序将三个旋转矩阵相乘得到最终旋转矩阵，绕X轴的旋转会带动Y轴和Z轴的旋转，Y轴的旋转只能带动Z轴的旋转，这就导致如果我们绕Y轴旋转90°，Y轴会带动Z轴也旋转90°而不会带动X轴旋转，此时Z轴就会和X轴重合，导致绕X、Z轴旋转的结果完全一样。</p>\n<p>平衡环有这个前提条件是由于其机械结构，而我们在实现欧拉角变换的时候，为什么也要遵守这个规则呢？</p>\n<p>首先明确一点：</p>\n<p><img src=\"/article_img/2023-03-17-15-39-57.png\"></p>\n<p>这一点其实就是反直觉的，我们经常下意识地将欧拉角变换理解成，先绕X轴转动一定角度，再绕Y轴，Z轴旋转一定角度，物体的旋转会带动其局部坐标系一同旋转，绕Y轴旋转90°，Y轴会带动Z轴也旋转90°并且带动X轴旋转90°。而真实的欧拉角变换是，通过一个由矩阵相乘计算出的最终旋转矩阵直接对物体进行一个变换，也就是说<strong>欧拉角旋转是一步完成的一个变换</strong>。</p>\n<p>当我们一旦规定绕三个正交轴旋转的先后循序，我们就确定了构成最终旋转矩阵的矩阵相乘顺序，而在矩阵乘法中没有交换律。</p>\n<p>我们规定了三个矩阵的相乘顺序是XYZ，即为：<strong>X(0°) * Y(90°) * Z(0°)<strong>，由线性代数知识可知，</strong>左侧矩阵的变换会被应用到其右侧的所有矩阵</strong>，这也就是平衡环中大环会带动小环，而小环不能带动大环的数学解释，也是为什么众多解释万向死锁的文章都用平衡环演示的原因。</p>\n<p><img src=\"/article_img/2023-03-17-16-13-42.png\"></p>\n<p>因此这个数学解释也就十分合理了。</p>\n<h1 id=\"万向死锁造成的问题\"><a href=\"#万向死锁造成的问题\" class=\"headerlink\" title=\"万向死锁造成的问题\"></a>万向死锁造成的问题</h1><p>其实万向死锁之后，并不是这个物体就再也不能随心所欲的旋转了，而是如果想要旋转，就需要同时对三个轴都旋转，这就会导致其旋转的移动轨迹不在正交平面上，就会导致我们不期望的转动轨迹。</p>\n<p>同过欧拉角实现的旋转动画，其每次只是应用一个变换，只是这个变换比上一帧应用的变换更近一步，产生了物体在转动的效果，也就是说，<strong>欧拉角旋转每次都是被作用在物体的初始状态上</strong>，这也可以进一步解释为什么上述案例中X轴会和Z轴重合，而不会随着物体转动而转动了，换个说法也就是在我们的直观理解中的<strong>新的X轴</strong>从来就不存在。</p>\n<h1 id=\"实际应用\"><a href=\"#实际应用\" class=\"headerlink\" title=\"实际应用\"></a>实际应用</h1><p>由我们上述的分析可知万向节死锁不可避免，不论怎样安排绕三个正交轴的旋转顺序，其中间的轴一旦旋转90°或-90°，均会产生万向节死锁。</p>\n<p>在实际运用中，一般会根据旋转的具体场景，将最不可能旋转到90°的轴安排在中间，比如在unity中，物体在Scene视图中的移动就是欧拉角移动，unity将x轴安排在中间，因为绕X轴的旋转即Pitch一般不会到达90°。</p>\n<p>在Unity中使用<a href=\"https://docs.unity3d.com/ScriptReference/Transform.Rotate.html\">Transform.Rotate</a>实现欧拉的旋转。</p>"},{"title":"百人计划-动画TA-动作理论基础","date":"2023-03-28T16:00:00.000Z","index_img":"/img/bg/West2.jpg","_content":"\n[百人计划-动画TA-动作理论基础](https://www.bilibili.com/video/BV1Bh411t7AF?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20)\n<!-- more -->\n\n# 动画基础知识\n\n## 什么是运动\n\n运动（translation）包括平移（position），旋转（rotation）和缩放（scale）（缩放一般用于夸张的卡通动画效果）。计算机角色动画的基础是骨骼动画，骨骼动画就是用某种方式驱动顶点的移动。\n\n![](/article_img/2023-03-29-13-40-25.png)\n\n## 蒙皮（Skining）\n\n蒙皮字面意思理解就是给骨骼蒙上一层皮肤，蒙皮系统以某种方式驱动哪些顶点去到哪里。\n\n![](/article_img/2023-03-29-13-43-09.png)\n\n常见的蒙皮算法：\n1. **LBS(Linear Blending Skining)线性混合蒙皮**，大步幅蒙皮都是这种方式，但是会有挤压重叠（可以添加辅助骨骼保持关节形状）\n2. **DQS(Dual Quaternion Skining)双四元数蒙皮**，游戏引擎不支持，如DAZ的模型\n3. **JCM(Joint Controlled Morphs)骨骼驱动变形**，等于PSD（Pose space deformations），用骨骼驱动morphs变形，如Metahuman\n4. **RBF(Radial Basis Function)辅助骨骼驱动**，除了关节还可以做一些肌肉的驱动\n5. **RTSS(Real-time Skeletal Skining)基于优化旋转中心的实时骨骼蒙皮**，比较新的概念\n\n## 动画类型\n\n1. **逐帧动画**：sprite（精灵）动画\n2. **骨骼动画**：3D动画，spine动画（2D骨骼）\n3. **顶点动画**：物理模拟后的动画数据，用于不便于用骨骼驱动的布料，流体和破碎等等；\n   VAT(vertex animation texture)将每帧顶点数据记录到贴图上，贴图尺寸：帧数*顶点数\n   shader顶点动画，在vertex shader中控制顶点按照一定规律和公式做偏移动画，常用于草地摆动，海浪等\n   离线定点动画，离线渲染完成后导出abc文件到引擎\n\n## FK和IK\n\n正向运动学和反向运动学，在DCC中的绑定用到了IK，在引擎中可以实时计算IK实现脚部对地面倾斜度的适配，牵手适配不同身高\n\n# 动画质量和流畅度\n\n好的动画符合运动规律，运动轨迹是弧线\n\n## 如何营造打击感\n\n首先打击感是结合视觉、听觉、特效等方面的综合表现营造的\n\n1. **合理的打击反馈**，被大机房在受到攻击时一般会做出相应的受击反馈\n2. **打击抽帧和顿帧**\n   击打后停顿的是抽帧，击打后震动的是顿帧\n   攻击的前摇后摇\n3. **攻击节奏和按键反馈**\n4. **硬直和打断**\n\n## 夸张的魅力\n\n1. **挤压和拉伸**\n   挤压程度最大，表现出物体越Q弹；3D中起跳的先下蹲再伸展也是挤压和拉伸\n2. **拖尾和变形**\n   二次元中是视觉残留，3D中就是运动模糊\n3. **不正确的透视**\n4. **时间操控**\n\n# 动画表现提升点\n\n## 表情\n\n1. 写实：基本是动捕\n2. 美式卡通：挤压拉伸\n3. 日式卡通：保证五官形状\n\n## 交互体验\n\n## 动作状态融合\n\n[ALS](https://www.unrealengine.com/marketplace/zh-CN/product/advanced-locomotion-system-v1)\n\n![](/article_img/2023-03-29-14-23-17.png)\n\n# 参考资料（下饭）\n\n[动画十二法则](https://www.bilibili.com/video/BV1Qt411v7ih/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20)\n[动画师生存手册](https://www.bilibili.com/video/BV1Mt4y1X7oB/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20)","source":"_posts/百人计划-动画TA-动作理论基础.md","raw":"---\ntitle: 百人计划-动画TA-动作理论基础\ndate: 2023-03-29\nindex_img: \"/img/bg/West2.jpg\"\ntags: [百人计划]\ncategories: \n   -[动画TA]\n---\n\n[百人计划-动画TA-动作理论基础](https://www.bilibili.com/video/BV1Bh411t7AF?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20)\n<!-- more -->\n\n# 动画基础知识\n\n## 什么是运动\n\n运动（translation）包括平移（position），旋转（rotation）和缩放（scale）（缩放一般用于夸张的卡通动画效果）。计算机角色动画的基础是骨骼动画，骨骼动画就是用某种方式驱动顶点的移动。\n\n![](/article_img/2023-03-29-13-40-25.png)\n\n## 蒙皮（Skining）\n\n蒙皮字面意思理解就是给骨骼蒙上一层皮肤，蒙皮系统以某种方式驱动哪些顶点去到哪里。\n\n![](/article_img/2023-03-29-13-43-09.png)\n\n常见的蒙皮算法：\n1. **LBS(Linear Blending Skining)线性混合蒙皮**，大步幅蒙皮都是这种方式，但是会有挤压重叠（可以添加辅助骨骼保持关节形状）\n2. **DQS(Dual Quaternion Skining)双四元数蒙皮**，游戏引擎不支持，如DAZ的模型\n3. **JCM(Joint Controlled Morphs)骨骼驱动变形**，等于PSD（Pose space deformations），用骨骼驱动morphs变形，如Metahuman\n4. **RBF(Radial Basis Function)辅助骨骼驱动**，除了关节还可以做一些肌肉的驱动\n5. **RTSS(Real-time Skeletal Skining)基于优化旋转中心的实时骨骼蒙皮**，比较新的概念\n\n## 动画类型\n\n1. **逐帧动画**：sprite（精灵）动画\n2. **骨骼动画**：3D动画，spine动画（2D骨骼）\n3. **顶点动画**：物理模拟后的动画数据，用于不便于用骨骼驱动的布料，流体和破碎等等；\n   VAT(vertex animation texture)将每帧顶点数据记录到贴图上，贴图尺寸：帧数*顶点数\n   shader顶点动画，在vertex shader中控制顶点按照一定规律和公式做偏移动画，常用于草地摆动，海浪等\n   离线定点动画，离线渲染完成后导出abc文件到引擎\n\n## FK和IK\n\n正向运动学和反向运动学，在DCC中的绑定用到了IK，在引擎中可以实时计算IK实现脚部对地面倾斜度的适配，牵手适配不同身高\n\n# 动画质量和流畅度\n\n好的动画符合运动规律，运动轨迹是弧线\n\n## 如何营造打击感\n\n首先打击感是结合视觉、听觉、特效等方面的综合表现营造的\n\n1. **合理的打击反馈**，被大机房在受到攻击时一般会做出相应的受击反馈\n2. **打击抽帧和顿帧**\n   击打后停顿的是抽帧，击打后震动的是顿帧\n   攻击的前摇后摇\n3. **攻击节奏和按键反馈**\n4. **硬直和打断**\n\n## 夸张的魅力\n\n1. **挤压和拉伸**\n   挤压程度最大，表现出物体越Q弹；3D中起跳的先下蹲再伸展也是挤压和拉伸\n2. **拖尾和变形**\n   二次元中是视觉残留，3D中就是运动模糊\n3. **不正确的透视**\n4. **时间操控**\n\n# 动画表现提升点\n\n## 表情\n\n1. 写实：基本是动捕\n2. 美式卡通：挤压拉伸\n3. 日式卡通：保证五官形状\n\n## 交互体验\n\n## 动作状态融合\n\n[ALS](https://www.unrealengine.com/marketplace/zh-CN/product/advanced-locomotion-system-v1)\n\n![](/article_img/2023-03-29-14-23-17.png)\n\n# 参考资料（下饭）\n\n[动画十二法则](https://www.bilibili.com/video/BV1Qt411v7ih/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20)\n[动画师生存手册](https://www.bilibili.com/video/BV1Mt4y1X7oB/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20)","slug":"百人计划-动画TA-动作理论基础","published":1,"updated":"2023-04-17T09:45:32.578Z","_id":"clgkjigmh003lw0jegztp4lmx","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"https://www.bilibili.com/video/BV1Bh411t7AF?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20\">百人计划-动画TA-动作理论基础</a></p>\n<span id=\"more\"></span>\n\n<h1 id=\"动画基础知识\"><a href=\"#动画基础知识\" class=\"headerlink\" title=\"动画基础知识\"></a>动画基础知识</h1><h2 id=\"什么是运动\"><a href=\"#什么是运动\" class=\"headerlink\" title=\"什么是运动\"></a>什么是运动</h2><p>运动（translation）包括平移（position），旋转（rotation）和缩放（scale）（缩放一般用于夸张的卡通动画效果）。计算机角色动画的基础是骨骼动画，骨骼动画就是用某种方式驱动顶点的移动。</p>\n<p><img src=\"/article_img/2023-03-29-13-40-25.png\"></p>\n<h2 id=\"蒙皮（Skining）\"><a href=\"#蒙皮（Skining）\" class=\"headerlink\" title=\"蒙皮（Skining）\"></a>蒙皮（Skining）</h2><p>蒙皮字面意思理解就是给骨骼蒙上一层皮肤，蒙皮系统以某种方式驱动哪些顶点去到哪里。</p>\n<p><img src=\"/article_img/2023-03-29-13-43-09.png\"></p>\n<p>常见的蒙皮算法：</p>\n<ol>\n<li><strong>LBS(Linear Blending Skining)线性混合蒙皮</strong>，大步幅蒙皮都是这种方式，但是会有挤压重叠（可以添加辅助骨骼保持关节形状）</li>\n<li><strong>DQS(Dual Quaternion Skining)双四元数蒙皮</strong>，游戏引擎不支持，如DAZ的模型</li>\n<li><strong>JCM(Joint Controlled Morphs)骨骼驱动变形</strong>，等于PSD（Pose space deformations），用骨骼驱动morphs变形，如Metahuman</li>\n<li><strong>RBF(Radial Basis Function)辅助骨骼驱动</strong>，除了关节还可以做一些肌肉的驱动</li>\n<li><strong>RTSS(Real-time Skeletal Skining)基于优化旋转中心的实时骨骼蒙皮</strong>，比较新的概念</li>\n</ol>\n<h2 id=\"动画类型\"><a href=\"#动画类型\" class=\"headerlink\" title=\"动画类型\"></a>动画类型</h2><ol>\n<li><strong>逐帧动画</strong>：sprite（精灵）动画</li>\n<li><strong>骨骼动画</strong>：3D动画，spine动画（2D骨骼）</li>\n<li><strong>顶点动画</strong>：物理模拟后的动画数据，用于不便于用骨骼驱动的布料，流体和破碎等等；<br>VAT(vertex animation texture)将每帧顶点数据记录到贴图上，贴图尺寸：帧数*顶点数<br>shader顶点动画，在vertex shader中控制顶点按照一定规律和公式做偏移动画，常用于草地摆动，海浪等<br>离线定点动画，离线渲染完成后导出abc文件到引擎</li>\n</ol>\n<h2 id=\"FK和IK\"><a href=\"#FK和IK\" class=\"headerlink\" title=\"FK和IK\"></a>FK和IK</h2><p>正向运动学和反向运动学，在DCC中的绑定用到了IK，在引擎中可以实时计算IK实现脚部对地面倾斜度的适配，牵手适配不同身高</p>\n<h1 id=\"动画质量和流畅度\"><a href=\"#动画质量和流畅度\" class=\"headerlink\" title=\"动画质量和流畅度\"></a>动画质量和流畅度</h1><p>好的动画符合运动规律，运动轨迹是弧线</p>\n<h2 id=\"如何营造打击感\"><a href=\"#如何营造打击感\" class=\"headerlink\" title=\"如何营造打击感\"></a>如何营造打击感</h2><p>首先打击感是结合视觉、听觉、特效等方面的综合表现营造的</p>\n<ol>\n<li><strong>合理的打击反馈</strong>，被大机房在受到攻击时一般会做出相应的受击反馈</li>\n<li><strong>打击抽帧和顿帧</strong><br>击打后停顿的是抽帧，击打后震动的是顿帧<br>攻击的前摇后摇</li>\n<li><strong>攻击节奏和按键反馈</strong></li>\n<li><strong>硬直和打断</strong></li>\n</ol>\n<h2 id=\"夸张的魅力\"><a href=\"#夸张的魅力\" class=\"headerlink\" title=\"夸张的魅力\"></a>夸张的魅力</h2><ol>\n<li><strong>挤压和拉伸</strong><br>挤压程度最大，表现出物体越Q弹；3D中起跳的先下蹲再伸展也是挤压和拉伸</li>\n<li><strong>拖尾和变形</strong><br>二次元中是视觉残留，3D中就是运动模糊</li>\n<li><strong>不正确的透视</strong></li>\n<li><strong>时间操控</strong></li>\n</ol>\n<h1 id=\"动画表现提升点\"><a href=\"#动画表现提升点\" class=\"headerlink\" title=\"动画表现提升点\"></a>动画表现提升点</h1><h2 id=\"表情\"><a href=\"#表情\" class=\"headerlink\" title=\"表情\"></a>表情</h2><ol>\n<li>写实：基本是动捕</li>\n<li>美式卡通：挤压拉伸</li>\n<li>日式卡通：保证五官形状</li>\n</ol>\n<h2 id=\"交互体验\"><a href=\"#交互体验\" class=\"headerlink\" title=\"交互体验\"></a>交互体验</h2><h2 id=\"动作状态融合\"><a href=\"#动作状态融合\" class=\"headerlink\" title=\"动作状态融合\"></a>动作状态融合</h2><p><a href=\"https://www.unrealengine.com/marketplace/zh-CN/product/advanced-locomotion-system-v1\">ALS</a></p>\n<p><img src=\"/article_img/2023-03-29-14-23-17.png\"></p>\n<h1 id=\"参考资料（下饭）\"><a href=\"#参考资料（下饭）\" class=\"headerlink\" title=\"参考资料（下饭）\"></a>参考资料（下饭）</h1><p><a href=\"https://www.bilibili.com/video/BV1Qt411v7ih/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20\">动画十二法则</a><br><a href=\"https://www.bilibili.com/video/BV1Mt4y1X7oB/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20\">动画师生存手册</a></p>\n","site":{"data":{}},"wordcount":1057,"excerpt":"<p><a href=\"https://www.bilibili.com/video/BV1Bh411t7AF?p=2&vd_source=93b215eab72b2548f75d0772e28f8b20\">百人计划-动画TA-动作理论基础</a></p>","more":"<h1 id=\"动画基础知识\"><a href=\"#动画基础知识\" class=\"headerlink\" title=\"动画基础知识\"></a>动画基础知识</h1><h2 id=\"什么是运动\"><a href=\"#什么是运动\" class=\"headerlink\" title=\"什么是运动\"></a>什么是运动</h2><p>运动（translation）包括平移（position），旋转（rotation）和缩放（scale）（缩放一般用于夸张的卡通动画效果）。计算机角色动画的基础是骨骼动画，骨骼动画就是用某种方式驱动顶点的移动。</p>\n<p><img src=\"/article_img/2023-03-29-13-40-25.png\"></p>\n<h2 id=\"蒙皮（Skining）\"><a href=\"#蒙皮（Skining）\" class=\"headerlink\" title=\"蒙皮（Skining）\"></a>蒙皮（Skining）</h2><p>蒙皮字面意思理解就是给骨骼蒙上一层皮肤，蒙皮系统以某种方式驱动哪些顶点去到哪里。</p>\n<p><img src=\"/article_img/2023-03-29-13-43-09.png\"></p>\n<p>常见的蒙皮算法：</p>\n<ol>\n<li><strong>LBS(Linear Blending Skining)线性混合蒙皮</strong>，大步幅蒙皮都是这种方式，但是会有挤压重叠（可以添加辅助骨骼保持关节形状）</li>\n<li><strong>DQS(Dual Quaternion Skining)双四元数蒙皮</strong>，游戏引擎不支持，如DAZ的模型</li>\n<li><strong>JCM(Joint Controlled Morphs)骨骼驱动变形</strong>，等于PSD（Pose space deformations），用骨骼驱动morphs变形，如Metahuman</li>\n<li><strong>RBF(Radial Basis Function)辅助骨骼驱动</strong>，除了关节还可以做一些肌肉的驱动</li>\n<li><strong>RTSS(Real-time Skeletal Skining)基于优化旋转中心的实时骨骼蒙皮</strong>，比较新的概念</li>\n</ol>\n<h2 id=\"动画类型\"><a href=\"#动画类型\" class=\"headerlink\" title=\"动画类型\"></a>动画类型</h2><ol>\n<li><strong>逐帧动画</strong>：sprite（精灵）动画</li>\n<li><strong>骨骼动画</strong>：3D动画，spine动画（2D骨骼）</li>\n<li><strong>顶点动画</strong>：物理模拟后的动画数据，用于不便于用骨骼驱动的布料，流体和破碎等等；<br>VAT(vertex animation texture)将每帧顶点数据记录到贴图上，贴图尺寸：帧数*顶点数<br>shader顶点动画，在vertex shader中控制顶点按照一定规律和公式做偏移动画，常用于草地摆动，海浪等<br>离线定点动画，离线渲染完成后导出abc文件到引擎</li>\n</ol>\n<h2 id=\"FK和IK\"><a href=\"#FK和IK\" class=\"headerlink\" title=\"FK和IK\"></a>FK和IK</h2><p>正向运动学和反向运动学，在DCC中的绑定用到了IK，在引擎中可以实时计算IK实现脚部对地面倾斜度的适配，牵手适配不同身高</p>\n<h1 id=\"动画质量和流畅度\"><a href=\"#动画质量和流畅度\" class=\"headerlink\" title=\"动画质量和流畅度\"></a>动画质量和流畅度</h1><p>好的动画符合运动规律，运动轨迹是弧线</p>\n<h2 id=\"如何营造打击感\"><a href=\"#如何营造打击感\" class=\"headerlink\" title=\"如何营造打击感\"></a>如何营造打击感</h2><p>首先打击感是结合视觉、听觉、特效等方面的综合表现营造的</p>\n<ol>\n<li><strong>合理的打击反馈</strong>，被大机房在受到攻击时一般会做出相应的受击反馈</li>\n<li><strong>打击抽帧和顿帧</strong><br>击打后停顿的是抽帧，击打后震动的是顿帧<br>攻击的前摇后摇</li>\n<li><strong>攻击节奏和按键反馈</strong></li>\n<li><strong>硬直和打断</strong></li>\n</ol>\n<h2 id=\"夸张的魅力\"><a href=\"#夸张的魅力\" class=\"headerlink\" title=\"夸张的魅力\"></a>夸张的魅力</h2><ol>\n<li><strong>挤压和拉伸</strong><br>挤压程度最大，表现出物体越Q弹；3D中起跳的先下蹲再伸展也是挤压和拉伸</li>\n<li><strong>拖尾和变形</strong><br>二次元中是视觉残留，3D中就是运动模糊</li>\n<li><strong>不正确的透视</strong></li>\n<li><strong>时间操控</strong></li>\n</ol>\n<h1 id=\"动画表现提升点\"><a href=\"#动画表现提升点\" class=\"headerlink\" title=\"动画表现提升点\"></a>动画表现提升点</h1><h2 id=\"表情\"><a href=\"#表情\" class=\"headerlink\" title=\"表情\"></a>表情</h2><ol>\n<li>写实：基本是动捕</li>\n<li>美式卡通：挤压拉伸</li>\n<li>日式卡通：保证五官形状</li>\n</ol>\n<h2 id=\"交互体验\"><a href=\"#交互体验\" class=\"headerlink\" title=\"交互体验\"></a>交互体验</h2><h2 id=\"动作状态融合\"><a href=\"#动作状态融合\" class=\"headerlink\" title=\"动作状态融合\"></a>动作状态融合</h2><p><a href=\"https://www.unrealengine.com/marketplace/zh-CN/product/advanced-locomotion-system-v1\">ALS</a></p>\n<p><img src=\"/article_img/2023-03-29-14-23-17.png\"></p>\n<h1 id=\"参考资料（下饭）\"><a href=\"#参考资料（下饭）\" class=\"headerlink\" title=\"参考资料（下饭）\"></a>参考资料（下饭）</h1><p><a href=\"https://www.bilibili.com/video/BV1Qt411v7ih/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20\">动画十二法则</a><br><a href=\"https://www.bilibili.com/video/BV1Mt4y1X7oB/?spm_id_from=333.337.search-card.all.click&vd_source=93b215eab72b2548f75d0772e28f8b20\">动画师生存手册</a></p>"},{"title":"实习岗位","hide":true,"_content":"# funplus（TA/3D引擎渲染方向实习生）\n## 3D引擎渲染方向实习生（杭州）\n[3D引擎渲染方向](https://app.mokahr.com/campus_apply/funplus01/24530#/job/e1f1242a-3399-4dff-94c0-0506d4beb2a1)\n职位描述\n\n岗位职责:\n\n负责游戏图形渲染效果相关开发, 对特定高级渲染算法研究并落地实现\n\n\n我们希望您具备以下条件:\n\n- 计算机视觉或图形学等相关研究方向, 或者有良好的图形学和数学基础\n\n- 有一定的的C++或C#等主流语言基础\n\n- 至少了解DirectX、OpenGL、Metal或者Vulkan中的一种图形API，有一定的Shader编写能力\n\n- 熟悉游戏中常用的渲染技术\n\n## TA（杭州）\n[TA](https://app.mokahr.com/campus_apply/funplus01/24530#/job/36b8762f-e245-48c8-9bbe-3c598e855804)\n职位描述\n\n工作内容：\n\n1、充分了解美术各环节开发中的需求和问题，提供足够的技术支持和技术解决方案；\n\n2、协助编写shader，实现游戏材质 后处理等表现效果       \n\n3、开发各类美术制作和资源管理工具，优化工作流程\n\n\n职位要求： \n\n1、具备较好审美，具有良好团队协作精神、沟通能力；\n\n2、熟悉Unity渲染管线和SRP框架，熟悉SHADER编程\n\n3、良好的编程思想和逻辑思维能力，至少掌握一种编程语言，比如C#，Python；\n\n4、每周实习4天及以上，实习期3个月以上。\n\n如果你有以下经验将更加合适：\n\n1、熟悉3D美术内容制作工具（3D Max、Maya、C4D、Substance、Houdini、ZBrush等）；\n\n2、有图形学、渲染引擎方面的理论和实践经验。\n# 灵犀（上海）\n## 乘云计划——游戏开发实习生\n[乘云计划](https://talent.alibaba.com/campus/position-detail?lang=zh&positionId=2004303)\n职位描述\n1、你可以通过技术，为全球游戏玩家创造无与伦比的游戏体验；\n2、你可以成为极具创造力团队的一员，解决技术各种挑战性问题；\n3、你可以从客户端到服务端，从产品架构到引擎研发，跨越广阔的技术领域，参与行业前沿技术研发；\n4、你可以获得业界技术大牛亲自指导，快速成长为技术业务骨干、行业精英。\"\n职位要求\n1、计算机或相关专业，本科及以上学历，硕士优先；\n2、编程基本功扎实，掌握C/C++ 等开发语言，掌握lua或python优先；\n3、深入了解数据结构、算法、操作系统、网络等相关知识；\n4、若熟悉分布式系统设计或者计算机图形学更佳；\n5、总是有一颗躁动的心，对世间的事物都充满好奇心，自驱寻找答案，并有相应的自学能力；\n6、良好沟通和协调能力，不仅能清晰准确表达自己想法，还能驱动团队稳步前进。\n\n如有倾向的技术方向（如客户端或服务器或其他等），可在简历上备注\n\n热爱游戏，简历请附上游戏经历（包括但不限于游戏类型、游戏名称、游戏平台、游戏时长、游戏成就等）；有游戏相关作品/项目经历请附上。\"\n# 无端科技（杭州）\n## 引擎开发实习生\n[引擎开发](https://wooduan.zhiye.com/wdxzdetail?jobId=390532779&jc=1&c=&p=1^-1,3^-1&ky=)\n岗位职责\n帮助项目解决性能优化，图形效果，动画和物理模拟，美术资产管线，设备兼容性等相关问题；\n任职要求\n必须具备的：\n23届及以后毕业，计算机科学、计算机工程相关专业；\n扎实的算法、数据结构、操作系统等基础知识，优秀的工程能力；\n热爱编程，至少掌握一种游戏开发常用的编程语言，C++/C#开发和调试经验者优先；\n良好的数学基础和英文阅读功底；\n良好的沟通表达能力和团队合作意识；\n热爱游戏，对于创新和解决有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力；\n\n可以加分的：\n对图形、物理、动画、AI等某一领域比较熟悉；\n熟悉Unreal、Unity等商业引擎；\n参与过自研或开源游戏引擎开发，或有操作系统内核，数据库等系统级软件开发经验；\n\n## TA\n[TA](https://wooduan.zhiye.com/wdxzdetail?jobId=390532776&jc=1&c=&p=1^-1,3^-1&ky=)\n岗位职责\n负责渲染效果开发和提升，材质系统搭建，配合美术制作相关资产\n梳理美术开发流程，制定美术资源规范，开发相关美术Pipeline工具\n对渲染和美术资产进行性能优化\n开发引擎和DCC相关美术工具，提高美术生产效能\n配合引擎和图形团队协同开发\n任职要求\n23届及以后毕业\n熟悉Unity\\Unreal Engine引擎\n有一定数学基础，熟悉常用图形管线API和算法，具备一定美术审美\n熟悉常用材质编辑器和蓝图工具，熟练掌握HLSL\\GLSL\\CG开发语言至少一种\n熟练掌握常见材质类型和商业化开发\n熟练掌握Python\\C#\\Lua至少一种脚本语言\n熟悉常用的Profiling工具进行性能优化分析\n熟悉常用美术DCC工具，如Maya\\Max\\Houdini至少其中一种\n团队协作能力强，良好的沟通和自学能力\n# 莉莉丝（AI算法实习生）\n[算法实习生](https://lilithgames.jobs.feishu.cn/intern/position/7198079285013039397/detail)\n职位描述\n1. 在指导下，负责主流AIGC任务前沿算法的调研、复现以及在游戏生产场景中的可用性评估，包括但不限于2D绘画生成、文本生成、动画生成等内容形式。\n2. 协助从prompt优化、模型finetuning、性能加速等方向优化AIGC算法效果，完成产品化落地。\n3. 跟进技术落地与研究前沿，协助完善并更新领域技术地图，助力AIGC内容生态。\n职位要求\n1. 数学/人工智能/计算机/机器学习/娱乐技术/游戏设计等相关专业，全日制统招在读硕博（2025年及以后毕业）。\n2. 具有较强的编程能力，熟练使用Python，掌握常用数据结构算法，熟悉Linux开发环境。\n3. 熟练使用主流深度学习框架，如PyTorch、TensorFlow等。\n4. 实习6个月以上，能够保证每周至少到岗4天。\n5. 热爱游戏，对AIGC在游戏领域应用有浓厚兴趣。\n具备以下条件优先：\n1. 具有扎实的计算机视觉或机器学习算法基础，有相关方向顶会论文者优先。\n2. 熟悉常见Al生成模型框架及多模态模型，有stable diffusion, CLIP等实际应用经验者优先。","source":"_posts/实习岗位.md","raw":"---\ntitle: 实习岗位\nhide: true\n---\n# funplus（TA/3D引擎渲染方向实习生）\n## 3D引擎渲染方向实习生（杭州）\n[3D引擎渲染方向](https://app.mokahr.com/campus_apply/funplus01/24530#/job/e1f1242a-3399-4dff-94c0-0506d4beb2a1)\n职位描述\n\n岗位职责:\n\n负责游戏图形渲染效果相关开发, 对特定高级渲染算法研究并落地实现\n\n\n我们希望您具备以下条件:\n\n- 计算机视觉或图形学等相关研究方向, 或者有良好的图形学和数学基础\n\n- 有一定的的C++或C#等主流语言基础\n\n- 至少了解DirectX、OpenGL、Metal或者Vulkan中的一种图形API，有一定的Shader编写能力\n\n- 熟悉游戏中常用的渲染技术\n\n## TA（杭州）\n[TA](https://app.mokahr.com/campus_apply/funplus01/24530#/job/36b8762f-e245-48c8-9bbe-3c598e855804)\n职位描述\n\n工作内容：\n\n1、充分了解美术各环节开发中的需求和问题，提供足够的技术支持和技术解决方案；\n\n2、协助编写shader，实现游戏材质 后处理等表现效果       \n\n3、开发各类美术制作和资源管理工具，优化工作流程\n\n\n职位要求： \n\n1、具备较好审美，具有良好团队协作精神、沟通能力；\n\n2、熟悉Unity渲染管线和SRP框架，熟悉SHADER编程\n\n3、良好的编程思想和逻辑思维能力，至少掌握一种编程语言，比如C#，Python；\n\n4、每周实习4天及以上，实习期3个月以上。\n\n如果你有以下经验将更加合适：\n\n1、熟悉3D美术内容制作工具（3D Max、Maya、C4D、Substance、Houdini、ZBrush等）；\n\n2、有图形学、渲染引擎方面的理论和实践经验。\n# 灵犀（上海）\n## 乘云计划——游戏开发实习生\n[乘云计划](https://talent.alibaba.com/campus/position-detail?lang=zh&positionId=2004303)\n职位描述\n1、你可以通过技术，为全球游戏玩家创造无与伦比的游戏体验；\n2、你可以成为极具创造力团队的一员，解决技术各种挑战性问题；\n3、你可以从客户端到服务端，从产品架构到引擎研发，跨越广阔的技术领域，参与行业前沿技术研发；\n4、你可以获得业界技术大牛亲自指导，快速成长为技术业务骨干、行业精英。\"\n职位要求\n1、计算机或相关专业，本科及以上学历，硕士优先；\n2、编程基本功扎实，掌握C/C++ 等开发语言，掌握lua或python优先；\n3、深入了解数据结构、算法、操作系统、网络等相关知识；\n4、若熟悉分布式系统设计或者计算机图形学更佳；\n5、总是有一颗躁动的心，对世间的事物都充满好奇心，自驱寻找答案，并有相应的自学能力；\n6、良好沟通和协调能力，不仅能清晰准确表达自己想法，还能驱动团队稳步前进。\n\n如有倾向的技术方向（如客户端或服务器或其他等），可在简历上备注\n\n热爱游戏，简历请附上游戏经历（包括但不限于游戏类型、游戏名称、游戏平台、游戏时长、游戏成就等）；有游戏相关作品/项目经历请附上。\"\n# 无端科技（杭州）\n## 引擎开发实习生\n[引擎开发](https://wooduan.zhiye.com/wdxzdetail?jobId=390532779&jc=1&c=&p=1^-1,3^-1&ky=)\n岗位职责\n帮助项目解决性能优化，图形效果，动画和物理模拟，美术资产管线，设备兼容性等相关问题；\n任职要求\n必须具备的：\n23届及以后毕业，计算机科学、计算机工程相关专业；\n扎实的算法、数据结构、操作系统等基础知识，优秀的工程能力；\n热爱编程，至少掌握一种游戏开发常用的编程语言，C++/C#开发和调试经验者优先；\n良好的数学基础和英文阅读功底；\n良好的沟通表达能力和团队合作意识；\n热爱游戏，对于创新和解决有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力；\n\n可以加分的：\n对图形、物理、动画、AI等某一领域比较熟悉；\n熟悉Unreal、Unity等商业引擎；\n参与过自研或开源游戏引擎开发，或有操作系统内核，数据库等系统级软件开发经验；\n\n## TA\n[TA](https://wooduan.zhiye.com/wdxzdetail?jobId=390532776&jc=1&c=&p=1^-1,3^-1&ky=)\n岗位职责\n负责渲染效果开发和提升，材质系统搭建，配合美术制作相关资产\n梳理美术开发流程，制定美术资源规范，开发相关美术Pipeline工具\n对渲染和美术资产进行性能优化\n开发引擎和DCC相关美术工具，提高美术生产效能\n配合引擎和图形团队协同开发\n任职要求\n23届及以后毕业\n熟悉Unity\\Unreal Engine引擎\n有一定数学基础，熟悉常用图形管线API和算法，具备一定美术审美\n熟悉常用材质编辑器和蓝图工具，熟练掌握HLSL\\GLSL\\CG开发语言至少一种\n熟练掌握常见材质类型和商业化开发\n熟练掌握Python\\C#\\Lua至少一种脚本语言\n熟悉常用的Profiling工具进行性能优化分析\n熟悉常用美术DCC工具，如Maya\\Max\\Houdini至少其中一种\n团队协作能力强，良好的沟通和自学能力\n# 莉莉丝（AI算法实习生）\n[算法实习生](https://lilithgames.jobs.feishu.cn/intern/position/7198079285013039397/detail)\n职位描述\n1. 在指导下，负责主流AIGC任务前沿算法的调研、复现以及在游戏生产场景中的可用性评估，包括但不限于2D绘画生成、文本生成、动画生成等内容形式。\n2. 协助从prompt优化、模型finetuning、性能加速等方向优化AIGC算法效果，完成产品化落地。\n3. 跟进技术落地与研究前沿，协助完善并更新领域技术地图，助力AIGC内容生态。\n职位要求\n1. 数学/人工智能/计算机/机器学习/娱乐技术/游戏设计等相关专业，全日制统招在读硕博（2025年及以后毕业）。\n2. 具有较强的编程能力，熟练使用Python，掌握常用数据结构算法，熟悉Linux开发环境。\n3. 熟练使用主流深度学习框架，如PyTorch、TensorFlow等。\n4. 实习6个月以上，能够保证每周至少到岗4天。\n5. 热爱游戏，对AIGC在游戏领域应用有浓厚兴趣。\n具备以下条件优先：\n1. 具有扎实的计算机视觉或机器学习算法基础，有相关方向顶会论文者优先。\n2. 熟悉常见Al生成模型框架及多模态模型，有stable diffusion, CLIP等实际应用经验者优先。","slug":"实习岗位","published":1,"date":"2023-02-24T08:24:56.062Z","updated":"2023-03-17T10:12:54.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigmi003mw0jee4vsg2sm","content":"<h1 id=\"funplus（TA-x2F-3D引擎渲染方向实习生）\"><a href=\"#funplus（TA-x2F-3D引擎渲染方向实习生）\" class=\"headerlink\" title=\"funplus（TA&#x2F;3D引擎渲染方向实习生）\"></a>funplus（TA&#x2F;3D引擎渲染方向实习生）</h1><h2 id=\"3D引擎渲染方向实习生（杭州）\"><a href=\"#3D引擎渲染方向实习生（杭州）\" class=\"headerlink\" title=\"3D引擎渲染方向实习生（杭州）\"></a>3D引擎渲染方向实习生（杭州）</h2><p><a href=\"https://app.mokahr.com/campus_apply/funplus01/24530#/job/e1f1242a-3399-4dff-94c0-0506d4beb2a1\">3D引擎渲染方向</a><br>职位描述</p>\n<p>岗位职责:</p>\n<p>负责游戏图形渲染效果相关开发, 对特定高级渲染算法研究并落地实现</p>\n<p>我们希望您具备以下条件:</p>\n<ul>\n<li><p>计算机视觉或图形学等相关研究方向, 或者有良好的图形学和数学基础</p>\n</li>\n<li><p>有一定的的C++或C#等主流语言基础</p>\n</li>\n<li><p>至少了解DirectX、OpenGL、Metal或者Vulkan中的一种图形API，有一定的Shader编写能力</p>\n</li>\n<li><p>熟悉游戏中常用的渲染技术</p>\n</li>\n</ul>\n<h2 id=\"TA（杭州）\"><a href=\"#TA（杭州）\" class=\"headerlink\" title=\"TA（杭州）\"></a>TA（杭州）</h2><p><a href=\"https://app.mokahr.com/campus_apply/funplus01/24530#/job/36b8762f-e245-48c8-9bbe-3c598e855804\">TA</a><br>职位描述</p>\n<p>工作内容：</p>\n<p>1、充分了解美术各环节开发中的需求和问题，提供足够的技术支持和技术解决方案；</p>\n<p>2、协助编写shader，实现游戏材质 后处理等表现效果       </p>\n<p>3、开发各类美术制作和资源管理工具，优化工作流程</p>\n<p>职位要求： </p>\n<p>1、具备较好审美，具有良好团队协作精神、沟通能力；</p>\n<p>2、熟悉Unity渲染管线和SRP框架，熟悉SHADER编程</p>\n<p>3、良好的编程思想和逻辑思维能力，至少掌握一种编程语言，比如C#，Python；</p>\n<p>4、每周实习4天及以上，实习期3个月以上。</p>\n<p>如果你有以下经验将更加合适：</p>\n<p>1、熟悉3D美术内容制作工具（3D Max、Maya、C4D、Substance、Houdini、ZBrush等）；</p>\n<p>2、有图形学、渲染引擎方面的理论和实践经验。</p>\n<h1 id=\"灵犀（上海）\"><a href=\"#灵犀（上海）\" class=\"headerlink\" title=\"灵犀（上海）\"></a>灵犀（上海）</h1><h2 id=\"乘云计划——游戏开发实习生\"><a href=\"#乘云计划——游戏开发实习生\" class=\"headerlink\" title=\"乘云计划——游戏开发实习生\"></a>乘云计划——游戏开发实习生</h2><p><a href=\"https://talent.alibaba.com/campus/position-detail?lang=zh&positionId=2004303\">乘云计划</a><br>职位描述<br>1、你可以通过技术，为全球游戏玩家创造无与伦比的游戏体验；<br>2、你可以成为极具创造力团队的一员，解决技术各种挑战性问题；<br>3、你可以从客户端到服务端，从产品架构到引擎研发，跨越广阔的技术领域，参与行业前沿技术研发；<br>4、你可以获得业界技术大牛亲自指导，快速成长为技术业务骨干、行业精英。”<br>职位要求<br>1、计算机或相关专业，本科及以上学历，硕士优先；<br>2、编程基本功扎实，掌握C&#x2F;C++ 等开发语言，掌握lua或python优先；<br>3、深入了解数据结构、算法、操作系统、网络等相关知识；<br>4、若熟悉分布式系统设计或者计算机图形学更佳；<br>5、总是有一颗躁动的心，对世间的事物都充满好奇心，自驱寻找答案，并有相应的自学能力；<br>6、良好沟通和协调能力，不仅能清晰准确表达自己想法，还能驱动团队稳步前进。</p>\n<p>如有倾向的技术方向（如客户端或服务器或其他等），可在简历上备注</p>\n<p>热爱游戏，简历请附上游戏经历（包括但不限于游戏类型、游戏名称、游戏平台、游戏时长、游戏成就等）；有游戏相关作品&#x2F;项目经历请附上。”</p>\n<h1 id=\"无端科技（杭州）\"><a href=\"#无端科技（杭州）\" class=\"headerlink\" title=\"无端科技（杭州）\"></a>无端科技（杭州）</h1><h2 id=\"引擎开发实习生\"><a href=\"#引擎开发实习生\" class=\"headerlink\" title=\"引擎开发实习生\"></a>引擎开发实习生</h2><p><a href=\"https://wooduan.zhiye.com/wdxzdetail?jobId=390532779&jc=1&c=&p=1%5E-1,3%5E-1&ky=\">引擎开发</a><br>岗位职责<br>帮助项目解决性能优化，图形效果，动画和物理模拟，美术资产管线，设备兼容性等相关问题；<br>任职要求<br>必须具备的：<br>23届及以后毕业，计算机科学、计算机工程相关专业；<br>扎实的算法、数据结构、操作系统等基础知识，优秀的工程能力；<br>热爱编程，至少掌握一种游戏开发常用的编程语言，C++&#x2F;C#开发和调试经验者优先；<br>良好的数学基础和英文阅读功底；<br>良好的沟通表达能力和团队合作意识；<br>热爱游戏，对于创新和解决有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力；</p>\n<p>可以加分的：<br>对图形、物理、动画、AI等某一领域比较熟悉；<br>熟悉Unreal、Unity等商业引擎；<br>参与过自研或开源游戏引擎开发，或有操作系统内核，数据库等系统级软件开发经验；</p>\n<h2 id=\"TA\"><a href=\"#TA\" class=\"headerlink\" title=\"TA\"></a>TA</h2><p><a href=\"https://wooduan.zhiye.com/wdxzdetail?jobId=390532776&jc=1&c=&p=1%5E-1,3%5E-1&ky=\">TA</a><br>岗位职责<br>负责渲染效果开发和提升，材质系统搭建，配合美术制作相关资产<br>梳理美术开发流程，制定美术资源规范，开发相关美术Pipeline工具<br>对渲染和美术资产进行性能优化<br>开发引擎和DCC相关美术工具，提高美术生产效能<br>配合引擎和图形团队协同开发<br>任职要求<br>23届及以后毕业<br>熟悉Unity\\Unreal Engine引擎<br>有一定数学基础，熟悉常用图形管线API和算法，具备一定美术审美<br>熟悉常用材质编辑器和蓝图工具，熟练掌握HLSL\\GLSL\\CG开发语言至少一种<br>熟练掌握常见材质类型和商业化开发<br>熟练掌握Python\\C#\\Lua至少一种脚本语言<br>熟悉常用的Profiling工具进行性能优化分析<br>熟悉常用美术DCC工具，如Maya\\Max\\Houdini至少其中一种<br>团队协作能力强，良好的沟通和自学能力</p>\n<h1 id=\"莉莉丝（AI算法实习生）\"><a href=\"#莉莉丝（AI算法实习生）\" class=\"headerlink\" title=\"莉莉丝（AI算法实习生）\"></a>莉莉丝（AI算法实习生）</h1><p><a href=\"https://lilithgames.jobs.feishu.cn/intern/position/7198079285013039397/detail\">算法实习生</a><br>职位描述</p>\n<ol>\n<li>在指导下，负责主流AIGC任务前沿算法的调研、复现以及在游戏生产场景中的可用性评估，包括但不限于2D绘画生成、文本生成、动画生成等内容形式。</li>\n<li>协助从prompt优化、模型finetuning、性能加速等方向优化AIGC算法效果，完成产品化落地。</li>\n<li>跟进技术落地与研究前沿，协助完善并更新领域技术地图，助力AIGC内容生态。<br>职位要求</li>\n<li>数学&#x2F;人工智能&#x2F;计算机&#x2F;机器学习&#x2F;娱乐技术&#x2F;游戏设计等相关专业，全日制统招在读硕博（2025年及以后毕业）。</li>\n<li>具有较强的编程能力，熟练使用Python，掌握常用数据结构算法，熟悉Linux开发环境。</li>\n<li>熟练使用主流深度学习框架，如PyTorch、TensorFlow等。</li>\n<li>实习6个月以上，能够保证每周至少到岗4天。</li>\n<li>热爱游戏，对AIGC在游戏领域应用有浓厚兴趣。<br>具备以下条件优先：</li>\n<li>具有扎实的计算机视觉或机器学习算法基础，有相关方向顶会论文者优先。</li>\n<li>熟悉常见Al生成模型框架及多模态模型，有stable diffusion, CLIP等实际应用经验者优先。</li>\n</ol>\n","site":{"data":{}},"wordcount":2164,"excerpt":"","more":"<h1 id=\"funplus（TA-x2F-3D引擎渲染方向实习生）\"><a href=\"#funplus（TA-x2F-3D引擎渲染方向实习生）\" class=\"headerlink\" title=\"funplus（TA&#x2F;3D引擎渲染方向实习生）\"></a>funplus（TA&#x2F;3D引擎渲染方向实习生）</h1><h2 id=\"3D引擎渲染方向实习生（杭州）\"><a href=\"#3D引擎渲染方向实习生（杭州）\" class=\"headerlink\" title=\"3D引擎渲染方向实习生（杭州）\"></a>3D引擎渲染方向实习生（杭州）</h2><p><a href=\"https://app.mokahr.com/campus_apply/funplus01/24530#/job/e1f1242a-3399-4dff-94c0-0506d4beb2a1\">3D引擎渲染方向</a><br>职位描述</p>\n<p>岗位职责:</p>\n<p>负责游戏图形渲染效果相关开发, 对特定高级渲染算法研究并落地实现</p>\n<p>我们希望您具备以下条件:</p>\n<ul>\n<li><p>计算机视觉或图形学等相关研究方向, 或者有良好的图形学和数学基础</p>\n</li>\n<li><p>有一定的的C++或C#等主流语言基础</p>\n</li>\n<li><p>至少了解DirectX、OpenGL、Metal或者Vulkan中的一种图形API，有一定的Shader编写能力</p>\n</li>\n<li><p>熟悉游戏中常用的渲染技术</p>\n</li>\n</ul>\n<h2 id=\"TA（杭州）\"><a href=\"#TA（杭州）\" class=\"headerlink\" title=\"TA（杭州）\"></a>TA（杭州）</h2><p><a href=\"https://app.mokahr.com/campus_apply/funplus01/24530#/job/36b8762f-e245-48c8-9bbe-3c598e855804\">TA</a><br>职位描述</p>\n<p>工作内容：</p>\n<p>1、充分了解美术各环节开发中的需求和问题，提供足够的技术支持和技术解决方案；</p>\n<p>2、协助编写shader，实现游戏材质 后处理等表现效果       </p>\n<p>3、开发各类美术制作和资源管理工具，优化工作流程</p>\n<p>职位要求： </p>\n<p>1、具备较好审美，具有良好团队协作精神、沟通能力；</p>\n<p>2、熟悉Unity渲染管线和SRP框架，熟悉SHADER编程</p>\n<p>3、良好的编程思想和逻辑思维能力，至少掌握一种编程语言，比如C#，Python；</p>\n<p>4、每周实习4天及以上，实习期3个月以上。</p>\n<p>如果你有以下经验将更加合适：</p>\n<p>1、熟悉3D美术内容制作工具（3D Max、Maya、C4D、Substance、Houdini、ZBrush等）；</p>\n<p>2、有图形学、渲染引擎方面的理论和实践经验。</p>\n<h1 id=\"灵犀（上海）\"><a href=\"#灵犀（上海）\" class=\"headerlink\" title=\"灵犀（上海）\"></a>灵犀（上海）</h1><h2 id=\"乘云计划——游戏开发实习生\"><a href=\"#乘云计划——游戏开发实习生\" class=\"headerlink\" title=\"乘云计划——游戏开发实习生\"></a>乘云计划——游戏开发实习生</h2><p><a href=\"https://talent.alibaba.com/campus/position-detail?lang=zh&positionId=2004303\">乘云计划</a><br>职位描述<br>1、你可以通过技术，为全球游戏玩家创造无与伦比的游戏体验；<br>2、你可以成为极具创造力团队的一员，解决技术各种挑战性问题；<br>3、你可以从客户端到服务端，从产品架构到引擎研发，跨越广阔的技术领域，参与行业前沿技术研发；<br>4、你可以获得业界技术大牛亲自指导，快速成长为技术业务骨干、行业精英。”<br>职位要求<br>1、计算机或相关专业，本科及以上学历，硕士优先；<br>2、编程基本功扎实，掌握C&#x2F;C++ 等开发语言，掌握lua或python优先；<br>3、深入了解数据结构、算法、操作系统、网络等相关知识；<br>4、若熟悉分布式系统设计或者计算机图形学更佳；<br>5、总是有一颗躁动的心，对世间的事物都充满好奇心，自驱寻找答案，并有相应的自学能力；<br>6、良好沟通和协调能力，不仅能清晰准确表达自己想法，还能驱动团队稳步前进。</p>\n<p>如有倾向的技术方向（如客户端或服务器或其他等），可在简历上备注</p>\n<p>热爱游戏，简历请附上游戏经历（包括但不限于游戏类型、游戏名称、游戏平台、游戏时长、游戏成就等）；有游戏相关作品&#x2F;项目经历请附上。”</p>\n<h1 id=\"无端科技（杭州）\"><a href=\"#无端科技（杭州）\" class=\"headerlink\" title=\"无端科技（杭州）\"></a>无端科技（杭州）</h1><h2 id=\"引擎开发实习生\"><a href=\"#引擎开发实习生\" class=\"headerlink\" title=\"引擎开发实习生\"></a>引擎开发实习生</h2><p><a href=\"https://wooduan.zhiye.com/wdxzdetail?jobId=390532779&jc=1&c=&p=1%5E-1,3%5E-1&ky=\">引擎开发</a><br>岗位职责<br>帮助项目解决性能优化，图形效果，动画和物理模拟，美术资产管线，设备兼容性等相关问题；<br>任职要求<br>必须具备的：<br>23届及以后毕业，计算机科学、计算机工程相关专业；<br>扎实的算法、数据结构、操作系统等基础知识，优秀的工程能力；<br>热爱编程，至少掌握一种游戏开发常用的编程语言，C++&#x2F;C#开发和调试经验者优先；<br>良好的数学基础和英文阅读功底；<br>良好的沟通表达能力和团队合作意识；<br>热爱游戏，对于创新和解决有挑战性的问题充满激情，有较强的学习能力、分析及解决问题能力；</p>\n<p>可以加分的：<br>对图形、物理、动画、AI等某一领域比较熟悉；<br>熟悉Unreal、Unity等商业引擎；<br>参与过自研或开源游戏引擎开发，或有操作系统内核，数据库等系统级软件开发经验；</p>\n<h2 id=\"TA\"><a href=\"#TA\" class=\"headerlink\" title=\"TA\"></a>TA</h2><p><a href=\"https://wooduan.zhiye.com/wdxzdetail?jobId=390532776&jc=1&c=&p=1%5E-1,3%5E-1&ky=\">TA</a><br>岗位职责<br>负责渲染效果开发和提升，材质系统搭建，配合美术制作相关资产<br>梳理美术开发流程，制定美术资源规范，开发相关美术Pipeline工具<br>对渲染和美术资产进行性能优化<br>开发引擎和DCC相关美术工具，提高美术生产效能<br>配合引擎和图形团队协同开发<br>任职要求<br>23届及以后毕业<br>熟悉Unity\\Unreal Engine引擎<br>有一定数学基础，熟悉常用图形管线API和算法，具备一定美术审美<br>熟悉常用材质编辑器和蓝图工具，熟练掌握HLSL\\GLSL\\CG开发语言至少一种<br>熟练掌握常见材质类型和商业化开发<br>熟练掌握Python\\C#\\Lua至少一种脚本语言<br>熟悉常用的Profiling工具进行性能优化分析<br>熟悉常用美术DCC工具，如Maya\\Max\\Houdini至少其中一种<br>团队协作能力强，良好的沟通和自学能力</p>\n<h1 id=\"莉莉丝（AI算法实习生）\"><a href=\"#莉莉丝（AI算法实习生）\" class=\"headerlink\" title=\"莉莉丝（AI算法实习生）\"></a>莉莉丝（AI算法实习生）</h1><p><a href=\"https://lilithgames.jobs.feishu.cn/intern/position/7198079285013039397/detail\">算法实习生</a><br>职位描述</p>\n<ol>\n<li>在指导下，负责主流AIGC任务前沿算法的调研、复现以及在游戏生产场景中的可用性评估，包括但不限于2D绘画生成、文本生成、动画生成等内容形式。</li>\n<li>协助从prompt优化、模型finetuning、性能加速等方向优化AIGC算法效果，完成产品化落地。</li>\n<li>跟进技术落地与研究前沿，协助完善并更新领域技术地图，助力AIGC内容生态。<br>职位要求</li>\n<li>数学&#x2F;人工智能&#x2F;计算机&#x2F;机器学习&#x2F;娱乐技术&#x2F;游戏设计等相关专业，全日制统招在读硕博（2025年及以后毕业）。</li>\n<li>具有较强的编程能力，熟练使用Python，掌握常用数据结构算法，熟悉Linux开发环境。</li>\n<li>熟练使用主流深度学习框架，如PyTorch、TensorFlow等。</li>\n<li>实习6个月以上，能够保证每周至少到岗4天。</li>\n<li>热爱游戏，对AIGC在游戏领域应用有浓厚兴趣。<br>具备以下条件优先：</li>\n<li>具有扎实的计算机视觉或机器学习算法基础，有相关方向顶会论文者优先。</li>\n<li>熟悉常见Al生成模型框架及多模态模型，有stable diffusion, CLIP等实际应用经验者优先。</li>\n</ol>\n"},{"title":"非真实感渲染入门","date":"2023-01-28T16:00:00.000Z","index_img":"/img/bg/P5R.jpg","_content":"\n非真实感渲染入门\n<!-- more -->\n\n![](/article_img/2023-01-29-20-58-10.png)\n\n图形学渲染风格主要分为真实感渲染(Photorealistic rendering)和非真实感渲染(Non-photorealistic rendering，NPR)两大类。不同于真实感渲染是为了渲染出照片级别的画面，非真实感渲染主要在于模拟艺术化的绘制风格，呈现出手绘的效果。常见的非真实渲染技术包括卡通渲染、油画渲染、像素感渲染、铅笔画、素描画、蜡笔画和水墨画等类型。\n\n# 卡通渲染（Cel Shading/Toon Shading）\n\n卡通渲染是NPR领域应用最广的渲染技术，在影视和游戏领域十分常见。如《你的名字》，塞尔达传说：荒野之息，Okami和原神等作品。\n\n![](/article_img/2023-01-29-17-48-34.png)\n![](/article_img/2023-01-29-17-48-09.png)\n\n卡通渲染在游戏领域主要分为美式卡通风格和日式卡通风格两种。其中美式卡通色彩上比较连续，不会出现明显的色块分界线，如堡垒之夜；而日式卡通在着色方面会有明显的色块，色块的分界线清晰，如崩坏3。\n\n![](/article_img/2023-01-29-17-49-24.png)\n![](/article_img/2023-01-29-17-47-19.png)\n\n## 描边（Outline Rendering）\n\n在Real-Time Rendering一书中将描边技术分为了以下五大类：基于法线和视角的描边( Shading Normal Contour Edges)、过程式的几何描边( Procedural Geometry Silhouetting)、基于图片处理的描边( Edge Detection by Image Processing)、基于轮廓线检测的描边( Geometric Contour Edge Detection)和混合以上几种描边方法(Hybrid Silhouetting)。\n\n### 基于法线和视角的描边\n\n通过观察，位于边缘的法线与视线方向的夹角接近90°，因此可以使用视线方向和法线方向的点积结果来获取轮廓线的信息。\n\n![](/article_img/2023-01-29-17-59-12.png)\n\n但这种方法会导致描边的粗细不均匀。\n\n![](/article_img/2023-01-29-17-57-41.png)\n\n### 过程式几何描边\n\n基本思路是通过两次绘制，第一次绘制角色，第二次绘制描边。绘制描边的时候，在顶点着色器将顶点沿着法线方向位移一段距离，使得模型轮廓放大，渲染作为描边。\n\n![](/article_img/2023-01-29-18-13-30.png)\n\n![](/article_img/2023-01-29-18-15-41.png)\n\n### 基于图像处理的方法\n\n基于图像的算法是通过图像处理的方法来进行边缘检测，一般用于屏幕空间的检测。我们通常使用深度、法线、亮度和颜色等属性作为边缘判断的依据。\n\n![](/article_img/2023-01-29-18-19-47.png)\n\n![](/article_img/2023-01-29-18-24-21.png)\n\n左上角是法线图，中上是深度图，左下是法线图得到的边缘，中下是深度图得到的边缘，右上是经过加粗（取周围一定范围内的最深的像素的颜色为自身的颜色）的边缘图，右下是最后的结果。\n\n## 着色\n\n在卡通渲染中，尤其是日式的卡通渲染中，色阶较少且着色一般不是连续的，存在非常明显的颜色分界线。\n\n![](/article_img/2023-01-29-19-14-03.png)\n\n### 漫反射\n\n![](/article_img/2023-01-29-17-59-12.png)\n\n![](/article_img/2023-01-29-19-58-58.png)\n\n漫反射亮度采用Lambert模型，再进行阈值化。一般会根据NdotL = dot(normal，lightDir)的结果与阈值比较来指定不同的颜色值，从而模拟卡通色块的着色效果；除了这种方法之外，更常见的处理方式是利用NdotL的结果从一维渐变纹理RampTexture中进行采样\n\n![](/article_img/2023-01-29-19-24-00.png) | ![](/article_img/2023-01-30-13-26-02.png)\n---|---\n\n\n有些时候也会使用平滑阶跃函数柔化明暗边界，这样比较容易使角色与场景融合也起到一定的抗锯齿效果。\n\n![](/article_img/2023-01-29-19-37-56.png)\n\n### 高光\n\n![](/article_img/2023-01-29-19-28-42.png)\n\n根据法线和半向量的点积，与高光阈值比较，控制高光的范围。\n\nStylized highlights for cartoon rendering and animation\n[风格化高光](https://blog.csdn.net/candycat1992/article/details/50167285)\n![](/article_img/2023-01-30-13-46-43.png)\n\n### 边缘光\n\n物体的边缘会有一圈边缘光，实现比轮廓线更好的边界区分效果。这里的实现和基于法线和视角的描边一样。\n\n![](/article_img/2023-01-30-13-57-25.png)\n\n## NPR与PBR的结合\n\n![](/article_img/2023-01-30-15-47-25.png) \n\n![](/article_img/2023-01-30-20-10-34.png) | ![](/article_img/2023-01-30-20-12-26.png) | ![](/article_img/2023-01-30-20-14-01.png) | ![](/article_img/2023-01-30-20-18-46.png)\n---|---|---|---","source":"_posts/非真实感渲染入门.md","raw":"---\ntitle: 非真实感渲染入门\ndate: 2023-01-29\nindex_img: \"/img/bg/P5R.jpg\"\ntags: [NPR]\ncategories: \n   -[笔记]\n---\n\n非真实感渲染入门\n<!-- more -->\n\n![](/article_img/2023-01-29-20-58-10.png)\n\n图形学渲染风格主要分为真实感渲染(Photorealistic rendering)和非真实感渲染(Non-photorealistic rendering，NPR)两大类。不同于真实感渲染是为了渲染出照片级别的画面，非真实感渲染主要在于模拟艺术化的绘制风格，呈现出手绘的效果。常见的非真实渲染技术包括卡通渲染、油画渲染、像素感渲染、铅笔画、素描画、蜡笔画和水墨画等类型。\n\n# 卡通渲染（Cel Shading/Toon Shading）\n\n卡通渲染是NPR领域应用最广的渲染技术，在影视和游戏领域十分常见。如《你的名字》，塞尔达传说：荒野之息，Okami和原神等作品。\n\n![](/article_img/2023-01-29-17-48-34.png)\n![](/article_img/2023-01-29-17-48-09.png)\n\n卡通渲染在游戏领域主要分为美式卡通风格和日式卡通风格两种。其中美式卡通色彩上比较连续，不会出现明显的色块分界线，如堡垒之夜；而日式卡通在着色方面会有明显的色块，色块的分界线清晰，如崩坏3。\n\n![](/article_img/2023-01-29-17-49-24.png)\n![](/article_img/2023-01-29-17-47-19.png)\n\n## 描边（Outline Rendering）\n\n在Real-Time Rendering一书中将描边技术分为了以下五大类：基于法线和视角的描边( Shading Normal Contour Edges)、过程式的几何描边( Procedural Geometry Silhouetting)、基于图片处理的描边( Edge Detection by Image Processing)、基于轮廓线检测的描边( Geometric Contour Edge Detection)和混合以上几种描边方法(Hybrid Silhouetting)。\n\n### 基于法线和视角的描边\n\n通过观察，位于边缘的法线与视线方向的夹角接近90°，因此可以使用视线方向和法线方向的点积结果来获取轮廓线的信息。\n\n![](/article_img/2023-01-29-17-59-12.png)\n\n但这种方法会导致描边的粗细不均匀。\n\n![](/article_img/2023-01-29-17-57-41.png)\n\n### 过程式几何描边\n\n基本思路是通过两次绘制，第一次绘制角色，第二次绘制描边。绘制描边的时候，在顶点着色器将顶点沿着法线方向位移一段距离，使得模型轮廓放大，渲染作为描边。\n\n![](/article_img/2023-01-29-18-13-30.png)\n\n![](/article_img/2023-01-29-18-15-41.png)\n\n### 基于图像处理的方法\n\n基于图像的算法是通过图像处理的方法来进行边缘检测，一般用于屏幕空间的检测。我们通常使用深度、法线、亮度和颜色等属性作为边缘判断的依据。\n\n![](/article_img/2023-01-29-18-19-47.png)\n\n![](/article_img/2023-01-29-18-24-21.png)\n\n左上角是法线图，中上是深度图，左下是法线图得到的边缘，中下是深度图得到的边缘，右上是经过加粗（取周围一定范围内的最深的像素的颜色为自身的颜色）的边缘图，右下是最后的结果。\n\n## 着色\n\n在卡通渲染中，尤其是日式的卡通渲染中，色阶较少且着色一般不是连续的，存在非常明显的颜色分界线。\n\n![](/article_img/2023-01-29-19-14-03.png)\n\n### 漫反射\n\n![](/article_img/2023-01-29-17-59-12.png)\n\n![](/article_img/2023-01-29-19-58-58.png)\n\n漫反射亮度采用Lambert模型，再进行阈值化。一般会根据NdotL = dot(normal，lightDir)的结果与阈值比较来指定不同的颜色值，从而模拟卡通色块的着色效果；除了这种方法之外，更常见的处理方式是利用NdotL的结果从一维渐变纹理RampTexture中进行采样\n\n![](/article_img/2023-01-29-19-24-00.png) | ![](/article_img/2023-01-30-13-26-02.png)\n---|---\n\n\n有些时候也会使用平滑阶跃函数柔化明暗边界，这样比较容易使角色与场景融合也起到一定的抗锯齿效果。\n\n![](/article_img/2023-01-29-19-37-56.png)\n\n### 高光\n\n![](/article_img/2023-01-29-19-28-42.png)\n\n根据法线和半向量的点积，与高光阈值比较，控制高光的范围。\n\nStylized highlights for cartoon rendering and animation\n[风格化高光](https://blog.csdn.net/candycat1992/article/details/50167285)\n![](/article_img/2023-01-30-13-46-43.png)\n\n### 边缘光\n\n物体的边缘会有一圈边缘光，实现比轮廓线更好的边界区分效果。这里的实现和基于法线和视角的描边一样。\n\n![](/article_img/2023-01-30-13-57-25.png)\n\n## NPR与PBR的结合\n\n![](/article_img/2023-01-30-15-47-25.png) \n\n![](/article_img/2023-01-30-20-10-34.png) | ![](/article_img/2023-01-30-20-12-26.png) | ![](/article_img/2023-01-30-20-14-01.png) | ![](/article_img/2023-01-30-20-18-46.png)\n---|---|---|---","slug":"非真实感渲染入门","published":1,"updated":"2023-02-24T06:33:29.048Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clgkjigmj003pw0je3m7a2trh","content":"<p>非真实感渲染入门</p>\n<span id=\"more\"></span>\n\n<p><img src=\"/article_img/2023-01-29-20-58-10.png\"></p>\n<p>图形学渲染风格主要分为真实感渲染(Photorealistic rendering)和非真实感渲染(Non-photorealistic rendering，NPR)两大类。不同于真实感渲染是为了渲染出照片级别的画面，非真实感渲染主要在于模拟艺术化的绘制风格，呈现出手绘的效果。常见的非真实渲染技术包括卡通渲染、油画渲染、像素感渲染、铅笔画、素描画、蜡笔画和水墨画等类型。</p>\n<h1 id=\"卡通渲染（Cel-Shading-x2F-Toon-Shading）\"><a href=\"#卡通渲染（Cel-Shading-x2F-Toon-Shading）\" class=\"headerlink\" title=\"卡通渲染（Cel Shading&#x2F;Toon Shading）\"></a>卡通渲染（Cel Shading&#x2F;Toon Shading）</h1><p>卡通渲染是NPR领域应用最广的渲染技术，在影视和游戏领域十分常见。如《你的名字》，塞尔达传说：荒野之息，Okami和原神等作品。</p>\n<p><img src=\"/article_img/2023-01-29-17-48-34.png\"><br><img src=\"/article_img/2023-01-29-17-48-09.png\"></p>\n<p>卡通渲染在游戏领域主要分为美式卡通风格和日式卡通风格两种。其中美式卡通色彩上比较连续，不会出现明显的色块分界线，如堡垒之夜；而日式卡通在着色方面会有明显的色块，色块的分界线清晰，如崩坏3。</p>\n<p><img src=\"/article_img/2023-01-29-17-49-24.png\"><br><img src=\"/article_img/2023-01-29-17-47-19.png\"></p>\n<h2 id=\"描边（Outline-Rendering）\"><a href=\"#描边（Outline-Rendering）\" class=\"headerlink\" title=\"描边（Outline Rendering）\"></a>描边（Outline Rendering）</h2><p>在Real-Time Rendering一书中将描边技术分为了以下五大类：基于法线和视角的描边( Shading Normal Contour Edges)、过程式的几何描边( Procedural Geometry Silhouetting)、基于图片处理的描边( Edge Detection by Image Processing)、基于轮廓线检测的描边( Geometric Contour Edge Detection)和混合以上几种描边方法(Hybrid Silhouetting)。</p>\n<h3 id=\"基于法线和视角的描边\"><a href=\"#基于法线和视角的描边\" class=\"headerlink\" title=\"基于法线和视角的描边\"></a>基于法线和视角的描边</h3><p>通过观察，位于边缘的法线与视线方向的夹角接近90°，因此可以使用视线方向和法线方向的点积结果来获取轮廓线的信息。</p>\n<p><img src=\"/article_img/2023-01-29-17-59-12.png\"></p>\n<p>但这种方法会导致描边的粗细不均匀。</p>\n<p><img src=\"/article_img/2023-01-29-17-57-41.png\"></p>\n<h3 id=\"过程式几何描边\"><a href=\"#过程式几何描边\" class=\"headerlink\" title=\"过程式几何描边\"></a>过程式几何描边</h3><p>基本思路是通过两次绘制，第一次绘制角色，第二次绘制描边。绘制描边的时候，在顶点着色器将顶点沿着法线方向位移一段距离，使得模型轮廓放大，渲染作为描边。</p>\n<p><img src=\"/article_img/2023-01-29-18-13-30.png\"></p>\n<p><img src=\"/article_img/2023-01-29-18-15-41.png\"></p>\n<h3 id=\"基于图像处理的方法\"><a href=\"#基于图像处理的方法\" class=\"headerlink\" title=\"基于图像处理的方法\"></a>基于图像处理的方法</h3><p>基于图像的算法是通过图像处理的方法来进行边缘检测，一般用于屏幕空间的检测。我们通常使用深度、法线、亮度和颜色等属性作为边缘判断的依据。</p>\n<p><img src=\"/article_img/2023-01-29-18-19-47.png\"></p>\n<p><img src=\"/article_img/2023-01-29-18-24-21.png\"></p>\n<p>左上角是法线图，中上是深度图，左下是法线图得到的边缘，中下是深度图得到的边缘，右上是经过加粗（取周围一定范围内的最深的像素的颜色为自身的颜色）的边缘图，右下是最后的结果。</p>\n<h2 id=\"着色\"><a href=\"#着色\" class=\"headerlink\" title=\"着色\"></a>着色</h2><p>在卡通渲染中，尤其是日式的卡通渲染中，色阶较少且着色一般不是连续的，存在非常明显的颜色分界线。</p>\n<p><img src=\"/article_img/2023-01-29-19-14-03.png\"></p>\n<h3 id=\"漫反射\"><a href=\"#漫反射\" class=\"headerlink\" title=\"漫反射\"></a>漫反射</h3><p><img src=\"/article_img/2023-01-29-17-59-12.png\"></p>\n<p><img src=\"/article_img/2023-01-29-19-58-58.png\"></p>\n<p>漫反射亮度采用Lambert模型，再进行阈值化。一般会根据NdotL &#x3D; dot(normal，lightDir)的结果与阈值比较来指定不同的颜色值，从而模拟卡通色块的着色效果；除了这种方法之外，更常见的处理方式是利用NdotL的结果从一维渐变纹理RampTexture中进行采样</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-01-29-19-24-00.png\"></th>\n<th><img src=\"/article_img/2023-01-30-13-26-02.png\"></th>\n</tr>\n</thead>\n</table>\n<p>有些时候也会使用平滑阶跃函数柔化明暗边界，这样比较容易使角色与场景融合也起到一定的抗锯齿效果。</p>\n<p><img src=\"/article_img/2023-01-29-19-37-56.png\"></p>\n<h3 id=\"高光\"><a href=\"#高光\" class=\"headerlink\" title=\"高光\"></a>高光</h3><p><img src=\"/article_img/2023-01-29-19-28-42.png\"></p>\n<p>根据法线和半向量的点积，与高光阈值比较，控制高光的范围。</p>\n<p>Stylized highlights for cartoon rendering and animation<br><a href=\"https://blog.csdn.net/candycat1992/article/details/50167285\">风格化高光</a><br><img src=\"/article_img/2023-01-30-13-46-43.png\"></p>\n<h3 id=\"边缘光\"><a href=\"#边缘光\" class=\"headerlink\" title=\"边缘光\"></a>边缘光</h3><p>物体的边缘会有一圈边缘光，实现比轮廓线更好的边界区分效果。这里的实现和基于法线和视角的描边一样。</p>\n<p><img src=\"/article_img/2023-01-30-13-57-25.png\"></p>\n<h2 id=\"NPR与PBR的结合\"><a href=\"#NPR与PBR的结合\" class=\"headerlink\" title=\"NPR与PBR的结合\"></a>NPR与PBR的结合</h2><p><img src=\"/article_img/2023-01-30-15-47-25.png\"> </p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-01-30-20-10-34.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-12-26.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-14-01.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-18-46.png\"></th>\n</tr>\n</thead>\n</table>\n","site":{"data":{}},"wordcount":1345,"excerpt":"<p>非真实感渲染入门</p>","more":"<p><img src=\"/article_img/2023-01-29-20-58-10.png\"></p>\n<p>图形学渲染风格主要分为真实感渲染(Photorealistic rendering)和非真实感渲染(Non-photorealistic rendering，NPR)两大类。不同于真实感渲染是为了渲染出照片级别的画面，非真实感渲染主要在于模拟艺术化的绘制风格，呈现出手绘的效果。常见的非真实渲染技术包括卡通渲染、油画渲染、像素感渲染、铅笔画、素描画、蜡笔画和水墨画等类型。</p>\n<h1 id=\"卡通渲染（Cel-Shading-x2F-Toon-Shading）\"><a href=\"#卡通渲染（Cel-Shading-x2F-Toon-Shading）\" class=\"headerlink\" title=\"卡通渲染（Cel Shading&#x2F;Toon Shading）\"></a>卡通渲染（Cel Shading&#x2F;Toon Shading）</h1><p>卡通渲染是NPR领域应用最广的渲染技术，在影视和游戏领域十分常见。如《你的名字》，塞尔达传说：荒野之息，Okami和原神等作品。</p>\n<p><img src=\"/article_img/2023-01-29-17-48-34.png\"><br><img src=\"/article_img/2023-01-29-17-48-09.png\"></p>\n<p>卡通渲染在游戏领域主要分为美式卡通风格和日式卡通风格两种。其中美式卡通色彩上比较连续，不会出现明显的色块分界线，如堡垒之夜；而日式卡通在着色方面会有明显的色块，色块的分界线清晰，如崩坏3。</p>\n<p><img src=\"/article_img/2023-01-29-17-49-24.png\"><br><img src=\"/article_img/2023-01-29-17-47-19.png\"></p>\n<h2 id=\"描边（Outline-Rendering）\"><a href=\"#描边（Outline-Rendering）\" class=\"headerlink\" title=\"描边（Outline Rendering）\"></a>描边（Outline Rendering）</h2><p>在Real-Time Rendering一书中将描边技术分为了以下五大类：基于法线和视角的描边( Shading Normal Contour Edges)、过程式的几何描边( Procedural Geometry Silhouetting)、基于图片处理的描边( Edge Detection by Image Processing)、基于轮廓线检测的描边( Geometric Contour Edge Detection)和混合以上几种描边方法(Hybrid Silhouetting)。</p>\n<h3 id=\"基于法线和视角的描边\"><a href=\"#基于法线和视角的描边\" class=\"headerlink\" title=\"基于法线和视角的描边\"></a>基于法线和视角的描边</h3><p>通过观察，位于边缘的法线与视线方向的夹角接近90°，因此可以使用视线方向和法线方向的点积结果来获取轮廓线的信息。</p>\n<p><img src=\"/article_img/2023-01-29-17-59-12.png\"></p>\n<p>但这种方法会导致描边的粗细不均匀。</p>\n<p><img src=\"/article_img/2023-01-29-17-57-41.png\"></p>\n<h3 id=\"过程式几何描边\"><a href=\"#过程式几何描边\" class=\"headerlink\" title=\"过程式几何描边\"></a>过程式几何描边</h3><p>基本思路是通过两次绘制，第一次绘制角色，第二次绘制描边。绘制描边的时候，在顶点着色器将顶点沿着法线方向位移一段距离，使得模型轮廓放大，渲染作为描边。</p>\n<p><img src=\"/article_img/2023-01-29-18-13-30.png\"></p>\n<p><img src=\"/article_img/2023-01-29-18-15-41.png\"></p>\n<h3 id=\"基于图像处理的方法\"><a href=\"#基于图像处理的方法\" class=\"headerlink\" title=\"基于图像处理的方法\"></a>基于图像处理的方法</h3><p>基于图像的算法是通过图像处理的方法来进行边缘检测，一般用于屏幕空间的检测。我们通常使用深度、法线、亮度和颜色等属性作为边缘判断的依据。</p>\n<p><img src=\"/article_img/2023-01-29-18-19-47.png\"></p>\n<p><img src=\"/article_img/2023-01-29-18-24-21.png\"></p>\n<p>左上角是法线图，中上是深度图，左下是法线图得到的边缘，中下是深度图得到的边缘，右上是经过加粗（取周围一定范围内的最深的像素的颜色为自身的颜色）的边缘图，右下是最后的结果。</p>\n<h2 id=\"着色\"><a href=\"#着色\" class=\"headerlink\" title=\"着色\"></a>着色</h2><p>在卡通渲染中，尤其是日式的卡通渲染中，色阶较少且着色一般不是连续的，存在非常明显的颜色分界线。</p>\n<p><img src=\"/article_img/2023-01-29-19-14-03.png\"></p>\n<h3 id=\"漫反射\"><a href=\"#漫反射\" class=\"headerlink\" title=\"漫反射\"></a>漫反射</h3><p><img src=\"/article_img/2023-01-29-17-59-12.png\"></p>\n<p><img src=\"/article_img/2023-01-29-19-58-58.png\"></p>\n<p>漫反射亮度采用Lambert模型，再进行阈值化。一般会根据NdotL &#x3D; dot(normal，lightDir)的结果与阈值比较来指定不同的颜色值，从而模拟卡通色块的着色效果；除了这种方法之外，更常见的处理方式是利用NdotL的结果从一维渐变纹理RampTexture中进行采样</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-01-29-19-24-00.png\"></th>\n<th><img src=\"/article_img/2023-01-30-13-26-02.png\"></th>\n</tr>\n</thead>\n</table>\n<p>有些时候也会使用平滑阶跃函数柔化明暗边界，这样比较容易使角色与场景融合也起到一定的抗锯齿效果。</p>\n<p><img src=\"/article_img/2023-01-29-19-37-56.png\"></p>\n<h3 id=\"高光\"><a href=\"#高光\" class=\"headerlink\" title=\"高光\"></a>高光</h3><p><img src=\"/article_img/2023-01-29-19-28-42.png\"></p>\n<p>根据法线和半向量的点积，与高光阈值比较，控制高光的范围。</p>\n<p>Stylized highlights for cartoon rendering and animation<br><a href=\"https://blog.csdn.net/candycat1992/article/details/50167285\">风格化高光</a><br><img src=\"/article_img/2023-01-30-13-46-43.png\"></p>\n<h3 id=\"边缘光\"><a href=\"#边缘光\" class=\"headerlink\" title=\"边缘光\"></a>边缘光</h3><p>物体的边缘会有一圈边缘光，实现比轮廓线更好的边界区分效果。这里的实现和基于法线和视角的描边一样。</p>\n<p><img src=\"/article_img/2023-01-30-13-57-25.png\"></p>\n<h2 id=\"NPR与PBR的结合\"><a href=\"#NPR与PBR的结合\" class=\"headerlink\" title=\"NPR与PBR的结合\"></a>NPR与PBR的结合</h2><p><img src=\"/article_img/2023-01-30-15-47-25.png\"> </p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-01-30-20-10-34.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-12-26.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-14-01.png\"></th>\n<th><img src=\"/article_img/2023-01-30-20-18-46.png\"></th>\n</tr>\n</thead>\n</table>"},{"title":"C++Review-How C++ Works","date":"2023-04-16T16:00:00.000Z","index_img":"/img/bg/cpp.jpg","_content":"\n复习C++\n<!-- more -->\n\n主要参考 [Cherno's C++ 教程](https://www.bilibili.com/video/BV1qh411p7Sa?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n# C++从文本到程序\n\n我们编写的代码本质就是文本（text），要让这个文本变成机器可以执行的应用（binary），需要有两个主要的操作：编译（compiling）和链接（linking）。\n\n当我们按下编译键（ctrl+F7）时只会进行编译，按下build键时会先编译后链接。\n\n# C++编译器（Compiling）\n\nC++编译器的工作是将**文本**（.cpp文件或者.h文件）转换为**obj**文件，也就是机器语言。\n\n说到底就是编译器把代码转化为constant data或者instructions\n\n**编译的基本步骤**\n\n1. 需要**预处理（pre-process）** 代码，处理所有的预处理语句（preprocessor）\n2. 编辑**解释（tokenizing）**和**解析（parsing）**，将c++文件里的这些文本翻译成编译器可以理解和处理的语句\n   结果就是创建**抽象语法树（abstract syntax tree）**\n3. 根据这颗抽象语法树产生cpu真正执行的机器码\n\n## 编译单元（translation unit）和文件的关系\n\nC++不关心文件（file），是什么文件对编译器来说并没有硬性要求，编译器会默认cpp文件是C++文件，h文件是header文件，但是这只是默认，完全可以自定义另一种文件.cherno文件是C++文件，编译器就会将cherno文件当作C++文件处理。\n\n一个**编译单元（translation unit）** 对应一个**obj文件**，一般都是每个文件是一个编译单元，但是如果使用了#include，将别的文件包含在当前的文件中（本质就是创建了一个大的cpp文件，里面有很多cpp文件），且只编译当前这个文件，那么这个文件和他include的文件组成一个编译单元，也就只会得到一个obj文件。\n\n\n## 预处理（pre-process）\n\n**\\#include**的工作原理就是找到你include的文件，之后**复制**其全部内容到当前的文件。\n\n**\\#define**的工作原理就是用anything替换INTEGER\n\n![](/article_img/2023-04-19-12-13-27.png)\n\nMath.i是生成的预处理文件，可以在项目属性里设置生成预处理文件，但是这样VS就不会生成obj文件了。\n\n## obj文件\n\nobj文件就已经是机器码了：\n![](/article_img/2023-04-19-12-51-20.png)\n\n如果选择了**优化**，在编译阶段就会对代码进行优化，比如删掉未使用的代码，计算所有的常量，删掉多余的寄存器等等。而为了使Debug方便，VS在Debug模式下默认禁止代码优化，就导致其运行起来较慢。\n\n# C++链接器（Linking）\n\n当我们将每个编译单元编译成一个Obj文件之后，这些文件是独立的，并不能进行交流，而我们经常将不同的代码写在不同的文件中，因此我们需要**链接（Linking）**，将这些独立的Obj文件联系起来。就算我们将所有的代码都写在一个文件中，我们也需要告知程序的入口（main函数）在哪，也需要链接操作。\n\n## 常见的链接错误\n\n1. unresolved external symbol（未解决的外部符号）：链接器找不到他需要的东西\n2. one or more multiply defined symbols found（重复定义）：链接器不知道选择哪个\n   常见于include头文件时，可以使用static，inline或者移动函数定义的方式（关键点就是理解include实际上就是复制粘贴！）\n\n\n# VS设置\n\n## Output\n\n输出目录：$(SolutionDir)bin\\$(Platform)\\$(Configuration)\\\n\n中间目录：$(SolutionDir)bin\\intermediates\\$(Platform)\\$(Configuration)\\  \n\n![](/article_img/2023-04-19-16-20-25.png)\n\n可以使结构清晰，方便查找。\n\n# Static关键字\n\n## 在类或结构体外\n\n类外的static修饰的符号在link阶段是**局部**的，也就是说它只对定义它的 **编译单元（.obj）** 可见。\n\n当链接器（Linker）工作时，他不会找static修饰的变量，如果不是static修饰的全局变量，在link阶段就会随着链接而变成一个“**整个项目的全局变量**”，因为每一个使用到这个全局变量的编译单元都会去其他编译单元中寻找这个全局变量，如果不同的编译单元中定义了命名相同的全局变量，就会在链接阶段报重复定义的错。\n\n假如在头文件中定义static变量，之后在不同的cpp文件中#include这个头文件，那么其实这些不同文件中的变量是相互独立的（因为#include就是复制，相当于分别在不同的文件中定义了static变量）\n\n### extern\n\nextern表示其修饰的变量或函数需要在其他编译单元中寻找。\n\n因此：**尽量让所有的全局变量和全局函数都被static修饰**\n\n## 在类或结构体内\n\n类内的static修饰的符号表示这部分内存是这个类的**所有实例共享的**，静态方法（static method）不能访问任何非静态的变量或方法（**因为类内的static只会被实例化一次，也可以理解为静态方法没有类实例，它并不能得到当前被实例化对象的信息**），类中的非静态方法之所以可以访问类中的变量是因为有个隐含的参数：**this指针**，而静态方法没有this指针，就当然不能访问非静态的成员了。\n```c++\n\nclass A{\n   int a,b;\n   void print(){\n      std::cout<< a << , << b <<std::endl;\n   }\n   /*\n   这个函数在编译阶段就会变成下面这样\n   void print(this){\n      std::cout<< this.a << , << this.b <<std::endl;\n   }\n   */\n\n   static void Sprint(){\n      std::cout<< a << , << b <<std::endl;  // 编译无法通过，静态方法不能访问非静态变量\n   }\n      /*\n   这个函数在编译阶段就会变成下面这样，根本不知道a，b是什么\n   void print(){\n      std::cout<< a << , << b <<std::endl;\n   }\n   */\n};\n\n```\n\n## static关键字使用场景\n\n1. 作用域是局部作用域，生命周期是整个程序的生命周期\n   ```c++\n   void function(){\n      static int i = 0;\n      i++;\n      std::cout<< i <<std::endl;\n   }\n   ```\n2. 单例模式（只有一个实例），这应该是Cherno自己的写法一般也不这么写？\n   ```c++\n   class Singleton{\n   public:\n      static Singleton& Get(){\n         static Singleton instance;\n         return instance;\n      }\n   };\n\n   int main(){\n      Singleton::Get();\n      return 0;\n   }\n   ```\n# const关键字\n\nCherno把const称为一个假的关键字，因为它并不会对产生的代码造成什么实质上的影响，它只是一种 **承诺** ，承诺这是一个不会被改变的常量，用来方便编程。\n\n## const常见用法\n\n1. 定义常量\n   ```c++\n   const int MAX_SPEED = 50;\n   ```\n2. 定义指针**本身**是常量还是指针**指向的内容**的常量\n   ```c++\n   int* aPtr = new int(2);\n   /*-------------------------------------*/\n   const int* p0 = new int;  // p0指针指向的内存存的是不可改变的常量，等价于：int const* p0 = new int;\n   *p0 = 2; // 报错\n   p0 = aPtr; // 正确 \n   /*-------------------------------------*/\n   int* const p1 = new int;  // p1指针指向的内存地址是不可改变的\n   *p1 = 2; // 正确\n   p1 = aPtr; // 报错\n   /*-------------------------------------*/\n   const int* const p2 = new int;  // p2指针指向的内存地址不可改变，内存地址中的量也不可改变\n   *p2 = 2; // 报错\n   p2 = aPtr; // 报错\n   ```\n3. 定义类中的方法，承诺这个方法不会修改变量（const只能修饰类中的方法）\n   ```c++\n   class Entity{\n   public:\n      int m_X, m_Y;\n      int GetX() const{\n         return m_X;\n      }\n      void SetX(int x){\n         m_X = x;\n      }\n   };\n   ```\n   ![](/article_img/2023-04-21-13-49-02.png) \n   const如果只是一个承诺那它是不是没什么实际的用处呢？当然不是！按照下图，GetX()**必须**用const修饰，因为函数**Print(const Entity& e)** 的参数是一个**常引用**（类比上面的const int* p），意味着其引用的对象（也就是自身，因为引用只是一个别名）是一个常量，那就要确保在函数中不能对自己这个常量进行修改，就只能调用被const修饰的函数。\n   ![](/article_img/2023-04-21-13-52-38.png) | ![](/article_img/2023-04-21-14-03-00.png)\n   ---|---\n   **因此，如果没有修改类或者不应该修改类时，总是把这个方法标记为const**\n\n# 枚举\n\n## 枚举类型\n\n**枚举类型本质就是整型**，下面的LevelError，LevelWarning，LevelInfo值就是0，1，2；因此枚举也可以直接进行整型的大小比较。\n\n```c++\nenum Level{\n   LevelError, LevelWarning, LevelInfo\n}；\n\nint main(){\n   Level l = LevelError;\n   if(l > 0){\n      //Do something\n   }\n}\n```\n\n# 构造函数\n\n**总是使用构造函数初始化列表！**，不适用函数初始化列表会导致一些变量（比如下面的m_A）被初始化多次，造成性能浪费。\n\n![](/article_img/2023-04-21-14-35-19.png) | ![](/article_img/2023-04-21-14-36-18.png) \n---|---\n\n# 继承\n\n\n继承的基本写法：\n```c++\nclass Entity{\npublic:\n   float X, Y;\n   void Move(float xa, float ya){\n      X += xa;\n      Y += ya;\n   }\n};\n\nclass Player : public Entity{\npublic:\n   const char* Name;\n\n   void PrintName(){\n      // print name \n   }\n}\n```\n\nPlayer类**不仅**是Player类，它**同样**是一个Entity类。我们可以在任何想要使用Entity的地方使用Player（**多态**）\n\n## 虚函数\n\n虚函数一般通过 **虚函数表（vtable）** 来实现编译，在编译阶段通过查询虚函数表确定该函数的定义。\n\n在c++11中允许用 **override** 标注被重写的虚函数。\n\n```c++\nclass Entity{\npublic:\n   float X, Y;\n   const char* Name;\n   Entity(const char* name){ Name = name; } // 构造函数\n   void Move(float xa, float ya){\n      // move\n   }\n   virtual void PrintName(){   // 虚函数基本用法\n      // print entity's name \n   }\n};\n\nclass Player : public Entity{\npublic:\n   void PrintName() override {\n      // print player's name \n   }\n}\n```\n## 纯虚函数（接口）\n\n纯虚函数的本质和其他语言中的接口相同，它是一种特殊的虚函数，在父类中不需要实现，而在子类中**必须**实现。\n\n包含纯虚函数的类不能被实例化，因为纯虚函数没有被定义。**只能实例化一个实现了所有纯虚函数的类。**\n\n```c++\nclass Printable{  \n   virtual void GetClassName() = 0;  // 纯虚函数\n};\nclass Entity : public Printable{  // 继承自Printable\npublic:\n   void GetClassName() override { std::cout << \"Entity\" << std::endl; } \n};\nclass Player : public Entity{   // 继承自Entity\npublic:\n   void GetClassName() override { std::cout << \"Player\" << std::endl; }   // 还需要再次定义，否则就会调用Entity中的GetClassName()\n}\n\nvoid Print(Printable* obj){\n   std::cout << obj->GetClassName << std::endl;\n}\n\nint main(){\n   Entity* e = new Entity();\n   Player* p = new Player();\n   Print(e);\n   Print(p);\n}\n/*\n输出：\nEntity\nPlayer\n*/\n```\n\n# 操作符和操作符重载\n\n操作符本质就是函数。\n```c++\nstruct Vector2 {\n    float x, y;\n    Vector2(int x, int y) :x(x), y(y) {}\n\n    Vector2 Add(const Vector2& other) const {\n        return Vector2(x + other.x, y + other.y);\n    }\n    Vector2 operator+(const Vector2& other) const {\n        return Add(other);\n    }\n\n    Vector2 Multiply(const Vector2& other) const {\n        return Vector2(x * other.x, y * other.y);\n    }\n    Vector2 operator*(const Vector2& other) const {\n        return Multiply(other);\n    }\n\n    bool operator==(const Vector2& other) const {\n        return x == other.x && y == other.y;\n    }\n    bool operator!=(const Vector2& other) const {\n        return !(*this==other);\n    }\n};\n\nstd::ostream& operator<<(std::ostream& stream, const Vector2& other) {\n    stream << other.x << \",\" << other.y;\n    return stream;\n}\n```\n\n","source":"_posts/C++Review_How.md","raw":"---\ntitle: C++Review-How C++ Works\ndate: 2023-04-17\nindex_img: \"/img/bg/cpp.jpg\"\ntags: [C++]\ncategories: \n   -[C++]\n---\n\n复习C++\n<!-- more -->\n\n主要参考 [Cherno's C++ 教程](https://www.bilibili.com/video/BV1qh411p7Sa?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20)\n\n# C++从文本到程序\n\n我们编写的代码本质就是文本（text），要让这个文本变成机器可以执行的应用（binary），需要有两个主要的操作：编译（compiling）和链接（linking）。\n\n当我们按下编译键（ctrl+F7）时只会进行编译，按下build键时会先编译后链接。\n\n# C++编译器（Compiling）\n\nC++编译器的工作是将**文本**（.cpp文件或者.h文件）转换为**obj**文件，也就是机器语言。\n\n说到底就是编译器把代码转化为constant data或者instructions\n\n**编译的基本步骤**\n\n1. 需要**预处理（pre-process）** 代码，处理所有的预处理语句（preprocessor）\n2. 编辑**解释（tokenizing）**和**解析（parsing）**，将c++文件里的这些文本翻译成编译器可以理解和处理的语句\n   结果就是创建**抽象语法树（abstract syntax tree）**\n3. 根据这颗抽象语法树产生cpu真正执行的机器码\n\n## 编译单元（translation unit）和文件的关系\n\nC++不关心文件（file），是什么文件对编译器来说并没有硬性要求，编译器会默认cpp文件是C++文件，h文件是header文件，但是这只是默认，完全可以自定义另一种文件.cherno文件是C++文件，编译器就会将cherno文件当作C++文件处理。\n\n一个**编译单元（translation unit）** 对应一个**obj文件**，一般都是每个文件是一个编译单元，但是如果使用了#include，将别的文件包含在当前的文件中（本质就是创建了一个大的cpp文件，里面有很多cpp文件），且只编译当前这个文件，那么这个文件和他include的文件组成一个编译单元，也就只会得到一个obj文件。\n\n\n## 预处理（pre-process）\n\n**\\#include**的工作原理就是找到你include的文件，之后**复制**其全部内容到当前的文件。\n\n**\\#define**的工作原理就是用anything替换INTEGER\n\n![](/article_img/2023-04-19-12-13-27.png)\n\nMath.i是生成的预处理文件，可以在项目属性里设置生成预处理文件，但是这样VS就不会生成obj文件了。\n\n## obj文件\n\nobj文件就已经是机器码了：\n![](/article_img/2023-04-19-12-51-20.png)\n\n如果选择了**优化**，在编译阶段就会对代码进行优化，比如删掉未使用的代码，计算所有的常量，删掉多余的寄存器等等。而为了使Debug方便，VS在Debug模式下默认禁止代码优化，就导致其运行起来较慢。\n\n# C++链接器（Linking）\n\n当我们将每个编译单元编译成一个Obj文件之后，这些文件是独立的，并不能进行交流，而我们经常将不同的代码写在不同的文件中，因此我们需要**链接（Linking）**，将这些独立的Obj文件联系起来。就算我们将所有的代码都写在一个文件中，我们也需要告知程序的入口（main函数）在哪，也需要链接操作。\n\n## 常见的链接错误\n\n1. unresolved external symbol（未解决的外部符号）：链接器找不到他需要的东西\n2. one or more multiply defined symbols found（重复定义）：链接器不知道选择哪个\n   常见于include头文件时，可以使用static，inline或者移动函数定义的方式（关键点就是理解include实际上就是复制粘贴！）\n\n\n# VS设置\n\n## Output\n\n输出目录：$(SolutionDir)bin\\$(Platform)\\$(Configuration)\\\n\n中间目录：$(SolutionDir)bin\\intermediates\\$(Platform)\\$(Configuration)\\  \n\n![](/article_img/2023-04-19-16-20-25.png)\n\n可以使结构清晰，方便查找。\n\n# Static关键字\n\n## 在类或结构体外\n\n类外的static修饰的符号在link阶段是**局部**的，也就是说它只对定义它的 **编译单元（.obj）** 可见。\n\n当链接器（Linker）工作时，他不会找static修饰的变量，如果不是static修饰的全局变量，在link阶段就会随着链接而变成一个“**整个项目的全局变量**”，因为每一个使用到这个全局变量的编译单元都会去其他编译单元中寻找这个全局变量，如果不同的编译单元中定义了命名相同的全局变量，就会在链接阶段报重复定义的错。\n\n假如在头文件中定义static变量，之后在不同的cpp文件中#include这个头文件，那么其实这些不同文件中的变量是相互独立的（因为#include就是复制，相当于分别在不同的文件中定义了static变量）\n\n### extern\n\nextern表示其修饰的变量或函数需要在其他编译单元中寻找。\n\n因此：**尽量让所有的全局变量和全局函数都被static修饰**\n\n## 在类或结构体内\n\n类内的static修饰的符号表示这部分内存是这个类的**所有实例共享的**，静态方法（static method）不能访问任何非静态的变量或方法（**因为类内的static只会被实例化一次，也可以理解为静态方法没有类实例，它并不能得到当前被实例化对象的信息**），类中的非静态方法之所以可以访问类中的变量是因为有个隐含的参数：**this指针**，而静态方法没有this指针，就当然不能访问非静态的成员了。\n```c++\n\nclass A{\n   int a,b;\n   void print(){\n      std::cout<< a << , << b <<std::endl;\n   }\n   /*\n   这个函数在编译阶段就会变成下面这样\n   void print(this){\n      std::cout<< this.a << , << this.b <<std::endl;\n   }\n   */\n\n   static void Sprint(){\n      std::cout<< a << , << b <<std::endl;  // 编译无法通过，静态方法不能访问非静态变量\n   }\n      /*\n   这个函数在编译阶段就会变成下面这样，根本不知道a，b是什么\n   void print(){\n      std::cout<< a << , << b <<std::endl;\n   }\n   */\n};\n\n```\n\n## static关键字使用场景\n\n1. 作用域是局部作用域，生命周期是整个程序的生命周期\n   ```c++\n   void function(){\n      static int i = 0;\n      i++;\n      std::cout<< i <<std::endl;\n   }\n   ```\n2. 单例模式（只有一个实例），这应该是Cherno自己的写法一般也不这么写？\n   ```c++\n   class Singleton{\n   public:\n      static Singleton& Get(){\n         static Singleton instance;\n         return instance;\n      }\n   };\n\n   int main(){\n      Singleton::Get();\n      return 0;\n   }\n   ```\n# const关键字\n\nCherno把const称为一个假的关键字，因为它并不会对产生的代码造成什么实质上的影响，它只是一种 **承诺** ，承诺这是一个不会被改变的常量，用来方便编程。\n\n## const常见用法\n\n1. 定义常量\n   ```c++\n   const int MAX_SPEED = 50;\n   ```\n2. 定义指针**本身**是常量还是指针**指向的内容**的常量\n   ```c++\n   int* aPtr = new int(2);\n   /*-------------------------------------*/\n   const int* p0 = new int;  // p0指针指向的内存存的是不可改变的常量，等价于：int const* p0 = new int;\n   *p0 = 2; // 报错\n   p0 = aPtr; // 正确 \n   /*-------------------------------------*/\n   int* const p1 = new int;  // p1指针指向的内存地址是不可改变的\n   *p1 = 2; // 正确\n   p1 = aPtr; // 报错\n   /*-------------------------------------*/\n   const int* const p2 = new int;  // p2指针指向的内存地址不可改变，内存地址中的量也不可改变\n   *p2 = 2; // 报错\n   p2 = aPtr; // 报错\n   ```\n3. 定义类中的方法，承诺这个方法不会修改变量（const只能修饰类中的方法）\n   ```c++\n   class Entity{\n   public:\n      int m_X, m_Y;\n      int GetX() const{\n         return m_X;\n      }\n      void SetX(int x){\n         m_X = x;\n      }\n   };\n   ```\n   ![](/article_img/2023-04-21-13-49-02.png) \n   const如果只是一个承诺那它是不是没什么实际的用处呢？当然不是！按照下图，GetX()**必须**用const修饰，因为函数**Print(const Entity& e)** 的参数是一个**常引用**（类比上面的const int* p），意味着其引用的对象（也就是自身，因为引用只是一个别名）是一个常量，那就要确保在函数中不能对自己这个常量进行修改，就只能调用被const修饰的函数。\n   ![](/article_img/2023-04-21-13-52-38.png) | ![](/article_img/2023-04-21-14-03-00.png)\n   ---|---\n   **因此，如果没有修改类或者不应该修改类时，总是把这个方法标记为const**\n\n# 枚举\n\n## 枚举类型\n\n**枚举类型本质就是整型**，下面的LevelError，LevelWarning，LevelInfo值就是0，1，2；因此枚举也可以直接进行整型的大小比较。\n\n```c++\nenum Level{\n   LevelError, LevelWarning, LevelInfo\n}；\n\nint main(){\n   Level l = LevelError;\n   if(l > 0){\n      //Do something\n   }\n}\n```\n\n# 构造函数\n\n**总是使用构造函数初始化列表！**，不适用函数初始化列表会导致一些变量（比如下面的m_A）被初始化多次，造成性能浪费。\n\n![](/article_img/2023-04-21-14-35-19.png) | ![](/article_img/2023-04-21-14-36-18.png) \n---|---\n\n# 继承\n\n\n继承的基本写法：\n```c++\nclass Entity{\npublic:\n   float X, Y;\n   void Move(float xa, float ya){\n      X += xa;\n      Y += ya;\n   }\n};\n\nclass Player : public Entity{\npublic:\n   const char* Name;\n\n   void PrintName(){\n      // print name \n   }\n}\n```\n\nPlayer类**不仅**是Player类，它**同样**是一个Entity类。我们可以在任何想要使用Entity的地方使用Player（**多态**）\n\n## 虚函数\n\n虚函数一般通过 **虚函数表（vtable）** 来实现编译，在编译阶段通过查询虚函数表确定该函数的定义。\n\n在c++11中允许用 **override** 标注被重写的虚函数。\n\n```c++\nclass Entity{\npublic:\n   float X, Y;\n   const char* Name;\n   Entity(const char* name){ Name = name; } // 构造函数\n   void Move(float xa, float ya){\n      // move\n   }\n   virtual void PrintName(){   // 虚函数基本用法\n      // print entity's name \n   }\n};\n\nclass Player : public Entity{\npublic:\n   void PrintName() override {\n      // print player's name \n   }\n}\n```\n## 纯虚函数（接口）\n\n纯虚函数的本质和其他语言中的接口相同，它是一种特殊的虚函数，在父类中不需要实现，而在子类中**必须**实现。\n\n包含纯虚函数的类不能被实例化，因为纯虚函数没有被定义。**只能实例化一个实现了所有纯虚函数的类。**\n\n```c++\nclass Printable{  \n   virtual void GetClassName() = 0;  // 纯虚函数\n};\nclass Entity : public Printable{  // 继承自Printable\npublic:\n   void GetClassName() override { std::cout << \"Entity\" << std::endl; } \n};\nclass Player : public Entity{   // 继承自Entity\npublic:\n   void GetClassName() override { std::cout << \"Player\" << std::endl; }   // 还需要再次定义，否则就会调用Entity中的GetClassName()\n}\n\nvoid Print(Printable* obj){\n   std::cout << obj->GetClassName << std::endl;\n}\n\nint main(){\n   Entity* e = new Entity();\n   Player* p = new Player();\n   Print(e);\n   Print(p);\n}\n/*\n输出：\nEntity\nPlayer\n*/\n```\n\n# 操作符和操作符重载\n\n操作符本质就是函数。\n```c++\nstruct Vector2 {\n    float x, y;\n    Vector2(int x, int y) :x(x), y(y) {}\n\n    Vector2 Add(const Vector2& other) const {\n        return Vector2(x + other.x, y + other.y);\n    }\n    Vector2 operator+(const Vector2& other) const {\n        return Add(other);\n    }\n\n    Vector2 Multiply(const Vector2& other) const {\n        return Vector2(x * other.x, y * other.y);\n    }\n    Vector2 operator*(const Vector2& other) const {\n        return Multiply(other);\n    }\n\n    bool operator==(const Vector2& other) const {\n        return x == other.x && y == other.y;\n    }\n    bool operator!=(const Vector2& other) const {\n        return !(*this==other);\n    }\n};\n\nstd::ostream& operator<<(std::ostream& stream, const Vector2& other) {\n    stream << other.x << \",\" << other.y;\n    return stream;\n}\n```\n\n","slug":"C++Review_How","published":1,"updated":"2023-04-21T07:46:40.330Z","_id":"clgnb2ch70000woje9qfk036c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>复习C++</p>\n<span id=\"more\"></span>\n\n<p>主要参考 <a href=\"https://www.bilibili.com/video/BV1qh411p7Sa?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20\">Cherno’s C++ 教程</a></p>\n<h1 id=\"C-从文本到程序\"><a href=\"#C-从文本到程序\" class=\"headerlink\" title=\"C++从文本到程序\"></a>C++从文本到程序</h1><p>我们编写的代码本质就是文本（text），要让这个文本变成机器可以执行的应用（binary），需要有两个主要的操作：编译（compiling）和链接（linking）。</p>\n<p>当我们按下编译键（ctrl+F7）时只会进行编译，按下build键时会先编译后链接。</p>\n<h1 id=\"C-编译器（Compiling）\"><a href=\"#C-编译器（Compiling）\" class=\"headerlink\" title=\"C++编译器（Compiling）\"></a>C++编译器（Compiling）</h1><p>C++编译器的工作是将<strong>文本</strong>（.cpp文件或者.h文件）转换为<strong>obj</strong>文件，也就是机器语言。</p>\n<p>说到底就是编译器把代码转化为constant data或者instructions</p>\n<p><strong>编译的基本步骤</strong></p>\n<ol>\n<li>需要<strong>预处理（pre-process）</strong> 代码，处理所有的预处理语句（preprocessor）</li>\n<li>编辑<strong>解释（tokenizing）</strong>和<strong>解析（parsing）</strong>，将c++文件里的这些文本翻译成编译器可以理解和处理的语句<br>结果就是创建<strong>抽象语法树（abstract syntax tree）</strong></li>\n<li>根据这颗抽象语法树产生cpu真正执行的机器码</li>\n</ol>\n<h2 id=\"编译单元（translation-unit）和文件的关系\"><a href=\"#编译单元（translation-unit）和文件的关系\" class=\"headerlink\" title=\"编译单元（translation unit）和文件的关系\"></a>编译单元（translation unit）和文件的关系</h2><p>C++不关心文件（file），是什么文件对编译器来说并没有硬性要求，编译器会默认cpp文件是C++文件，h文件是header文件，但是这只是默认，完全可以自定义另一种文件.cherno文件是C++文件，编译器就会将cherno文件当作C++文件处理。</p>\n<p>一个<strong>编译单元（translation unit）</strong> 对应一个<strong>obj文件</strong>，一般都是每个文件是一个编译单元，但是如果使用了#include，将别的文件包含在当前的文件中（本质就是创建了一个大的cpp文件，里面有很多cpp文件），且只编译当前这个文件，那么这个文件和他include的文件组成一个编译单元，也就只会得到一个obj文件。</p>\n<h2 id=\"预处理（pre-process）\"><a href=\"#预处理（pre-process）\" class=\"headerlink\" title=\"预处理（pre-process）\"></a>预处理（pre-process）</h2><p><strong>#include</strong>的工作原理就是找到你include的文件，之后<strong>复制</strong>其全部内容到当前的文件。</p>\n<p><strong>#define</strong>的工作原理就是用anything替换INTEGER</p>\n<p><img src=\"/article_img/2023-04-19-12-13-27.png\"></p>\n<p>Math.i是生成的预处理文件，可以在项目属性里设置生成预处理文件，但是这样VS就不会生成obj文件了。</p>\n<h2 id=\"obj文件\"><a href=\"#obj文件\" class=\"headerlink\" title=\"obj文件\"></a>obj文件</h2><p>obj文件就已经是机器码了：<br><img src=\"/article_img/2023-04-19-12-51-20.png\"></p>\n<p>如果选择了<strong>优化</strong>，在编译阶段就会对代码进行优化，比如删掉未使用的代码，计算所有的常量，删掉多余的寄存器等等。而为了使Debug方便，VS在Debug模式下默认禁止代码优化，就导致其运行起来较慢。</p>\n<h1 id=\"C-链接器（Linking）\"><a href=\"#C-链接器（Linking）\" class=\"headerlink\" title=\"C++链接器（Linking）\"></a>C++链接器（Linking）</h1><p>当我们将每个编译单元编译成一个Obj文件之后，这些文件是独立的，并不能进行交流，而我们经常将不同的代码写在不同的文件中，因此我们需要<strong>链接（Linking）</strong>，将这些独立的Obj文件联系起来。就算我们将所有的代码都写在一个文件中，我们也需要告知程序的入口（main函数）在哪，也需要链接操作。</p>\n<h2 id=\"常见的链接错误\"><a href=\"#常见的链接错误\" class=\"headerlink\" title=\"常见的链接错误\"></a>常见的链接错误</h2><ol>\n<li>unresolved external symbol（未解决的外部符号）：链接器找不到他需要的东西</li>\n<li>one or more multiply defined symbols found（重复定义）：链接器不知道选择哪个<br>常见于include头文件时，可以使用static，inline或者移动函数定义的方式（关键点就是理解include实际上就是复制粘贴！）</li>\n</ol>\n<h1 id=\"VS设置\"><a href=\"#VS设置\" class=\"headerlink\" title=\"VS设置\"></a>VS设置</h1><h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>输出目录：$(SolutionDir)bin$(Platform)$(Configuration)\\</p>\n<p>中间目录：$(SolutionDir)bin\\intermediates$(Platform)$(Configuration)\\  </p>\n<p><img src=\"/article_img/2023-04-19-16-20-25.png\"></p>\n<p>可以使结构清晰，方便查找。</p>\n<h1 id=\"Static关键字\"><a href=\"#Static关键字\" class=\"headerlink\" title=\"Static关键字\"></a>Static关键字</h1><h2 id=\"在类或结构体外\"><a href=\"#在类或结构体外\" class=\"headerlink\" title=\"在类或结构体外\"></a>在类或结构体外</h2><p>类外的static修饰的符号在link阶段是<strong>局部</strong>的，也就是说它只对定义它的 <strong>编译单元（.obj）</strong> 可见。</p>\n<p>当链接器（Linker）工作时，他不会找static修饰的变量，如果不是static修饰的全局变量，在link阶段就会随着链接而变成一个“<strong>整个项目的全局变量</strong>”，因为每一个使用到这个全局变量的编译单元都会去其他编译单元中寻找这个全局变量，如果不同的编译单元中定义了命名相同的全局变量，就会在链接阶段报重复定义的错。</p>\n<p>假如在头文件中定义static变量，之后在不同的cpp文件中#include这个头文件，那么其实这些不同文件中的变量是相互独立的（因为#include就是复制，相当于分别在不同的文件中定义了static变量）</p>\n<h3 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h3><p>extern表示其修饰的变量或函数需要在其他编译单元中寻找。</p>\n<p>因此：<strong>尽量让所有的全局变量和全局函数都被static修饰</strong></p>\n<h2 id=\"在类或结构体内\"><a href=\"#在类或结构体内\" class=\"headerlink\" title=\"在类或结构体内\"></a>在类或结构体内</h2><p>类内的static修饰的符号表示这部分内存是这个类的<strong>所有实例共享的</strong>，静态方法（static method）不能访问任何非静态的变量或方法（<strong>因为类内的static只会被实例化一次，也可以理解为静态方法没有类实例，它并不能得到当前被实例化对象的信息</strong>），类中的非静态方法之所以可以访问类中的变量是因为有个隐含的参数：<strong>this指针</strong>，而静态方法没有this指针，就当然不能访问非静态的成员了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>&#123;<br>   <span class=\"hljs-type\">int</span> a,b;<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span></span>&#123;<br>      std::cout&lt;&lt; a &lt;&lt; , &lt;&lt; b &lt;&lt;std::endl;<br>   &#125;<br>   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">   这个函数在编译阶段就会变成下面这样</span><br><span class=\"hljs-comment\">   void print(this)&#123;</span><br><span class=\"hljs-comment\">      std::cout&lt;&lt; this.a &lt;&lt; , &lt;&lt; this.b &lt;&lt;std::endl;</span><br><span class=\"hljs-comment\">   &#125;</span><br><span class=\"hljs-comment\">   */</span><br><br>   <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Sprint</span><span class=\"hljs-params\">()</span></span>&#123;<br>      std::cout&lt;&lt; a &lt;&lt; , &lt;&lt; b &lt;&lt;std::endl;  <span class=\"hljs-comment\">// 编译无法通过，静态方法不能访问非静态变量</span><br>   &#125;<br>      <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">   这个函数在编译阶段就会变成下面这样，根本不知道a，b是什么</span><br><span class=\"hljs-comment\">   void print()&#123;</span><br><span class=\"hljs-comment\">      std::cout&lt;&lt; a &lt;&lt; , &lt;&lt; b &lt;&lt;std::endl;</span><br><span class=\"hljs-comment\">   &#125;</span><br><span class=\"hljs-comment\">   */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"static关键字使用场景\"><a href=\"#static关键字使用场景\" class=\"headerlink\" title=\"static关键字使用场景\"></a>static关键字使用场景</h2><ol>\n<li>作用域是局部作用域，生命周期是整个程序的生命周期<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function</span><span class=\"hljs-params\">()</span></span>&#123;<br>   <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>   i++;<br>   std::cout&lt;&lt; i &lt;&lt;std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>单例模式（只有一个实例），这应该是Cherno自己的写法一般也不这么写？<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Singleton</span>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> Singleton&amp; <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">()</span></span>&#123;<br>      <span class=\"hljs-type\">static</span> Singleton instance;<br>      <span class=\"hljs-keyword\">return</span> instance;<br>   &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>   Singleton::<span class=\"hljs-built_in\">Get</span>();<br>   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"const关键字\"><a href=\"#const关键字\" class=\"headerlink\" title=\"const关键字\"></a>const关键字</h1><p>Cherno把const称为一个假的关键字，因为它并不会对产生的代码造成什么实质上的影响，它只是一种 <strong>承诺</strong> ，承诺这是一个不会被改变的常量，用来方便编程。</p>\n<h2 id=\"const常见用法\"><a href=\"#const常见用法\" class=\"headerlink\" title=\"const常见用法\"></a>const常见用法</h2><ol>\n<li>定义常量<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MAX_SPEED = <span class=\"hljs-number\">50</span>;<br></code></pre></td></tr></table></figure></li>\n<li>定义指针<strong>本身</strong>是常量还是指针<strong>指向的内容</strong>的常量<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span>* aPtr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">2</span>);<br><span class=\"hljs-comment\">/*-------------------------------------*/</span><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* p0 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;  <span class=\"hljs-comment\">// p0指针指向的内存存的是不可改变的常量，等价于：int const* p0 = new int;</span><br>*p0 = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 报错</span><br>p0 = aPtr; <span class=\"hljs-comment\">// 正确 </span><br><span class=\"hljs-comment\">/*-------------------------------------*/</span><br><span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;  <span class=\"hljs-comment\">// p1指针指向的内存地址是不可改变的</span><br>*p1 = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 正确</span><br>p1 = aPtr; <span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-comment\">/*-------------------------------------*/</span><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;  <span class=\"hljs-comment\">// p2指针指向的内存地址不可改变，内存地址中的量也不可改变</span><br>*p2 = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 报错</span><br>p2 = aPtr; <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure></li>\n<li>定义类中的方法，承诺这个方法不会修改变量（const只能修饰类中的方法）<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entity</span>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-type\">int</span> m_X, m_Y;<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">GetX</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>&#123;<br>      <span class=\"hljs-keyword\">return</span> m_X;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetX</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span></span>&#123;<br>      m_X = x;<br>   &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<img src=\"/article_img/2023-04-21-13-49-02.png\"><br>const如果只是一个承诺那它是不是没什么实际的用处呢？当然不是！按照下图，GetX()<strong>必须</strong>用const修饰，因为函数<strong>Print(const Entity&amp; e)</strong> 的参数是一个<strong>常引用</strong>（类比上面的const int* p），意味着其引用的对象（也就是自身，因为引用只是一个别名）是一个常量，那就要确保在函数中不能对自己这个常量进行修改，就只能调用被const修饰的函数。<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-04-21-13-52-38.png\"></th>\n<th><img src=\"/article_img/2023-04-21-14-03-00.png\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>因此，如果没有修改类或者不应该修改类时，总是把这个方法标记为const</strong></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h2 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h2><p><strong>枚举类型本质就是整型</strong>，下面的LevelError，LevelWarning，LevelInfo值就是0，1，2；因此枚举也可以直接进行整型的大小比较。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Level</span>&#123;<br>   LevelError, LevelWarning, LevelInfo<br>&#125;；<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>   Level l = LevelError;<br>   <span class=\"hljs-keyword\">if</span>(l &gt; <span class=\"hljs-number\">0</span>)&#123;<br>      <span class=\"hljs-comment\">//Do something</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><p><strong>总是使用构造函数初始化列表！</strong>，不适用函数初始化列表会导致一些变量（比如下面的m_A）被初始化多次，造成性能浪费。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-04-21-14-35-19.png\"></th>\n<th><img src=\"/article_img/2023-04-21-14-36-18.png\"></th>\n</tr>\n</thead>\n</table>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>继承的基本写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entity</span>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-type\">float</span> X, Y;<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> xa, <span class=\"hljs-type\">float</span> ya)</span></span>&#123;<br>      X += xa;<br>      Y += ya;<br>   &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Player</span> : <span class=\"hljs-keyword\">public</span> Entity&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* Name;<br><br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintName</span><span class=\"hljs-params\">()</span></span>&#123;<br>      <span class=\"hljs-comment\">// print name </span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>Player类<strong>不仅</strong>是Player类，它<strong>同样</strong>是一个Entity类。我们可以在任何想要使用Entity的地方使用Player（<strong>多态</strong>）</p>\n<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>虚函数一般通过 <strong>虚函数表（vtable）</strong> 来实现编译，在编译阶段通过查询虚函数表确定该函数的定义。</p>\n<p>在c++11中允许用 <strong>override</strong> 标注被重写的虚函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entity</span>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-type\">float</span> X, Y;<br>   <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* Name;<br>   <span class=\"hljs-built_in\">Entity</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)&#123; Name = name; &#125; <span class=\"hljs-comment\">// 构造函数</span><br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> xa, <span class=\"hljs-type\">float</span> ya)</span></span>&#123;<br>      <span class=\"hljs-comment\">// move</span><br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintName</span><span class=\"hljs-params\">()</span></span>&#123;   <span class=\"hljs-comment\">// 虚函数基本用法</span><br>      <span class=\"hljs-comment\">// print entity&#x27;s name </span><br>   &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Player</span> : <span class=\"hljs-keyword\">public</span> Entity&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span> </span>&#123;<br>      <span class=\"hljs-comment\">// print player&#x27;s name </span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"纯虚函数（接口）\"><a href=\"#纯虚函数（接口）\" class=\"headerlink\" title=\"纯虚函数（接口）\"></a>纯虚函数（接口）</h2><p>纯虚函数的本质和其他语言中的接口相同，它是一种特殊的虚函数，在父类中不需要实现，而在子类中<strong>必须</strong>实现。</p>\n<p>包含纯虚函数的类不能被实例化，因为纯虚函数没有被定义。<strong>只能实例化一个实现了所有纯虚函数的类。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Printable</span>&#123;  <br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">GetClassName</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 纯虚函数</span><br>&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entity</span> : <span class=\"hljs-keyword\">public</span> Printable&#123;  <span class=\"hljs-comment\">// 继承自Printable</span><br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">GetClassName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Entity&quot;</span> &lt;&lt; std::endl; &#125; <br>&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Player</span> : <span class=\"hljs-keyword\">public</span> Entity&#123;   <span class=\"hljs-comment\">// 继承自Entity</span><br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">GetClassName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Player&quot;</span> &lt;&lt; std::endl; &#125;   <span class=\"hljs-comment\">// 还需要再次定义，否则就会调用Entity中的GetClassName()</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">(Printable* obj)</span></span>&#123;<br>   std::cout &lt;&lt; obj-&gt;GetClassName &lt;&lt; std::endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>   Entity* e = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Entity</span>();<br>   Player* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Player</span>();<br>   <span class=\"hljs-built_in\">Print</span>(e);<br>   <span class=\"hljs-built_in\">Print</span>(p);<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">输出：</span><br><span class=\"hljs-comment\">Entity</span><br><span class=\"hljs-comment\">Player</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"操作符和操作符重载\"><a href=\"#操作符和操作符重载\" class=\"headerlink\" title=\"操作符和操作符重载\"></a>操作符和操作符重载</h1><p>操作符本质就是函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Vector2</span> &#123;<br>    <span class=\"hljs-type\">float</span> x, y;<br>    <span class=\"hljs-built_in\">Vector2</span>(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y) :<span class=\"hljs-built_in\">x</span>(x), <span class=\"hljs-built_in\">y</span>(y) &#123;&#125;<br><br>    <span class=\"hljs-function\">Vector2 <span class=\"hljs-title\">Add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Vector2&amp; other)</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Vector2</span>(x + other.x, y + other.y);<br>    &#125;<br>    Vector2 <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Vector2&amp; other) <span class=\"hljs-type\">const</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Add</span>(other);<br>    &#125;<br><br>    <span class=\"hljs-function\">Vector2 <span class=\"hljs-title\">Multiply</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Vector2&amp; other)</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Vector2</span>(x * other.x, y * other.y);<br>    &#125;<br>    Vector2 <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Vector2&amp; other) <span class=\"hljs-type\">const</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Multiply</span>(other);<br>    &#125;<br><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>==(<span class=\"hljs-type\">const</span> Vector2&amp; other) <span class=\"hljs-type\">const</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x == other.x &amp;&amp; y == other.y;<br>    &#125;<br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> Vector2&amp; other) <span class=\"hljs-type\">const</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> !(*<span class=\"hljs-keyword\">this</span>==other);<br>    &#125;<br>&#125;;<br><br>std::ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class=\"hljs-type\">const</span> Vector2&amp; other) &#123;<br>    stream &lt;&lt; other.x &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; other.y;<br>    <span class=\"hljs-keyword\">return</span> stream;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":6277,"excerpt":"<p>复习C++</p>","more":"<p>主要参考 <a href=\"https://www.bilibili.com/video/BV1qh411p7Sa?p=6&vd_source=93b215eab72b2548f75d0772e28f8b20\">Cherno’s C++ 教程</a></p>\n<h1 id=\"C-从文本到程序\"><a href=\"#C-从文本到程序\" class=\"headerlink\" title=\"C++从文本到程序\"></a>C++从文本到程序</h1><p>我们编写的代码本质就是文本（text），要让这个文本变成机器可以执行的应用（binary），需要有两个主要的操作：编译（compiling）和链接（linking）。</p>\n<p>当我们按下编译键（ctrl+F7）时只会进行编译，按下build键时会先编译后链接。</p>\n<h1 id=\"C-编译器（Compiling）\"><a href=\"#C-编译器（Compiling）\" class=\"headerlink\" title=\"C++编译器（Compiling）\"></a>C++编译器（Compiling）</h1><p>C++编译器的工作是将<strong>文本</strong>（.cpp文件或者.h文件）转换为<strong>obj</strong>文件，也就是机器语言。</p>\n<p>说到底就是编译器把代码转化为constant data或者instructions</p>\n<p><strong>编译的基本步骤</strong></p>\n<ol>\n<li>需要<strong>预处理（pre-process）</strong> 代码，处理所有的预处理语句（preprocessor）</li>\n<li>编辑<strong>解释（tokenizing）</strong>和<strong>解析（parsing）</strong>，将c++文件里的这些文本翻译成编译器可以理解和处理的语句<br>结果就是创建<strong>抽象语法树（abstract syntax tree）</strong></li>\n<li>根据这颗抽象语法树产生cpu真正执行的机器码</li>\n</ol>\n<h2 id=\"编译单元（translation-unit）和文件的关系\"><a href=\"#编译单元（translation-unit）和文件的关系\" class=\"headerlink\" title=\"编译单元（translation unit）和文件的关系\"></a>编译单元（translation unit）和文件的关系</h2><p>C++不关心文件（file），是什么文件对编译器来说并没有硬性要求，编译器会默认cpp文件是C++文件，h文件是header文件，但是这只是默认，完全可以自定义另一种文件.cherno文件是C++文件，编译器就会将cherno文件当作C++文件处理。</p>\n<p>一个<strong>编译单元（translation unit）</strong> 对应一个<strong>obj文件</strong>，一般都是每个文件是一个编译单元，但是如果使用了#include，将别的文件包含在当前的文件中（本质就是创建了一个大的cpp文件，里面有很多cpp文件），且只编译当前这个文件，那么这个文件和他include的文件组成一个编译单元，也就只会得到一个obj文件。</p>\n<h2 id=\"预处理（pre-process）\"><a href=\"#预处理（pre-process）\" class=\"headerlink\" title=\"预处理（pre-process）\"></a>预处理（pre-process）</h2><p><strong>#include</strong>的工作原理就是找到你include的文件，之后<strong>复制</strong>其全部内容到当前的文件。</p>\n<p><strong>#define</strong>的工作原理就是用anything替换INTEGER</p>\n<p><img src=\"/article_img/2023-04-19-12-13-27.png\"></p>\n<p>Math.i是生成的预处理文件，可以在项目属性里设置生成预处理文件，但是这样VS就不会生成obj文件了。</p>\n<h2 id=\"obj文件\"><a href=\"#obj文件\" class=\"headerlink\" title=\"obj文件\"></a>obj文件</h2><p>obj文件就已经是机器码了：<br><img src=\"/article_img/2023-04-19-12-51-20.png\"></p>\n<p>如果选择了<strong>优化</strong>，在编译阶段就会对代码进行优化，比如删掉未使用的代码，计算所有的常量，删掉多余的寄存器等等。而为了使Debug方便，VS在Debug模式下默认禁止代码优化，就导致其运行起来较慢。</p>\n<h1 id=\"C-链接器（Linking）\"><a href=\"#C-链接器（Linking）\" class=\"headerlink\" title=\"C++链接器（Linking）\"></a>C++链接器（Linking）</h1><p>当我们将每个编译单元编译成一个Obj文件之后，这些文件是独立的，并不能进行交流，而我们经常将不同的代码写在不同的文件中，因此我们需要<strong>链接（Linking）</strong>，将这些独立的Obj文件联系起来。就算我们将所有的代码都写在一个文件中，我们也需要告知程序的入口（main函数）在哪，也需要链接操作。</p>\n<h2 id=\"常见的链接错误\"><a href=\"#常见的链接错误\" class=\"headerlink\" title=\"常见的链接错误\"></a>常见的链接错误</h2><ol>\n<li>unresolved external symbol（未解决的外部符号）：链接器找不到他需要的东西</li>\n<li>one or more multiply defined symbols found（重复定义）：链接器不知道选择哪个<br>常见于include头文件时，可以使用static，inline或者移动函数定义的方式（关键点就是理解include实际上就是复制粘贴！）</li>\n</ol>\n<h1 id=\"VS设置\"><a href=\"#VS设置\" class=\"headerlink\" title=\"VS设置\"></a>VS设置</h1><h2 id=\"Output\"><a href=\"#Output\" class=\"headerlink\" title=\"Output\"></a>Output</h2><p>输出目录：$(SolutionDir)bin$(Platform)$(Configuration)\\</p>\n<p>中间目录：$(SolutionDir)bin\\intermediates$(Platform)$(Configuration)\\  </p>\n<p><img src=\"/article_img/2023-04-19-16-20-25.png\"></p>\n<p>可以使结构清晰，方便查找。</p>\n<h1 id=\"Static关键字\"><a href=\"#Static关键字\" class=\"headerlink\" title=\"Static关键字\"></a>Static关键字</h1><h2 id=\"在类或结构体外\"><a href=\"#在类或结构体外\" class=\"headerlink\" title=\"在类或结构体外\"></a>在类或结构体外</h2><p>类外的static修饰的符号在link阶段是<strong>局部</strong>的，也就是说它只对定义它的 <strong>编译单元（.obj）</strong> 可见。</p>\n<p>当链接器（Linker）工作时，他不会找static修饰的变量，如果不是static修饰的全局变量，在link阶段就会随着链接而变成一个“<strong>整个项目的全局变量</strong>”，因为每一个使用到这个全局变量的编译单元都会去其他编译单元中寻找这个全局变量，如果不同的编译单元中定义了命名相同的全局变量，就会在链接阶段报重复定义的错。</p>\n<p>假如在头文件中定义static变量，之后在不同的cpp文件中#include这个头文件，那么其实这些不同文件中的变量是相互独立的（因为#include就是复制，相当于分别在不同的文件中定义了static变量）</p>\n<h3 id=\"extern\"><a href=\"#extern\" class=\"headerlink\" title=\"extern\"></a>extern</h3><p>extern表示其修饰的变量或函数需要在其他编译单元中寻找。</p>\n<p>因此：<strong>尽量让所有的全局变量和全局函数都被static修饰</strong></p>\n<h2 id=\"在类或结构体内\"><a href=\"#在类或结构体内\" class=\"headerlink\" title=\"在类或结构体内\"></a>在类或结构体内</h2><p>类内的static修饰的符号表示这部分内存是这个类的<strong>所有实例共享的</strong>，静态方法（static method）不能访问任何非静态的变量或方法（<strong>因为类内的static只会被实例化一次，也可以理解为静态方法没有类实例，它并不能得到当前被实例化对象的信息</strong>），类中的非静态方法之所以可以访问类中的变量是因为有个隐含的参数：<strong>this指针</strong>，而静态方法没有this指针，就当然不能访问非静态的成员了。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span>&#123;<br>   <span class=\"hljs-type\">int</span> a,b;<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span></span>&#123;<br>      std::cout&lt;&lt; a &lt;&lt; , &lt;&lt; b &lt;&lt;std::endl;<br>   &#125;<br>   <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">   这个函数在编译阶段就会变成下面这样</span><br><span class=\"hljs-comment\">   void print(this)&#123;</span><br><span class=\"hljs-comment\">      std::cout&lt;&lt; this.a &lt;&lt; , &lt;&lt; this.b &lt;&lt;std::endl;</span><br><span class=\"hljs-comment\">   &#125;</span><br><span class=\"hljs-comment\">   */</span><br><br>   <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Sprint</span><span class=\"hljs-params\">()</span></span>&#123;<br>      std::cout&lt;&lt; a &lt;&lt; , &lt;&lt; b &lt;&lt;std::endl;  <span class=\"hljs-comment\">// 编译无法通过，静态方法不能访问非静态变量</span><br>   &#125;<br>      <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">   这个函数在编译阶段就会变成下面这样，根本不知道a，b是什么</span><br><span class=\"hljs-comment\">   void print()&#123;</span><br><span class=\"hljs-comment\">      std::cout&lt;&lt; a &lt;&lt; , &lt;&lt; b &lt;&lt;std::endl;</span><br><span class=\"hljs-comment\">   &#125;</span><br><span class=\"hljs-comment\">   */</span><br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"static关键字使用场景\"><a href=\"#static关键字使用场景\" class=\"headerlink\" title=\"static关键字使用场景\"></a>static关键字使用场景</h2><ol>\n<li>作用域是局部作用域，生命周期是整个程序的生命周期<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">function</span><span class=\"hljs-params\">()</span></span>&#123;<br>   <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;<br>   i++;<br>   std::cout&lt;&lt; i &lt;&lt;std::endl;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n<li>单例模式（只有一个实例），这应该是Cherno自己的写法一般也不这么写？<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Singleton</span>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">static</span> Singleton&amp; <span class=\"hljs-title\">Get</span><span class=\"hljs-params\">()</span></span>&#123;<br>      <span class=\"hljs-type\">static</span> Singleton instance;<br>      <span class=\"hljs-keyword\">return</span> instance;<br>   &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>   Singleton::<span class=\"hljs-built_in\">Get</span>();<br>   <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h1 id=\"const关键字\"><a href=\"#const关键字\" class=\"headerlink\" title=\"const关键字\"></a>const关键字</h1><p>Cherno把const称为一个假的关键字，因为它并不会对产生的代码造成什么实质上的影响，它只是一种 <strong>承诺</strong> ，承诺这是一个不会被改变的常量，用来方便编程。</p>\n<h2 id=\"const常见用法\"><a href=\"#const常见用法\" class=\"headerlink\" title=\"const常见用法\"></a>const常见用法</h2><ol>\n<li>定义常量<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> MAX_SPEED = <span class=\"hljs-number\">50</span>;<br></code></pre></td></tr></table></figure></li>\n<li>定义指针<strong>本身</strong>是常量还是指针<strong>指向的内容</strong>的常量<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-type\">int</span>* aPtr = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-number\">2</span>);<br><span class=\"hljs-comment\">/*-------------------------------------*/</span><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* p0 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;  <span class=\"hljs-comment\">// p0指针指向的内存存的是不可改变的常量，等价于：int const* p0 = new int;</span><br>*p0 = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 报错</span><br>p0 = aPtr; <span class=\"hljs-comment\">// 正确 </span><br><span class=\"hljs-comment\">/*-------------------------------------*/</span><br><span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;  <span class=\"hljs-comment\">// p1指针指向的内存地址是不可改变的</span><br>*p1 = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 正确</span><br>p1 = aPtr; <span class=\"hljs-comment\">// 报错</span><br><span class=\"hljs-comment\">/*-------------------------------------*/</span><br><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span>* <span class=\"hljs-type\">const</span> p2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">int</span>;  <span class=\"hljs-comment\">// p2指针指向的内存地址不可改变，内存地址中的量也不可改变</span><br>*p2 = <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 报错</span><br>p2 = aPtr; <span class=\"hljs-comment\">// 报错</span><br></code></pre></td></tr></table></figure></li>\n<li>定义类中的方法，承诺这个方法不会修改变量（const只能修饰类中的方法）<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entity</span>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-type\">int</span> m_X, m_Y;<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">GetX</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>&#123;<br>      <span class=\"hljs-keyword\">return</span> m_X;<br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetX</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x)</span></span>&#123;<br>      m_X = x;<br>   &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n<img src=\"/article_img/2023-04-21-13-49-02.png\"><br>const如果只是一个承诺那它是不是没什么实际的用处呢？当然不是！按照下图，GetX()<strong>必须</strong>用const修饰，因为函数<strong>Print(const Entity&amp; e)</strong> 的参数是一个<strong>常引用</strong>（类比上面的const int* p），意味着其引用的对象（也就是自身，因为引用只是一个别名）是一个常量，那就要确保在函数中不能对自己这个常量进行修改，就只能调用被const修饰的函数。<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-04-21-13-52-38.png\"></th>\n<th><img src=\"/article_img/2023-04-21-14-03-00.png\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td><strong>因此，如果没有修改类或者不应该修改类时，总是把这个方法标记为const</strong></td>\n<td></td>\n</tr>\n</tbody></table>\n</li>\n</ol>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><h2 id=\"枚举类型\"><a href=\"#枚举类型\" class=\"headerlink\" title=\"枚举类型\"></a>枚举类型</h2><p><strong>枚举类型本质就是整型</strong>，下面的LevelError，LevelWarning，LevelInfo值就是0，1，2；因此枚举也可以直接进行整型的大小比较。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Level</span>&#123;<br>   LevelError, LevelWarning, LevelInfo<br>&#125;；<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>   Level l = LevelError;<br>   <span class=\"hljs-keyword\">if</span>(l &gt; <span class=\"hljs-number\">0</span>)&#123;<br>      <span class=\"hljs-comment\">//Do something</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h1 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h1><p><strong>总是使用构造函数初始化列表！</strong>，不适用函数初始化列表会导致一些变量（比如下面的m_A）被初始化多次，造成性能浪费。</p>\n<table>\n<thead>\n<tr>\n<th><img src=\"/article_img/2023-04-21-14-35-19.png\"></th>\n<th><img src=\"/article_img/2023-04-21-14-36-18.png\"></th>\n</tr>\n</thead>\n</table>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><p>继承的基本写法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entity</span>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-type\">float</span> X, Y;<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> xa, <span class=\"hljs-type\">float</span> ya)</span></span>&#123;<br>      X += xa;<br>      Y += ya;<br>   &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Player</span> : <span class=\"hljs-keyword\">public</span> Entity&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* Name;<br><br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintName</span><span class=\"hljs-params\">()</span></span>&#123;<br>      <span class=\"hljs-comment\">// print name </span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>Player类<strong>不仅</strong>是Player类，它<strong>同样</strong>是一个Entity类。我们可以在任何想要使用Entity的地方使用Player（<strong>多态</strong>）</p>\n<h2 id=\"虚函数\"><a href=\"#虚函数\" class=\"headerlink\" title=\"虚函数\"></a>虚函数</h2><p>虚函数一般通过 <strong>虚函数表（vtable）</strong> 来实现编译，在编译阶段通过查询虚函数表确定该函数的定义。</p>\n<p>在c++11中允许用 <strong>override</strong> 标注被重写的虚函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entity</span>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-type\">float</span> X, Y;<br>   <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* Name;<br>   <span class=\"hljs-built_in\">Entity</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)&#123; Name = name; &#125; <span class=\"hljs-comment\">// 构造函数</span><br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Move</span><span class=\"hljs-params\">(<span class=\"hljs-type\">float</span> xa, <span class=\"hljs-type\">float</span> ya)</span></span>&#123;<br>      <span class=\"hljs-comment\">// move</span><br>   &#125;<br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintName</span><span class=\"hljs-params\">()</span></span>&#123;   <span class=\"hljs-comment\">// 虚函数基本用法</span><br>      <span class=\"hljs-comment\">// print entity&#x27;s name </span><br>   &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Player</span> : <span class=\"hljs-keyword\">public</span> Entity&#123;<br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">PrintName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span> </span>&#123;<br>      <span class=\"hljs-comment\">// print player&#x27;s name </span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<h2 id=\"纯虚函数（接口）\"><a href=\"#纯虚函数（接口）\" class=\"headerlink\" title=\"纯虚函数（接口）\"></a>纯虚函数（接口）</h2><p>纯虚函数的本质和其他语言中的接口相同，它是一种特殊的虚函数，在父类中不需要实现，而在子类中<strong>必须</strong>实现。</p>\n<p>包含纯虚函数的类不能被实例化，因为纯虚函数没有被定义。<strong>只能实例化一个实现了所有纯虚函数的类。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Printable</span>&#123;  <br>   <span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">GetClassName</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 纯虚函数</span><br>&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Entity</span> : <span class=\"hljs-keyword\">public</span> Printable&#123;  <span class=\"hljs-comment\">// 继承自Printable</span><br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">GetClassName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Entity&quot;</span> &lt;&lt; std::endl; &#125; <br>&#125;;<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Player</span> : <span class=\"hljs-keyword\">public</span> Entity&#123;   <span class=\"hljs-comment\">// 继承自Entity</span><br><span class=\"hljs-keyword\">public</span>:<br>   <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">GetClassName</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">override</span> </span>&#123; std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Player&quot;</span> &lt;&lt; std::endl; &#125;   <span class=\"hljs-comment\">// 还需要再次定义，否则就会调用Entity中的GetClassName()</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">Print</span><span class=\"hljs-params\">(Printable* obj)</span></span>&#123;<br>   std::cout &lt;&lt; obj-&gt;GetClassName &lt;&lt; std::endl;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span>&#123;<br>   Entity* e = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Entity</span>();<br>   Player* p = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Player</span>();<br>   <span class=\"hljs-built_in\">Print</span>(e);<br>   <span class=\"hljs-built_in\">Print</span>(p);<br>&#125;<br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">输出：</span><br><span class=\"hljs-comment\">Entity</span><br><span class=\"hljs-comment\">Player</span><br><span class=\"hljs-comment\">*/</span><br></code></pre></td></tr></table></figure>\n\n<h1 id=\"操作符和操作符重载\"><a href=\"#操作符和操作符重载\" class=\"headerlink\" title=\"操作符和操作符重载\"></a>操作符和操作符重载</h1><p>操作符本质就是函数。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Vector2</span> &#123;<br>    <span class=\"hljs-type\">float</span> x, y;<br>    <span class=\"hljs-built_in\">Vector2</span>(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y) :<span class=\"hljs-built_in\">x</span>(x), <span class=\"hljs-built_in\">y</span>(y) &#123;&#125;<br><br>    <span class=\"hljs-function\">Vector2 <span class=\"hljs-title\">Add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Vector2&amp; other)</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Vector2</span>(x + other.x, y + other.y);<br>    &#125;<br>    Vector2 <span class=\"hljs-keyword\">operator</span>+(<span class=\"hljs-type\">const</span> Vector2&amp; other) <span class=\"hljs-type\">const</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Add</span>(other);<br>    &#125;<br><br>    <span class=\"hljs-function\">Vector2 <span class=\"hljs-title\">Multiply</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> Vector2&amp; other)</span> <span class=\"hljs-type\">const</span> </span>&#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Vector2</span>(x * other.x, y * other.y);<br>    &#125;<br>    Vector2 <span class=\"hljs-keyword\">operator</span>*(<span class=\"hljs-type\">const</span> Vector2&amp; other) <span class=\"hljs-type\">const</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">Multiply</span>(other);<br>    &#125;<br><br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>==(<span class=\"hljs-type\">const</span> Vector2&amp; other) <span class=\"hljs-type\">const</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> x == other.x &amp;&amp; y == other.y;<br>    &#125;<br>    <span class=\"hljs-type\">bool</span> <span class=\"hljs-keyword\">operator</span>!=(<span class=\"hljs-type\">const</span> Vector2&amp; other) <span class=\"hljs-type\">const</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> !(*<span class=\"hljs-keyword\">this</span>==other);<br>    &#125;<br>&#125;;<br><br>std::ostream&amp; <span class=\"hljs-keyword\">operator</span>&lt;&lt;(std::ostream&amp; stream, <span class=\"hljs-type\">const</span> Vector2&amp; other) &#123;<br>    stream &lt;&lt; other.x &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span> &lt;&lt; other.y;<br>    <span class=\"hljs-keyword\">return</span> stream;<br>&#125;<br></code></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"clgkjigle0001w0je5zy5cbu4","category_id":"clgkjiglh0003w0je4je3fdm4","_id":"clgkjiglo000dw0jeebhb91e3"},{"post_id":"clgkjiglg0002w0jeh5n4fklm","category_id":"clgkjigll0008w0je1f6ihaxu","_id":"clgkjiglr000jw0je8k5ub5k0"},{"post_id":"clgkjiglj0005w0je5tne58oy","category_id":"clgkjiglo000ew0jeg1vo1yku","_id":"clgkjiglv000qw0jegup8ca63"},{"post_id":"clgkjiglk0006w0jecfsj7o2h","category_id":"clgkjiglo000ew0jeg1vo1yku","_id":"clgkjiglw000vw0je9xq66oqy"},{"post_id":"clgkjiglv000sw0je6r7ifac3","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjigly0012w0jebvxq83hk"},{"post_id":"clgkjiglk0007w0je4nht6ilw","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjiglz0017w0je1r5m8qq1"},{"post_id":"clgkjiglw000uw0je9f1qbtd1","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjiglz001aw0jefu7o7vm1"},{"post_id":"clgkjiglx000zw0jegf9xgauy","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjigm2001fw0jeaxr6amje"},{"post_id":"clgkjigln000bw0je4mvv08u1","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjigm3001iw0je4q5699vn"},{"post_id":"clgkjigly0016w0je9upeflia","category_id":"clgkjiglo000ew0jeg1vo1yku","_id":"clgkjigm4001mw0jecwbn8i2u"},{"post_id":"clgkjiglo000cw0jec5nr74tc","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjigm5001pw0jeebz70njn"},{"post_id":"clgkjigm0001ew0je93hbaule","category_id":"clgkjiglo000ew0jeg1vo1yku","_id":"clgkjigm6001tw0jehvhq1lr3"},{"post_id":"clgkjiglq000gw0jeejqx53ow","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjigm7001ww0jegn835rdv"},{"post_id":"clgkjigm3001lw0je5r671gtx","category_id":"clgkjiglo000ew0jeg1vo1yku","_id":"clgkjigm80020w0je6ba9f0jc"},{"post_id":"clgkjiglq000iw0je4u2eee3u","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjigm90023w0jehkhtdfrp"},{"post_id":"clgkjigls000mw0je5pkv9jrp","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjigma0027w0je76qi5tss"},{"post_id":"clgkjiglt000ow0jegn3kfo1l","category_id":"clgkjiglv000pw0je6qs64gy0","_id":"clgkjigmb002aw0jebz611jg8"},{"post_id":"clgkjiglx0011w0jeahvt9q2c","category_id":"clgkjigm90024w0je3qjrh5if","_id":"clgkjigmc002fw0jeg4c7eerr"},{"post_id":"clgkjigmb002bw0jee2rf9b6d","category_id":"clgkjiglo000ew0jeg1vo1yku","_id":"clgkjigmc002iw0jecgrf6hzh"},{"post_id":"clgkjiglz0019w0jeeeobc1yp","category_id":"clgkjigmb002cw0je4fwc4ydq","_id":"clgkjigmc002kw0je6fcdaam4"},{"post_id":"clgkjigm2001hw0je5n1349al","category_id":"clgkjigmc002gw0jeflyl17wl","_id":"clgkjigmd002nw0je5vpr9dm4"},{"post_id":"clgkjigm4001ow0je7s5qaodk","category_id":"clgkjigmc002lw0jefad492z7","_id":"clgkjigmd002sw0je5wl06o52"},{"post_id":"clgkjigm6001vw0je7iqi1ucu","category_id":"clgkjigmd002ow0je85ku3yk4","_id":"clgkjigme002xw0je69s0dtxd"},{"post_id":"clgkjigm7001zw0je25pdgfgf","category_id":"clgkjigmd002ow0je85ku3yk4","_id":"clgkjigme0031w0jebanpfg5f"},{"post_id":"clgkjigm80022w0je2jyzhr07","category_id":"clgkjigmd002ow0je85ku3yk4","_id":"clgkjigmf0035w0je5see8ad1"},{"post_id":"clgkjigm90026w0je86zd3fy2","category_id":"clgkjigmd002ow0je85ku3yk4","_id":"clgkjigmf0038w0je0fphhno2"},{"post_id":"clgkjigma0029w0jebuws5iol","category_id":"clgkjigmd002ow0je85ku3yk4","_id":"clgkjigmf003bw0jebsyy1a79"},{"post_id":"clgkjigmj003pw0je3m7a2trh","category_id":"clgkjiglo000ew0jeg1vo1yku","_id":"clgkjigmj003sw0je8p9gfs5x"},{"post_id":"clgkjigmh003lw0jegztp4lmx","category_id":"clgkjigmi003nw0je9q1m1hik","_id":"clgkjigmk003tw0je4c1o0sri"},{"post_id":"clgnb2ch70000woje9qfk036c","category_id":"clgnb2che0001woje0441holu","_id":"clgnb2chl0004woje5npu932b"}],"PostTag":[{"post_id":"clgkjigle0001w0je5zy5cbu4","tag_id":"clgkjigli0004w0je9wh7fllx","_id":"clgkjigln000aw0je9j5a74oe"},{"post_id":"clgkjiglg0002w0jeh5n4fklm","tag_id":"clgkjigll0009w0je4rpxeya4","_id":"clgkjiglq000hw0je2ukm05kv"},{"post_id":"clgkjiglj0005w0je5tne58oy","tag_id":"clgkjigll0009w0je4rpxeya4","_id":"clgkjiglt000nw0jeap00dwyz"},{"post_id":"clgkjiglk0006w0jecfsj7o2h","tag_id":"clgkjiglr000kw0je4xkxaixy","_id":"clgkjiglw000tw0jegovu2me3"},{"post_id":"clgkjiglv000sw0je6r7ifac3","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjiglw000ww0jecw1daf98"},{"post_id":"clgkjiglk0007w0je4nht6ilw","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjiglx0010w0je0cymb95q"},{"post_id":"clgkjiglw000uw0je9f1qbtd1","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjigly0013w0je5p40ajqn"},{"post_id":"clgkjiglx000zw0jegf9xgauy","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjiglz0018w0je6navay78"},{"post_id":"clgkjigln000bw0je4mvv08u1","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjigm0001bw0je6108giym"},{"post_id":"clgkjiglo000cw0jec5nr74tc","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjigm2001gw0jeghlkeig9"},{"post_id":"clgkjiglq000gw0jeejqx53ow","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjigm4001nw0je9a5f1jn8"},{"post_id":"clgkjiglq000iw0je4u2eee3u","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjigm6001uw0je4yjk0rej"},{"post_id":"clgkjigls000mw0je5pkv9jrp","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjigm80021w0jedf2b1lox"},{"post_id":"clgkjiglt000ow0jegn3kfo1l","tag_id":"clgkjiglv000rw0je5m8x6qke","_id":"clgkjigma0028w0jehfwi71r1"},{"post_id":"clgkjiglx0011w0jeahvt9q2c","tag_id":"clgkjigm90025w0jeaq6e6xo8","_id":"clgkjigmb002ew0jeh70je3z5"},{"post_id":"clgkjigly0016w0je9upeflia","tag_id":"clgkjigmb002dw0jedv53732o","_id":"clgkjigmc002jw0jebaob1fi7"},{"post_id":"clgkjiglz0019w0jeeeobc1yp","tag_id":"clgkjigmc002hw0je9sirfakf","_id":"clgkjigmd002qw0je76lrfupy"},{"post_id":"clgkjiglz0019w0jeeeobc1yp","tag_id":"clgkjigmc002mw0je1mu7ciwd","_id":"clgkjigmd002rw0jef8h36e5k"},{"post_id":"clgkjigm0001ew0je93hbaule","tag_id":"clgkjigmb002dw0jedv53732o","_id":"clgkjigme002vw0jefenodo3f"},{"post_id":"clgkjigm2001hw0je5n1349al","tag_id":"clgkjigmd002tw0je7n2dgttq","_id":"clgkjigme002zw0jea7ibeds3"},{"post_id":"clgkjigm3001lw0je5r671gtx","tag_id":"clgkjigme002yw0je6y5yci5j","_id":"clgkjigmf0033w0je4scjaeh5"},{"post_id":"clgkjigm4001ow0je7s5qaodk","tag_id":"clgkjigme0032w0jecumm0zj2","_id":"clgkjigmf0037w0je7zd892fy"},{"post_id":"clgkjigm6001vw0je7iqi1ucu","tag_id":"clgkjigmf0036w0jeb5wkei4r","_id":"clgkjigmf003aw0je6wd6fwrm"},{"post_id":"clgkjigm7001zw0je25pdgfgf","tag_id":"clgkjigmf0036w0jeb5wkei4r","_id":"clgkjigmg003dw0je74btavdy"},{"post_id":"clgkjigm80022w0je2jyzhr07","tag_id":"clgkjigmf0036w0jeb5wkei4r","_id":"clgkjigmg003fw0je8nw21dz6"},{"post_id":"clgkjigm90026w0je86zd3fy2","tag_id":"clgkjigmf0036w0jeb5wkei4r","_id":"clgkjigmg003hw0je7bkl7jmn"},{"post_id":"clgkjigma0029w0jebuws5iol","tag_id":"clgkjigmf0036w0jeb5wkei4r","_id":"clgkjigmg003jw0jeczbeanli"},{"post_id":"clgkjigmb002bw0jee2rf9b6d","tag_id":"clgkjigmb002dw0jedv53732o","_id":"clgkjigmh003kw0jefnp89qzw"},{"post_id":"clgkjigmh003lw0jegztp4lmx","tag_id":"clgkjigmi003ow0je6ge76jek","_id":"clgkjigmj003rw0jecy2057ez"},{"post_id":"clgkjigmj003pw0je3m7a2trh","tag_id":"clgkjigmj003qw0je5o68eg3q","_id":"clgkjigmk003uw0je137v90a1"},{"post_id":"clgnb2ch70000woje9qfk036c","tag_id":"clgnb2chj0002woje4ex43o5h","_id":"clgnb2chk0003woje9pk8fck1"}],"Tag":[{"name":"意识形态","_id":"clgkjigli0004w0je9wh7fllx"},{"name":"3DSlicer","_id":"clgkjigll0009w0je4rpxeya4"},{"name":"Blender","_id":"clgkjiglr000kw0je4xkxaixy"},{"name":"Games101","_id":"clgkjiglv000rw0je5m8x6qke"},{"name":"Games105","_id":"clgkjigm90025w0jeaq6e6xo8"},{"name":"计算机角色动画","_id":"clgkjigmb002dw0jedv53732o"},{"name":"Hexo","_id":"clgkjigmc002hw0je9sirfakf"},{"name":"Fluid","_id":"clgkjigmc002mw0je1mu7ciwd"},{"name":"Ray Tracing","_id":"clgkjigmd002tw0je7n2dgttq"},{"name":"Unity","_id":"clgkjigme002yw0je6y5yci5j"},{"name":"【边学边做】","_id":"clgkjigme0032w0jecumm0zj2"},{"name":"OpenGL","_id":"clgkjigmf0036w0jeb5wkei4r"},{"name":"百人计划","_id":"clgkjigmi003ow0je6ge76jek"},{"name":"NPR","_id":"clgkjigmj003qw0je5o68eg3q"},{"name":"C++","_id":"clgnb2chj0002woje4ex43o5h"}]}}